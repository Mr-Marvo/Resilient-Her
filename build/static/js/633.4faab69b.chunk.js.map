{"version":3,"file":"static/js/633.4faab69b.chunk.js","mappings":"qhDAWMA,EAAS,IAAIC,EAAAA,GCXI,2BDsJDC,EAAtB,oJAKI,SAAmBC,GACf,SAAUA,IAASA,EAAMC,aAC5B,KAPL,GAAwCC,EAAAA,IA4ElBC,EAAtB,WAgFI,6BACIN,EAAOO,cAAP,0CAAiCD,IACjCE,EAAAA,EAAAA,IAAeC,KAAM,eAAe,EACvC,CAnFL,yCAQU,W,+IAC0B,O,UAAMC,EAAAA,EAAAA,IAAkB,CAChDC,MAAOF,KAAKG,SAAS,UACrBC,SAAUJ,KAAKK,cAAcC,OAAM,SAACC,GAGhC,OAAO,IACV,M,uBANGL,EAAAA,EAAAA,MAAOE,EAAAA,EAAAA,SASXI,EAAoB,KAAMC,EAAe,KAAMC,EAAuB,KAEtER,GAASA,EAAMS,gBAIfH,EAAoBN,EAAMS,cAC1BD,EAAuBE,EAAAA,GAAAA,KAAe,cACtCH,EAAeP,EAAMS,cAAcE,IAAI,GAAGC,IAAIJ,I,kBAG3C,CAAEF,kBAAAA,EAAmBC,aAAAA,EAAcC,qBAAAA,EAAsBN,SAAAA,I,+CACnE,GA9BL,yBAkEI,SAAYW,EAAsBC,GAC9B,OAAOhB,KAAKiB,GAAGF,EAAWC,EAC7B,GApEL,4BAuEI,SAAeD,EAAsBC,GACjC,OAAOhB,KAAKkB,IAAIH,EAAWC,EAC9B,IAzEL,yBAqFI,SAAkBtB,GACd,SAAUA,IAASA,EAAMyB,YAC5B,KAvFL,KE9NM5B,EAAS,IAAIC,EAAAA,GCJI,kBDuBvB,SAAS4B,EAAmBC,GACxB,IAAMC,EAAO,SAASC,EAAgBC,GACnB,MAAXA,IAAmBA,EAAU,CAAC,GAClC,IAAMC,EAA2B,GAEjC,GAAIF,EAAUG,gBAAqC,MAAnBF,EAAQG,OACpC,IACIF,EAAaG,KAAK,IAAIL,EAAUG,eAAeL,EAASG,EAAQG,QAClD,CAAhB,MAAMpB,GAAU,CAGtB,GAAIgB,EAAUM,mBAA2C,MAAtBL,EAAQM,UACvC,IACIL,EAAaG,KAAK,IAAIL,EAAUM,kBAAkBR,EAASG,EAAQM,WACrD,CAAhB,MAAMvB,GAAU,CAGtB,GAAIgB,EAAUQ,iBAAuC,MAApBP,EAAQQ,QACrC,IACIP,EAAaG,KAAK,IAAIL,EAAUQ,gBAAgBV,EAASG,EAAQQ,SACnD,CAAhB,MAAMzB,GAAU,CAGtB,GAAIgB,EAAUU,gBAAqC,MAAnBT,EAAQU,OAAgB,CAMpD,IACI,IAAMC,EAAW,IAAIZ,EAAUU,eAAeZ,EAASG,EAAQU,QAC3DC,EAASd,UAAoD,IAHxD,CAAE,SAAU,UAAW,WAGHe,QAAQD,EAASd,QAAQgB,OAClDZ,EAAaG,KAAKO,EAER,CAAhB,MAAM5B,GAAU,CACrB,CAED,GAAIgB,EAAUe,oBAA6C,MAAvBd,EAAQe,WACxC,IACId,EAAaG,KAAK,IAAIL,EAAUe,mBAAmBjB,GACrC,CAAhB,MAAMd,GAAU,CAGtB,GAAIgB,EAAUiB,cAAiC,MAAjBhB,EAAQiB,KAClC,IACI,IACMN,EAAW,IAAIZ,EAAUiB,aAAanB,EAASG,EAAQiB,MACzDN,EAASd,UAAoD,IAFpD,CAAE,WAEce,QAAQD,EAASd,QAAQgB,OAClDZ,EAAaG,KAAKO,EAER,CAAhB,MAAM5B,GAAU,CAGtB,GAA4B,IAAxBkB,EAAaiB,OAAgB,OAAO,KAExC,GAAInB,EAAUoB,iBAAkB,CAC5B,IAAIC,EAAS,EAMb,OALsB,MAAlBpB,EAAQoB,OACRA,EAASpB,EAAQoB,OACE,cAAZvB,IACPuB,EAAS,GAEN,IAAIrB,EAAUoB,iBAAiBlB,EAAcmB,EACvD,CAED,OAAOnB,EAAa,EACvB,EAMD,OAJAH,EAAKuB,UAAY,SAASxB,GACtB,OAAOD,EAAmBC,EAC7B,EAEMC,CACV,CAED,SAASwB,EAAmBC,EAAa1B,GACrC,IAAMC,EAAO,SAASC,EAAgBC,GAClC,OAAID,EAAUyB,gBACH,IAAIzB,EAAUyB,gBAAgBD,EAAK1B,GAGvC,IACV,EAMD,OAJAC,EAAKuB,UAAY,SAASxB,GACtB,OAAOyB,EAAmBC,EAAK1B,EAClC,EAEMC,CACV,CAED,IAAM2B,EAAqB,CACvBC,QAAS,EACTC,WAAY,6CACZd,KAAM,YACNe,iBAAkBhC,EAAmB,cAGnCiC,EAAmB,CACrBH,QAAS,EACTC,WAAY,6CACZd,KAAM,UACNe,iBAAkBhC,EAAmB,YAGnCkC,EAAyB,CAC3BJ,QAAS,GACTb,KAAM,gBACNe,iBAAkBN,EAAmB,sCAAuC,kBAI1ES,EAAwC,CAC1CC,YAAa,CAAEN,QAAS,EAAGb,KAAM,eAEjCY,UAAWA,EACXQ,QAASR,EAETS,OAAQ,CAAER,QAAS,EAAGb,KAAM,UAE5BgB,QAASA,EACTM,QAASN,EAETO,QAAS,CACLV,QAAS,EACTC,WAAY,6CACZd,KAAM,UACNe,iBAAkBhC,EAAmB,YAGzCyC,MAAO,CACHX,QAAS,GACTb,KAAM,QACNe,iBAAkBhC,EAAmB,UAGzC0C,OAAQ,CACJZ,QAAS,EACTC,WAAY,6CACZd,KAAM,SACNe,iBAAkBhC,EAAmB,WAGzC2C,SAAU,CAAEb,QAAS,QAASb,KAAM,YAIpC2B,QAAS,CACLd,QAAS,GACTb,KAAM,UACNe,iBAAkBN,EAAmB,mCAAqC,YAG9EmB,cAAe,CAAEf,QAAS,GAAIb,KAAM,iBAEpCiB,cAAeA,EACfY,eAAgBZ,EAEhBa,aAAc,CACVjB,QAAS,EACTb,KAAM,eACNe,iBAAkBN,EAAmB,qCAAuC,iBAGhFsB,KAAM,CAAElB,QAAS,IAAKb,KAAM,QAE5BgC,MAAO,CACHnB,QAAS,IACTb,KAAM,QACNe,iBAAkBhC,EAAmB,UAEzCkD,SAAU,CAAEpB,QAAS,MAAOb,KAAM,YAElCkC,SAAU,CACNrB,QAAS,GACTb,KAAM,WACNe,iBAAkBhC,EAAmB,aAEzC,iBAAkB,CAAE8B,QAAS,GAAIb,KAAM,kBACvC,kBAAmB,CAAEa,QAAS,IAAKb,KAAM,mBAEzCmC,SAAU,CAAEtB,QAAS,MAAOb,KAAM,YAClC,mBAAoB,CAAEa,QAAS,OAAQb,KAAM,oBAC7C,kBAAmB,CAAEa,QAAS,OAAQb,KAAM,mBAE5CoC,IAAK,CAAEvB,QAAS,GAAIb,KAAM,OAC1BqC,KAAM,CAAExB,QAAS,GAAIb,KAAM,SASzB,SAAUsC,EAAWtD,GAEvB,GAAe,MAAXA,EAAmB,OAAO,KAE9B,GAAwB,kBAAbA,EAAuB,CAC9B,IAAK,IAAMgB,KAAQkB,EAAU,CACzB,IAAMqB,EAAWrB,EAASlB,GAC1B,GAAIuC,EAAS1B,UAAY7B,EACrB,MAAO,CACHgB,KAAMuC,EAASvC,KACfa,QAAS0B,EAAS1B,QAClBC,WAAayB,EAASzB,YAAc,KACpCC,iBAAmBwB,EAASxB,kBAAoB,KAG3D,CAED,MAAO,CACHF,QAAS7B,EACTgB,KAAM,UAEb,CAED,GAAwB,kBAAbhB,EAAuB,CAC9B,IAAMuD,EAAWrB,EAASlC,GAC1B,OAAgB,MAAZuD,EAA2B,KACxB,CACHvC,KAAMuC,EAASvC,KACfa,QAAS0B,EAAS1B,QAClBC,WAAYyB,EAASzB,WACrBC,iBAAmBwB,EAASxB,kBAAoB,KAEvD,CAED,IAAMwB,EAAYrB,EAASlC,EAAQgB,MAGnC,IAAKuC,EAID,MAHgC,kBAArBvD,EAAQ6B,SACf3D,EAAOsF,mBAAmB,0BAA2B,UAAWxD,GAE7DA,EAIa,IAApBA,EAAQ6B,SAAiB7B,EAAQ6B,UAAY0B,EAAS1B,SACtD3D,EAAOsF,mBAAmB,2BAA4B,UAAWxD,GAKrE,IA1PqB3B,EA0PjBoF,EAAuCzD,EAAQ+B,kBAAoB,KAUvE,OATuB,MAAnB0B,GAA2BF,EAASxB,mBAEhC0B,GA7PapF,EA4PGkF,EAASxB,mBA3PY,oBAArB1D,EAAMmD,UA4PJ+B,EAASxB,iBAAiBP,UAAUxB,GAEpCuD,EAASxB,kBAK5B,CACHf,KAAMhB,EAAQgB,KACda,QAAS0B,EAAS1B,QAClBC,WAAa9B,EAAQ8B,YAAcyB,EAASzB,YAAc,KAC1DC,iBAAkB0B,EAEzB,C,0BEzRK,SAAUC,EAAOC,GACnBA,EAAWC,KAAKD,GAEhB,IADA,IAAME,EAAO,GACJC,EAAI,EAAGA,EAAIH,EAAStC,OAAQyC,IACjCD,EAAKtD,KAAKoD,EAASI,WAAWD,IAElC,OAAOE,EAAAA,EAAAA,IAASH,EACnB,CAEK,SAAUI,EAAOJ,GACnBA,GAAOG,EAAAA,EAAAA,IAASH,GAEhB,IADA,IAAIF,EAAW,GACNG,EAAI,EAAGA,EAAID,EAAKxC,OAAQyC,IAC7BH,GAAYO,OAAOC,aAAaN,EAAKC,IAEzC,OAAOM,KAAKT,EACf,CCuBM,IAAMU,EAAb,WAOI,WAAYC,IAAgB,gBACxB5F,EAAAA,EAAAA,IAAeC,KAAM,WAAY2F,IACjC5F,EAAAA,EAAAA,IAAeC,KAAM,OAAQ2F,EAASjD,SAEtC3C,EAAAA,EAAAA,IAAeC,KAAM,eAAgB,CAAC,IACtCD,EAAAA,EAAAA,IAAeC,KAAM,UAAW2F,EAASC,OAAO,IAGhD,IAAK,IAAIT,EAAI,EAAGA,EAAIQ,EAASjD,OAAQyC,IACjCnF,KAAK6F,aAAaF,EAASC,OAAOT,IAAMA,CAE/C,CAlBL,qCAoBI,SAAOzF,GACH,IAAIoG,GAAST,EAAAA,EAAAA,IAAS3F,GAEtB,GAAsB,IAAlBoG,EAAOpD,OAAgB,MAAO,GAGlC,IADA,IAAIqD,EAAS,CAAE,GACNZ,EAAI,EAAGA,EAAIW,EAAOpD,SAAUyC,EAAG,CAEpC,IADA,IAAIa,EAAQF,EAAOX,GACVc,EAAI,EAAGA,EAAIF,EAAOrD,SAAUuD,EACjCD,GAASD,EAAOE,IAAM,EACtBF,EAAOE,GAAKD,EAAQhG,KAAKkG,KACzBF,EAASA,EAAQhG,KAAKkG,KAAQ,EAGlC,KAAOF,EAAQ,GACXD,EAAOnE,KAAKoE,EAAQhG,KAAKkG,MACzBF,EAASA,EAAQhG,KAAKkG,KAAQ,CAErC,CAKD,IAHA,IAAIC,EAAS,GAGJC,EAAI,EAAiB,IAAdN,EAAOM,IAAYA,EAAIN,EAAOpD,OAAS,IAAK0D,EACxDD,GAAUnG,KAAKqG,QAInB,IAAK,IAAIC,EAAIP,EAAOrD,OAAS,EAAG4D,GAAK,IAAKA,EACtCH,GAAUnG,KAAK2F,SAASI,EAAOO,IAGnC,OAAOH,CACV,GArDL,oBAuDI,SAAOzG,GACH,GAAsB,kBAAXA,EACP,MAAM,IAAI6G,UAAU,mBAGxB,IAAIC,EAAuB,GAC3B,GAAqB,IAAjB9G,EAAMgD,OAAgB,OAAO,IAAI+D,WAAWD,GAEhDA,EAAM5E,KAAK,GACX,IAAK,IAAIuD,EAAI,EAAGA,EAAIzF,EAAMgD,OAAQyC,IAAK,CACnC,IAAIuB,EAAO1G,KAAK6F,aAAanG,EAAMyF,IAEnC,QAAawB,IAATD,EACA,MAAM,IAAIE,MAAM,WAAa5G,KAAKkG,KAAO,cAI7C,IADA,IAAIF,EAAQU,EACHT,EAAI,EAAGA,EAAIO,EAAM9D,SAAUuD,EAChCD,GAASQ,EAAMP,GAAKjG,KAAKkG,KACzBM,EAAMP,GAAa,IAARD,EACXA,IAAU,EAGd,KAAOA,EAAQ,GACXQ,EAAM5E,KAAa,IAARoE,GACXA,IAAU,CAEjB,CAGD,IAAK,IAAII,EAAI,EAAG1G,EAAM0G,KAAOpG,KAAKqG,SAAWD,EAAI1G,EAAMgD,OAAS,IAAK0D,EACjEI,EAAM5E,KAAK,GAGf,OAAOyD,EAAAA,EAAAA,IAAS,IAAIoB,WAAWD,EAAMK,WACxC,KA1FL,KA8FMC,GADS,IAAIpB,EAAM,oCACV,IAAIA,EAAM,+D,sBCzIZqB,EAAU,a,sBCiCvB,SAASC,EAAKC,EAAmBC,GAChB,MAATA,IAAiBA,EAAQ,GAC7B,IAAMC,EAAqB,GAErBC,EAAUD,EAAOC,QAavB,OAXiB,SAAXC,EAAqBC,EAAiBJ,GACxCE,EAAQG,KAAKD,GAAK,SAAUE,GACpBN,EAAQ,GAAKO,MAAMC,QAAQF,GAC3BH,EAASG,EAAKN,EAAQ,GAEvBC,EAAOvF,KAAK4F,EAElB,GACJ,CAEDH,CAASJ,EAAOC,GACTC,CACV,CAmGK,SAAUQ,EAAwBnB,GACvC,OALK,SAAuBoB,GAC5B,IAAIC,EAAM,EACV,OAAO,kBAAMD,EAAEC,IAAR,CACP,CAEOC,CAzFF,SAA4BtB,GACjC,IAAIqB,EAAM,EACV,SAASE,IAAQ,OAAQvB,EAAMqB,MAAU,EAAKrB,EAAMqB,IAAS,CAM7D,IAHA,IAAIG,EAAeD,IACfE,EAAQ,EACRC,EAAM,CAAC,EAAG,GACL/C,EAAI,EAAGA,EAAI6C,EAAc7C,IACjC+C,EAAItG,KAAKqG,GAASF,KAInB,IAAII,EAAOJ,IACPK,EAAcP,EAClBA,GAAOM,EAEP,IAAIE,EAAa,EACbC,EAAc,EAClB,SAASC,IAOR,OANkB,GAAdF,IAGHC,EAAeA,GAAe,EAAK9B,EAAMqB,KACzCQ,EAAa,GAENC,KAAiBD,EAAc,CACvC,CAUD,IARA,IACMG,EAAOC,KAAAA,IAAAA,EADH,IAEJC,EAAOF,IAAS,EAChBG,EAAOD,GAAQ,EACfE,EAAOJ,EAAO,EAGhBK,EAAW,EACN1D,EAAI,EAAGA,EARN,GAQaA,IAAK0D,EAAYA,GAAY,EAAKN,IAKzD,IAHA,IAAIO,EAAU,GACVC,EAAM,EACNC,EAAQR,IACC,CAIZ,IAHA,IAAI9I,EAAQ+I,KAAKQ,QAASJ,EAAWE,EAAM,GAAKd,EAAS,GAAKe,GAC1DE,EAAQ,EACRC,EAAMnB,EACHmB,EAAMD,EAAQ,GAAG,CACvB,IAAIE,EAAOF,EAAQC,IAAS,EACxBzJ,EAAQwI,EAAIkB,GACfD,EAAMC,EAENF,EAAQE,CAET,CACD,GAAa,GAATF,EAAY,MAChBJ,EAAQlH,KAAKsH,GAGb,IAFA,IAAIG,EAAIN,EAAMN,KAAKQ,MAAMD,EAAQd,EAAIgB,GAAWjB,GAC5CqB,EAAIP,EAAMN,KAAKQ,MAAMD,EAAQd,EAAIgB,EAAM,GAAKjB,GAAS,EAC9B,KAAlBoB,EAAIC,GAAKZ,IACjBG,EAAYA,GAAY,EAAKD,EAAOL,IACpCc,EAAKA,GAAK,EAAKT,EACfU,EAAKA,GAAK,EAAKV,EAAO,EAEvB,KAAOS,GAAKC,EAAIX,GACfE,EAAYA,EAAWH,EAAUG,GAAY,EAAMD,IAAS,EAAML,IAClEc,EAAKA,GAAK,EAAKX,EACfY,GAAMA,EAAIZ,IAAS,EAAKA,EAAO,EAEhCK,EAAMM,EACNL,EAAQ,EAAIM,EAAID,CAChB,CACD,IAAIE,EAASvB,EAAe,EAC5B,OAAOc,EAAQU,KAAI,SAAAC,GAClB,OAAQA,EAAIF,GACX,KAAK,EAAG,OAAOA,EAAS,OAAY/C,EAAM4B,MAAkB,GAAO5B,EAAM4B,MAAkB,EAAK5B,EAAM4B,MACtG,KAAK,EAAG,OAAOmB,EAAS,KAAU/C,EAAM4B,MAAkB,EAAK5B,EAAM4B,MACrE,KAAK,EAAG,OAAOmB,EAAS/C,EAAM4B,KAC9B,QAAS,OAAOqB,EAAI,EAErB,GACD,CASoBC,CAAkBlD,GACtC,CAGK,SAAUmD,EAAOxE,GACtB,OAAY,EAAJA,GAAWA,GAAK,EAAMA,GAAK,CACnC,CAQD,SAASyE,EAAeC,EAAWC,GAElC,IADA,IAAIlC,EAAIH,MAAMoC,GACL1E,EAAI,EAAGsE,GAAK,EAAGtE,EAAI0E,EAAG1E,IAAKyC,EAAEzC,GAAKsE,GAAK,EAAIK,IACpD,OAAOlC,CACP,CAED,SAASmC,EAAYF,EAAWC,GAE/B,IADA,IAAIlC,EAAIH,MAAMoC,GACL1E,EAAI,EAAGsE,EAAI,EAAGtE,EAAI0E,EAAG1E,IAAKyC,EAAEzC,GAAKsE,GAAKE,EAAOG,KACtD,OAAOlC,CACP,CAEK,SAAUoC,EAAkBF,EAAgBG,GAK9C,IAJA,IAAIrC,EAAIgC,EAAeE,IAAQA,GAC3BD,EAAIC,IACJI,EAAKN,EAAeC,EAAGC,GACvBK,EAtBR,SAAqBN,EAAWC,GAE/B,IADA,IAAIlC,EAAIH,MAAMoC,GACL1E,EAAI,EAAGA,EAAI0E,EAAG1E,IAAKyC,EAAEzC,GAAK,EAAI2E,IACvC,OAAOlC,CACP,CAkBYwC,CAAYP,EAAGC,GACf3E,EAAI,EAAGA,EAAI0E,EAAG1E,IACnB,IAAK,IAAIc,EAAI,EAAGA,EAAIkE,EAAGhF,GAAIc,IACvB2B,EAAEhG,KAAKsI,EAAG/E,GAAKc,GAGvB,OAAOgE,EAASrC,EAAE4B,KAAI,SAAAC,GAAC,OAAIQ,EAAOR,EAAX,IAAiB7B,CAC3C,CA8BD,SAASyC,EAAgBR,EAAWS,EAAWR,GAE3C,IADA,IAAIS,EAAI9C,MAAMoC,GAAGW,UAAK7D,GAAW6C,KAAI,iBAAM,EAAN,IAC5BrE,EAAI,EAAGA,EAAImF,EAAGnF,IACnB4E,EAAYF,EAAGC,GAAM1C,SAAQ,SAACqC,EAAGxD,GAAJ,OAAUsE,EAAEtE,GAAGrE,KAAK6H,EAApB,IAEjC,OAAOc,CACV,CAGD,SAASE,EAAkBH,EAAWR,GACrC,IAAIY,EAAK,EAAIZ,IACTa,EAAKb,IACLK,EAtBC,SAAqCL,GAE1C,IADA,IAAIlC,EAAI,KACK,CACZ,IAAIzC,EAAI2E,IACR,GAAS,GAAL3E,EAAQ,MACZyC,EAAEhG,KAAKuD,EACP,CACD,OAAOyC,CACP,CAcSgD,CAA2Bd,GAEpC,OAAO9C,EADCqD,EAAgBF,EAAGzH,OAAQ,EAAE4H,EAAGR,GAC1BN,KAAI,SAAC5B,EAAGzC,GACpB,IAAMsE,EAAI7B,EAAE,GAAIiD,EAAKjD,EAAEkD,MAAM,GAG9B,OAAOrD,MAAM0C,EAAGhF,IAAIqF,UAAK7D,GAAW6C,KAAI,SAACuB,EAAG9E,GAC3C,IAAI+E,EAAO/E,EAAI0E,EACf,MAAO,CAAClB,EAAIxD,EAAIyE,EAAIG,EAAGrB,KAAI,SAAAyB,GAAC,OAAIA,EAAID,CAAR,IAC5B,GACD,IACD,CAED,SAASE,EAAuBZ,EAAWR,GAG1C,OADQO,EADA,EAAIP,IACe,EAAEQ,EAAGR,GACvBN,KAAI,SAAA5B,GAAC,MAAI,CAACA,EAAE,GAAIA,EAAEkD,MAAM,GAAnB,GACd,CCvND,IAAMK,ECEKxD,EAAwB5C,EAAO,q6cDIpCqG,EAAQ,IAAIC,IAAIrB,EAAkBmB,IAClCG,EAAU,IAAID,IAAIrB,EAAkBmB,IACpCI,EDyJA,SAA0BzB,GAE/B,IADA,IAAI0B,EAAM,KACG,CACZ,IAAIlB,EAAIR,IACR,GAAS,GAALQ,EAAQ,MACZkB,EAAI5J,KAAK6I,EAAkBH,EAAGR,GAC9B,CACD,OAAa,CACZ,IAAIQ,EAAIR,IAAS,EACjB,GAAIQ,EAAI,EAAG,MACXkB,EAAI5J,KAAKsJ,EAAuBZ,EAAGR,GACnC,CACD,OAxJD,SAA6F7C,GAEzF,IADA,IAAME,EAAqC,CAAC,EACnChC,EAAI,EAAGA,EAAI8B,EAAMvE,OAAQyC,IAAK,CACnC,IAAMzF,EAAQuH,EAAM9B,GACpBgC,EAAOzH,EAAM,IAAMA,EAAM,EAC5B,CACD,OAAOyH,CACV,CAiJOsE,CAAmCzE,EAAKwE,GAC/C,CCtKcE,CAAgBP,GACzBQ,ED6NA,SAA0B7B,GAC/B,IAAI8B,EAAS5B,EAAkBF,GAAM+B,MAAK,SAACxC,EAAGC,GAAJ,OAAUD,EAAIC,CAAd,IAC1C,OACA,SAASwC,IACR,IAAIC,EAAW,GACf,OAAa,CACZ,IAAIC,EAAOhC,EAAkBF,EAAM8B,GACnC,GAAmB,GAAfI,EAAKtJ,OAAa,MACtBqJ,EAASnK,KAAK,CAACqK,IAAK,IAAIZ,IAAIW,GAAOE,KAAMJ,KACzC,CACCC,EAASF,MAAK,SAACxC,EAAGC,GAAJ,OAAUA,EAAE2C,IAAIE,KAAO9C,EAAE4C,IAAIE,IAA7B,IACf,IAAIC,EAAOtC,IAOX,MAAO,CAACiC,SAAAA,EAAUM,MANND,EAAO,EAMME,QAJJ,GADrBF,EAAQA,EAAO,EAAG,IAKaG,KAFZ,IADnBH,IAAS,GAG4BI,MADjB,GAARJ,EAEb,CAjBMN,EAkBP,CCjPkBW,CAAgBtB,GAOnC,SAASuB,EAAWrK,GAChB,OAAOsK,EAAAA,EAAAA,IAAiBtK,EAC3B,CAED,SAASuK,EAAYC,GACjB,OAAOA,EAAIC,QAAO,SAAAC,GAAE,OAAU,OAANA,CAAJ,GACvB,CAEK,SAAUC,EAAyB3K,GAAY,gBAClCA,EAAK4K,MAAM,MADuB,IACpD,IAAK,EAAL,qBAAmC,KAA1BC,EAA0B,QAC9BL,EAAMH,EAAWQ,GACrB,IACC,IAAK,IAAI/H,EAAI0H,EAAIM,YAdD,IAc2B,EAAGhI,GAAK,EAAGA,IACrD,GAfe,KAeX0H,EAAI1H,GACP,MAAM,IAAIyB,MAAJ,oCAGR,GAAIiG,EAAInK,QAAU,GAAKmK,EAAIO,OAAM,SAAAL,GAAE,OAAIA,EAAK,GAAT,KApBvB,KAoByCF,EAAI,IApB7C,KAoB8DA,EAAI,GAC7E,MAAM,IAAIjG,MAAJ,0BAIP,CAFC,MAAOyG,GACR,MAAM,IAAIzG,MAAJ,yBAA4BsG,EAA5B,cAAuCG,EAAIC,SACjD,CACD,CAfmD,+BAgBpD,OAAOjL,CACP,CAEK,SAAUkL,EAAclL,GAC7B,OAAO2K,EAGR,SAAmB3K,EAAcmL,GAChC,IAAIC,EAAQf,EAAWrK,GAAMwE,UACzB6G,EAAS,GACb,KAAOD,EAAM/K,QAAQ,CACpB,IAAIiL,EAAQC,EAAuBH,GACnC,GAAIE,EACHD,EAAO9L,KAAP,MAAA8L,GAAM,OAASF,EAAaG,SAD7B,CAIA,IAAIZ,EAAKU,EAAMI,MACf,GAAIzC,EAAM0C,IAAIf,GACbW,EAAO9L,KAAKmL,QAGb,IAAIzB,EAAQwC,IAAIf,GAAhB,CAGA,IAAIF,EAAMtB,EAAOwB,GACjB,IAAIF,EAIJ,MAAM,IAAIjG,MAAJ,kCAAqCmG,EAAGgB,SAAS,IAAIC,gBAH1DN,EAAO9L,KAAP,MAAA8L,GAAM,OAASb,GAHf,CARA,CAeD,CACD,OAAOG,GAGKiB,EAHwB1I,OAAO2I,cAAP,MAAA3I,OAAwBmI,GAIlDO,EAAEE,UAAU,SADvB,IAAaF,CAFZ,CA5BgCE,CAAU9L,EAAMuK,GAChD,CAiCD,SAASgB,EAAuBf,EAAoBuB,G,MAE/CT,EACAU,EAFAnC,EAAOP,EAGP2C,EAAQ,GACRzG,EAAMgF,EAAInK,OACV0L,IAAOA,EAAM1L,OAAS,GAC1B,IAPwE,iBAQvE,IAAIqK,EAAKF,IAAMhF,GAEf,KADAqE,EAA6C,QAAtC,EAAAA,EAAKH,SAASwC,MAAK,SAAA9E,GAAC,OAAIA,EAAEwC,IAAI6B,IAAIf,EAAd,WAAkByB,IAAAA,OAAA,EAAAA,EAAEtC,MACpC,cACX,GAAIA,EAAKK,KACR8B,EAAQtB,OACF,GAAIb,EAAKM,OACXO,IAAOsB,EAAO,cAEnBC,EAAM1M,KAAKmL,GACPb,EAAKI,OACRgC,EAAM1M,KAAK,OACPiG,EAAM,GAAqB,OAAhBgF,EAAIhF,EAAM,IAAcA,KAEpCqE,EAAKG,QACRsB,EAAQW,EAAMxD,QACI,GAAdoB,EAAKG,OAAYsB,EAAMc,OAAO,EAAG,GACjCL,GAAOA,EAAMxM,KAAN,MAAAwM,GAAK,OAASvB,EAAI/B,MAAMjD,GAAKhB,YACxCgG,EAAInK,OAASmF,EAzByD,EAOjEA,GAAK,kBAOQ,KAanB,CACD,OAAO8F,CACP,CErID,IAAMpO,EAAS,IAAIC,EAAAA,GAAOuH,GAIpB2H,GAAQ,IAAIjI,WAAW,IAG7B,SAASkI,GAAeC,GACpB,GAAoB,IAAhBA,EAAKlM,OAAgB,MAAM,IAAIkE,MAAM,qCACzC,OAAOgI,CACV,CAED,SAASC,GAAaxM,GAClB,IAAMmE,GAAQsI,EAAAA,EAAAA,IAAYvB,EAAclL,IAClC0M,EAA2B,GAEjC,GAAoB,IAAhB1M,EAAKK,OAAgB,OAAOqM,EAGhC,IADA,IAAIC,EAAO,EACF7J,EAAI,EAAGA,EAAIqB,EAAM9D,OAAQyC,IAAK,CAIzB,KAHAqB,EAAMrB,KAIZ4J,EAAMnN,KAAK+M,GAAenI,EAAMsE,MAAMkE,EAAM7J,KAC5C6J,EAAO7J,EAAI,EAElB,CAGD,GAAI6J,GAAQxI,EAAM9D,OAAU,MAAM,IAAIkE,MAAM,qCAG5C,OADAmI,EAAMnN,KAAK+M,GAAenI,EAAMsE,MAAMkE,KAC/BD,CACV,CAaK,SAAUE,GAAS5M,GAEA,kBAAVA,GACP9C,EAAOsF,mBAAmB,iCAAkC,OAAQxC,GAMxE,IAHA,IAAI8E,EAA8BuH,GAE5BK,EAAQF,GAAaxM,GACpB0M,EAAMrM,QACTyE,GAAS+H,EAAAA,EAAAA,IAAUC,EAAAA,EAAAA,IAAO,CAAChI,GAAQ+H,EAAAA,EAAAA,GAAUH,EAAMlB,UAGvD,OAAOuB,EAAAA,EAAAA,IAAQjI,EAClB,CAxDDuH,GAAMlE,KAAK,G,2BCAI,IAAIhL,EAAAA,GCXI,cDiBjB,SAAU6P,GAAOnK,GACnB,MAAO,KAAQoK,KAAAA,SAAcC,QAAOlK,EAAAA,EAAAA,IAASH,IAAOsK,OAAO,MAC9D,CEnBM,I,uSCQD,SAAgBC,GAAOC,EAAclO,G,8IA0BtB,OAzBF,MAAXA,IAAmBA,EAAU,CAAC,GAE5BmO,EAAuB,CACzBC,OAASpO,EAAQoO,QAAU,MAC3BC,QAAUrO,EAAQqO,SAAW,CAAC,EAC9BC,KAAOtO,EAAQsO,WAAQnJ,IAGI,IAA3BnF,EAAQuO,iBACRJ,EAAQK,KAAoB,OAC5BL,EAAQM,MAAsB,WAC9BN,EAAQO,YAAkC,cAC1CP,EAAQQ,SAA4B,SACpCR,EAAQS,SAAW,UAGK,MAAxB5O,EAAQ6O,gBACFC,EAAO9O,EAAQ6O,cACZL,OAAQL,EAAQK,KAAqBM,EAAKN,MAC/CM,EAAKL,QAASN,EAAQM,MAAuBK,EAAKL,OAClDK,EAAKJ,cAAeP,EAAQO,YAAmCI,EAAKJ,aACpEI,EAAKH,WAAYR,EAAQQ,SAA6BG,EAAKH,UAC3DG,EAAKF,WAAYT,EAAQS,SAAWE,EAAKF,W,SAG1BG,MAAMb,EAAMC,G,OACtB,OADPa,EAAW,EAAXA,K,UACaA,EAASC,c,eAAtBX,EAAO,EAAPA,KAEAD,EAAwC,CAAC,EAC3CW,EAASX,QAAQzI,QACjBoJ,EAASX,QAAQzI,SAAQ,SAAC1H,EAAOgR,GAC7Bb,EAAQa,EAAIC,eAAiBjR,CAChC,IAE6B8Q,EAASX,QAAU7D,OAAS5E,SAAQ,SAACsJ,GAC/Db,EAAQa,EAAIC,eAAiBH,EAASX,QAAQe,IAAIF,EACrD,I,kBAGE,CACHb,QAASA,EACTgB,WAAYL,EAASM,OACrBC,cAAeP,EAASQ,WACxBlB,MAAMzK,EAAAA,EAAAA,IAAS,IAAIoB,WAAWqJ,M,2CAErC,C,2SC7CKvQ,GAAS,IAAIC,EAAAA,GFTI,aEavB,SAASyR,GAAQC,GACb,OAAO,IAAIC,SAAQ,SAACC,GAChBC,WAAWD,EAASF,EACvB,GACJ,CAED,SAASI,GAAQ5R,EAAY6R,GACzB,GAAa,MAAT7R,EAAiB,OAAO,KAE5B,GAAsB,kBAAXA,EAAuB,OAAOA,EAEzC,IAAI8R,EAAAA,EAAAA,IAAY9R,GAAQ,CACpB,GAAI6R,IAAgC,SAAvBA,EAAKtE,MAAM,KAAK,IAA+C,qBAA9BsE,EAAKtE,MAAM,KAAK,GAAGwE,QAC7D,IACI,OAAOC,EAAAA,EAAAA,IAAahS,EACL,CAAjB,MAAOa,GAAU,CAEvB,OAAO6O,EAAAA,EAAAA,IAAQ1P,EAClB,CAED,OAAOA,CACV,CAuUK,SAAUiS,GAAUC,EAAqCC,EAAeC,GAC1E,IAuBIhC,EAAmB,KACvB,GAAY,MAAR+B,EAAc,CACd/B,GAAOhB,EAAAA,EAAAA,IAAY+C,GAGnB,IAAME,EAAkD,kBAAhBH,EAA6B,CAAE7O,IAAK6O,IAAeI,EAAAA,EAAAA,IAAYJ,GACvG,GAAIG,EAAQlC,QAC6G,IAA7FoC,OAAOjG,KAAK+F,EAAQlC,SAAS/C,QAAO,SAAC1G,GAAD,MAA4B,iBAApBA,EAAEuK,aAAV,IAA6CjO,SAErGqP,EAAQlC,SAAUmC,EAAAA,EAAAA,IAAYD,EAAQlC,SACtCkC,EAAQlC,QAAQ,gBAAkB,yBAGtCkC,EAAQlC,QAAU,CAAE,eAAgB,oBAExC+B,EAAaG,CAChB,CAED,OAzTE,SAAqCH,EAAqC9B,EAAmBgC,GAG/F,IAAMI,EAAuC,kBAAhBN,GAAwD,MAA5BA,EAAWO,cAAyBP,EAAWO,cAAe,GACvH5S,GAAO6S,eAAgBF,EAAe,GAAMA,EAAe,IAAO,EAC9D,oCAAqC,2BAA4BA,GAErE,IAAMG,EAA4C,kBAAhBT,EAA4BA,EAAWS,iBAAkB,KACrFC,EAAgD,kBAAhBV,GAAwE,kBAArCA,EAAWU,qBAAsCV,EAAWU,qBAAsB,IAC3J/S,GAAO6S,eAAgBE,EAAuB,GAAMA,EAAuB,IAAO,EAC9E,4CAA6C,kCAAmCA,GAEpF,IAAMC,EAA4C,kBAAhBX,KAA+BA,EAAWW,iBAEtE1C,EAAqC,CAAC,EAExC9M,EAAc,KAGZvB,EAAmB,CACrBoO,OAAQ,OAGR4C,GAAW,EAEXC,EAAU,KAEd,GAA2B,kBAAhBb,EACP7O,EAAM6O,OAEH,GAA2B,kBAAhBA,EAA0B,CAWxC,GAVkB,MAAdA,GAAwC,MAAlBA,EAAW7O,KACjCxD,GAAOsF,mBAAmB,cAAe,iBAAkB+M,GAG/D7O,EAAM6O,EAAW7O,IAEkB,kBAAxB6O,EAAWa,SAAyBb,EAAWa,QAAU,IAChEA,EAAUb,EAAWa,SAGrBb,EAAW/B,QACX,IAAK,IAAMa,KAAOkB,EAAW/B,QACzBA,EAAQa,EAAIC,eAAiB,CAAED,IAAKA,EAAKhR,MAAO6F,OAAOqM,EAAW/B,QAAQa,KACtE,CAAC,gBAAiB,qBAAqBtO,QAAQsO,EAAIC,gBAAkB,IACrE6B,GAAW,GAOvB,GAFAhR,EAAQkR,YAAcd,EAAWc,UAEV,MAAnBd,EAAWe,MAAuC,MAAvBf,EAAWgB,SAAkB,CAC5B,WAAxB7P,EAAI8P,UAAU,EAAG,KAA8D,IAA3CjB,EAAWkB,6BAC/CvT,GAAOwT,WACH,mDACAvT,EAAAA,GAAAA,OAAAA,iBACA,CAAEwT,SAAU,MAAOjQ,IAAKA,EAAK4P,KAAMf,EAAWe,KAAMC,SAAU,eAItE,IAAMK,EAAgBrB,EAAWe,KAAO,IAAMf,EAAWgB,SACzD/C,EAAO,cAAoB,CACvBa,IAAK,gBACLhR,MAAO,SAAWwT,GAAapE,EAAAA,EAAAA,IAAYmE,IAElD,CAEgC,MAA7BrB,EAAW7B,iBACXvO,EAAQuO,iBAAmB6B,EAAW7B,gBAGX,MAA3B6B,EAAWvB,eACX7O,EAAQ6O,cAAe2B,EAAAA,EAAAA,IAAYJ,EAAWvB,cAErD,CAED,IAAM8C,EAAS,IAAIC,OAAO,6CAA8C,KAClEC,EAActQ,EAAOA,EAAIuQ,MAAMH,GAAS,KAC9C,GAAIE,EACA,IACI,IAAM7C,EAAW,CACbK,WAAY,IACZE,cAAe,KACflB,QAAS,CAAE,eAAgBwD,EAAU,IACrCvD,KAAMyD,EAAaF,EAAU,KAG7BlM,EAAwBqJ,EAASV,KAIrC,OAHIgC,IACA3K,EAAS2K,EAAYtB,EAASV,KAAMU,IAEjCW,QAAQC,QAAoBjK,EAUtC,CARC,MAAO5G,GACLhB,GAAOwT,WAAW,4BAA6BvT,EAAAA,GAAAA,OAAAA,aAA4B,CACvEsQ,KAAMwB,GAAQ+B,EAAU,GAAIA,EAAU,IACtC9S,MAAOA,EACPiT,YAAa,KACbC,cAAe,MACf1Q,IAAKA,GAEZ,CAGD+M,IACAtO,EAAQoO,OAAS,OACjBpO,EAAQsO,KAAOA,EACgB,MAA3BD,EAAQ,kBACRA,EAAQ,gBAAkB,CAAEa,IAAK,eAAgBhR,MAAO,6BAE3B,MAA7BmQ,EAAQ,oBACRA,EAAQ,kBAAoB,CAAEa,IAAK,iBAAkBhR,MAAO6F,OAAOuK,EAAKpN,WAIhF,IAAMgR,EAA2C,CAAC,EAClDzB,OAAOjG,KAAK6D,GAASzI,SAAQ,SAACsJ,GAC1B,IAAMiD,EAAS9D,EAAQa,GACvBgD,EAAYC,EAAOjD,KAAOiD,EAAOjU,KACpC,IACD8B,EAAQqO,QAAU6D,EAElB,IAAME,EAAkB,WACpB,IAAIC,EAAsB,KAuB1B,MAAO,CAAEC,QAtBuB,IAAI3C,SAAQ,SAASC,EAAS2C,GACtDtB,IACAoB,EAAQxC,YAAW,WACF,MAATwC,IACJA,EAAQ,KAERE,EAAOxU,GAAOyU,UAAU,UAAWxU,EAAAA,GAAAA,OAAAA,QAAuB,CACtDgU,YAAalC,GAAQ9P,EAAQsO,KAAM4D,EAAY,iBAC/CD,cAAejS,EAAQoO,OACvB6C,QAASA,EACT1P,IAAKA,KAEZ,GAAE0P,GAEV,IAQiBwB,OANH,WACE,MAATJ,IACJK,aAAaL,GACbA,EAAQ,KACX,EAGJ,CAzBuB,GA2BlBM,EAAgB,W,wJAETC,EAAU,E,YAAGA,EAAUlC,GAAAA,C,gBAIb,OAHX1B,EAA2B,K,kBAGVf,GAAO1M,EAAKvB,G,UAA7BgP,EAAAA,EAAAA,OAEI4D,EAAUlC,GAAAA,C,mBACkB,MAAxB1B,EAASK,YAA8C,MAAxBL,EAASK,WAAe,C,mBAEjDwD,EAAW7D,EAASX,QAAQwE,UAAY,GACvB,QAAnB7S,EAAQoO,SAAoByE,EAASf,MAAM,WAAf,C,uBAC5BvQ,EAAMyN,EAASX,QAAQwE,S,2DAII,MAAxB7D,EAASK,WAAe,C,mBAE3ByD,GAAW,GACXjC,EAAkB,C,gBACP,O,UAAMA,EAAiB+B,EAASrR,G,QAA3CuR,EAAW,EAAXA,K,YAGAA,EAAU,C,gBAWV,OAVIC,EAAQ,EAENC,EAAahE,EAASX,QAAQ,eAEhC0E,EADuB,kBAAhBC,GAA4BA,EAAWlB,MAAM,iBACrB,IAAvBmB,SAASD,GAETlC,EAAuBmC,SAASlP,OAAOkD,KAAKiM,SAAWjM,KAAKkM,IAAI,EAAGP,K,UAIzEnD,GAAQsD,G,iGAQV,OADhB/D,EAAiB,KAAOA,YAEpBoD,EAAeK,SACf1U,GAAOwT,WAAW,mBAAoBvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC9DgU,YAAalC,GAAQ9P,EAAQsO,KAAM4D,EAAY,iBAC/CD,cAAejS,EAAQoO,OACvBgF,YAAa,EAAF,GACX7R,IAAKA,K,WAMb+M,EAAOU,EAASV,KAEhB0C,GAAoC,MAAxBhC,EAASK,WACrBf,EAAO,MACCyC,IAAqB/B,EAASK,WAAa,KAAOL,EAASK,YAAc,OACjF+C,EAAeK,SACf1U,GAAOwT,WAAW,eAAgBvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC1DsR,OAAQN,EAASK,WACjBhB,QAASW,EAASX,QAClBC,KAAMwB,GAAQxB,EAAQU,EAASX,QAAWW,EAASX,QAAQ,gBAAiB,MAC5E2D,YAAalC,GAAQ9P,EAAQsO,KAAM4D,EAAY,iBAC/CD,cAAejS,EAAQoO,OACvB7M,IAAKA,MAIT+O,EAAa,C,gBAEM,O,oBAAMA,EAAYhC,EAAMU,G,eAAjCrJ,EAAAA,EAAAA,KACNyM,EAAeK,S,kBACR9M,G,wCAIH,KAAM0N,eAAiBT,EAAUlC,GAAAA,C,mBAC7BoC,GAAW,GACXjC,EAAkB,C,gBACP,O,UAAMA,EAAiB+B,EAASrR,G,QAA3CuR,EAAAA,EAAAA,K,YAGAA,EAAAA,C,gBAGA,OAFM7B,EAAUH,EAAuBmC,SAASlP,OAAOkD,KAAKiM,SAAWjM,KAAKkM,IAAI,EAAGP,K,UAE7EnD,GAAQwB,G,+CAKtBmB,EAAeK,SACf1U,GAAOwT,WAAW,4BAA6BvT,EAAAA,GAAAA,OAAAA,aAA4B,CACvEsQ,KAAMwB,GAAQxB,EAAQU,EAASX,QAAWW,EAASX,QAAQ,gBAAiB,MAC5EtP,MAAO,EAAF,GACLiT,YAAalC,GAAQ9P,EAAQsO,KAAM4D,EAAY,iBAC/CD,cAAejS,EAAQoO,OACvB7M,IAAKA,I,eAKjB6Q,EAAeK,S,kBAIKnE,G,QA1GsBsE,I,gDA6GvC7U,GAAOwT,WAAW,kBAAmBvT,EAAAA,GAAAA,OAAAA,aAA4B,CACpEgU,YAAalC,GAAQ9P,EAAQsO,KAAM4D,EAAY,iBAC/CD,cAAejS,EAAQoO,OACvB7M,IAAKA,K,iEAEZ,CApHqB,GAsHtB,OAAOoO,QAAQ2D,KAAK,CAAElB,EAAeE,QAASK,GACjD,CA4CUY,CAAgBnD,EAAY9B,GAzCb,SAACpQ,EAAmB8Q,GACtC,IAAIrJ,EAAc,KAClB,GAAa,MAATzH,EACA,IACIyH,EAAS6N,KAAKC,OAAMvD,EAAAA,EAAAA,IAAahS,GAMpC,CALC,MAAOa,GACLhB,GAAOwT,WAAW,eAAgBvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC1DsQ,KAAMpQ,EACNa,MAAOA,GAEd,CAOL,OAJIuR,IACA3K,EAAS2K,EAAY3K,EAAQqJ,IAG1BrJ,CACV,GAwBJ,CAEK,SAAU+N,GAAQ5T,EAAwBE,GAO5C,OANKA,IAAWA,EAAU,CAAC,GAEN,OADrBA,GAAUwQ,EAAAA,EAAAA,IAAYxQ,IACVyH,QAAiBzH,EAAQyH,MAAQ,GACtB,MAAnBzH,EAAQ2T,UAAmB3T,EAAQ2T,QAAU,KACzB,MAApB3T,EAAQ4T,WAAoB5T,EAAQ4T,SAAW,KAE5C,IAAIjE,SAAQ,SAASC,EAAS2C,GAEjC,IAAIF,EAAsB,KACtBwB,GAAgB,EAGdpB,EAAS,WACX,OAAIoB,IACJA,GAAO,EACHxB,GAASK,aAAaL,IACnB,EACV,EAEGrS,EAAQiR,UACRoB,EAAQxC,YAAW,WACX4C,KAAYF,EAAO,IAAInN,MAAM,WACpC,GAAEpF,EAAQiR,UAGf,IAAM6C,EAAa9T,EAAQ8T,WAEvBlB,EAAU,GACd,SAAS5H,IACL,OAAOlL,IAAOiU,MAAK,SAASpO,GAGxB,QAAeR,IAAXQ,EACI8M,KAAY7C,EAAQjK,QAErB,GAAI3F,EAAQgU,SACfhU,EAAQgU,SAASC,KAAK,OAAQjJ,QAE3B,GAAIhL,EAAQkU,UACflU,EAAQkU,UAAUD,KAAK,QAASjJ,QAG7B,IAAK6I,EAAM,CAEd,KADAjB,EACckB,EAEV,YADIrB,KAAYF,EAAO,IAAInN,MAAM,yBAIrC,IAAI6L,EAAUjR,EAAQ4T,SAAWX,SAASlP,OAAOkD,KAAKiM,SAAWjM,KAAKkM,IAAI,EAAGP,KACzE3B,EAAUjR,EAAQyH,QAASwJ,EAAUjR,EAAQyH,OAC7CwJ,EAAUjR,EAAQ2T,UAAW1C,EAAUjR,EAAQ2T,SAEnD9D,WAAW7E,EAAOiG,EACrB,CAED,OAAO,IACV,IAAE,SAASlS,GACJ0T,KAAYF,EAAOxT,EAC1B,GACJ,CACDiM,EACH,GACJ,C,2BCtdYzF,GAAU,kB,wBCYjBxH,GAAS,IAAIC,EAAAA,GAAOuH,IAiBb4O,GAAb,WAGI,6BACI3V,KAAK4V,QAAU5V,KAAK6V,mBACvB,CALL,gDAOI,WAAiB,WACPD,EAA6B,CAAC,EAE9BE,EAAU9V,KAAK8V,QAAQC,KAAK/V,MAC5BgW,EAAYhW,KAAKgW,UAAUD,KAAK/V,MAChCiW,EAAWjW,KAAKiW,SAASF,KAAK/V,MAC9BkF,EAAOlF,KAAKkF,KAAK6Q,KAAK/V,MACtBsP,EAAOtP,KAAKsP,KAAKyG,KAAK/V,MACtBkW,EAAMlW,KAAKkW,IAAIH,KAAK/V,MACpBmW,EAASnW,KAAKmW,OAAOJ,KAAK/V,MAC1BuR,EAAOvR,KAAKuR,KAAKwE,KAAK/V,MAmI5B,OA/HA4V,EAAQQ,YAAc,CAClB9G,KAAMA,EAENiC,KAAMA,EACN8E,WAAYV,EAAUW,UAAUtW,KAAKqW,WAAWN,KAAK/V,MAAO,MAE5DuW,UAAWZ,EAAUW,UAAUhH,EAAM,MACrCkH,YAAab,EAAUW,UAAUH,EAAQ,MACzCM,iBAAkBd,EAAUW,UAAUH,EAAQ,MAE9CO,cAAef,EAAUW,UAAUH,EAAQ,MAE3CQ,KAAMb,EAIN1V,SAAUuV,EAAUW,UAAUN,GAC9BtV,qBAAsBiV,EAAUW,UAAUN,GAC1CvV,aAAckV,EAAUW,UAAUN,GAElCY,SAAUZ,EACVa,GAAIlB,EAAUW,UAAUR,EAAS,MACjCpW,MAAOsW,EACPc,MAAOX,EACPjR,KAAMA,EAENiG,EAAGwK,EAAUW,UAAUtW,KAAK+W,SAC5B9I,EAAG0H,EAAUW,UAAUtW,KAAK+W,SAC5BnP,EAAG+N,EAAUW,UAAUH,GAEvBa,QAASrB,EAAUW,UAAUR,EAAS,MAEtCmB,IAAKtB,EAAUW,UAAUpR,IAG7B0Q,EAAQsB,mBAAqB,CACzBP,KAAMhB,EAAUW,UAAUR,GAC1BgB,MAAOnB,EAAUW,UAAUH,GAC3BS,SAAUjB,EAAUW,UAAUN,GAC9B5V,SAAUuV,EAAUW,UAAUN,GAC9BtV,qBAAsBiV,EAAUW,UAAUN,GAC1CvV,aAAckV,EAAUW,UAAUN,GAClCa,GAAIlB,EAAUW,UAAUR,GACxBpW,MAAOiW,EAAUW,UAAUN,GAC3B9Q,KAAMyQ,EAAUW,WA9CD,SAAC1O,GAAa,OAAO,EAAK1C,KAAK0C,GAAG,EAAQ,IA+CzD2J,KAAMoE,EAAUW,UAAUH,GAC1BE,WAAYV,EAAUW,UAAUtW,KAAKqW,WAAWN,KAAK/V,MAAO,OAGhE4V,EAAQuB,WAAa,CACjBV,iBAAkBN,EAClBK,YAAaL,EACbiB,gBAAiB9H,EACjBwG,QAASA,EACTuB,OAAQ1B,EAAU2B,QAAQhI,GAC1BpK,KAAMA,EACNqS,SAAUpB,EACVI,UAAWjH,GAGfsG,EAAQ4B,QAAU,CACdX,GAAIlB,EAAUW,UAAUtW,KAAK8V,QAAS,MACtCa,KAAMhB,EAAUW,UAAUtW,KAAK8V,QAAS,MACxC2B,gBAAiB9B,EAAUW,UAAUR,EAAS,MAC9CW,iBAAkBN,EAElBuB,KAAM/B,EAAUW,UAAUJ,GAC1ByB,QAAS3B,EACT4B,UAAWjC,EAAUW,UAAUpR,GAC/BqR,UAAWjH,EACX8H,gBAAiB9H,EACjBuI,KAAMlC,EAAU2B,QAAQtX,KAAKmX,WAAWpB,KAAK/V,OAC7CwW,YAAaL,EACbO,cAAef,EAAUW,UAAUH,EAAQ,MAC3C2B,kBAAmB9B,EACnB+B,kBAAmBpC,EAAUW,UAAUN,GACvClF,OAAQ6E,EAAUW,UAAUH,GAC5B5E,KAAMA,GAGVqE,EAAQ1V,MAAQ,CACZoP,KAAMqG,EAAUW,UAAUhH,GAC1B0I,WAAY1I,EACZ6G,OAAQA,EAER8B,UAAW9B,EACXW,MAAOnB,EAAUW,UAAUJ,GAC3BgC,WAAYlY,KAAKkY,WAAWnC,KAAK/V,MAEjC4W,SAAUZ,EACV2B,QAAS3B,EAETmC,MAAOxC,EAAUW,UAAUR,GAC3BsC,UAAWlT,EAEXmT,aAAc1C,EAAUW,UAAUX,EAAU2B,QAAQhI,IAEpD3O,cAAegV,EAAUW,UAAUN,IAGvCJ,EAAQ0C,uBAAwBtG,EAAAA,EAAAA,IAAY4D,EAAQ1V,OACpD0V,EAAQ0C,sBAAsBD,aAAe1C,EAAUW,UAAUX,EAAU2B,QAAQtX,KAAKuY,oBAAoBxC,KAAK/V,QAEjH4V,EAAQ9I,OAAS,CACb0L,UAAW7C,EAAUW,UAAUL,OAAUtP,GACzC8R,QAAS9C,EAAUW,UAAUL,OAAUtP,GACvC4P,UAAWZ,EAAUW,UAAUhH,OAAM3I,GACrCmP,QAASH,EAAUW,UAAUR,OAASnP,GACtC0Q,OAAQ1B,EAAUW,UAAUtW,KAAKqX,OAAOtB,KAAK/V,WAAO2G,IAGxDiP,EAAQ8C,UAAY,CAChBlC,YAAab,EAAUW,UAAUH,GACjCI,UAAWZ,EAAUW,UAAUhH,GAC/BmH,iBAAkBN,EAElBwC,QAAShD,EAAUW,UAAUtW,KAAK4Y,QAAQ7C,KAAK/V,OAE/C8V,QAASA,EACT5Q,KAAMyQ,EAAUkD,aAAa3T,EAAM,MAEnCmS,OAAQ1B,EAAU2B,QAAQhI,GAE1B8H,gBAAiB9H,EACjBiI,SAAUpB,GAGPP,CACV,GArJL,wBAuJI,SAAWS,GACP,OAAOyC,EAAAA,GAAAA,eAAczC,GAAc,GACtC,GAzJL,oBA6JI,SAAOF,GACH,MAAe,OAAXA,EAA0B,EACvBvV,EAAAA,GAAAA,KAAeuV,GAAQ4C,UACjC,GAhKL,kBAkKI,SAAK5C,GACD,MAAe,OAAXA,GAA6B,MAAVA,EAAyB,EACzCvV,EAAAA,GAAAA,KAAeuV,GAAQ4C,UACjC,GArKL,uBAwKI,SAAUrZ,GACN,OAAOkB,EAAAA,GAAAA,KAAelB,EACzB,GA1KL,qBA6KI,SAAQA,GACJ,GAAsB,mBAAXA,EAAwB,OAAOA,EAC1C,GAAsB,kBAAXA,EAAqB,CAE5B,GAAc,UADdA,EAAQA,EAAMiR,eACU,OAAO,EAC/B,GAAc,UAAVjR,EAAqB,OAAO,CACnC,CACD,MAAM,IAAIkH,MAAM,qBAAuBlH,EAC1C,GArLL,iBAuLI,SAAIA,EAAYsZ,GACZ,MAAsB,kBAAXtZ,IACFsZ,GAAoC,OAA1BtZ,EAAMmT,UAAU,EAAG,KAAenT,EAAQ,KAAOA,IAC5DuZ,EAAAA,EAAAA,IAAYvZ,IACNA,EAAMiR,cAGbpR,GAAOsF,mBAAmB,eAAgB,QAASnF,EAC7D,GA/LL,kBAiMI,SAAKA,EAAYsZ,GACb,IAAM7R,EAASnH,KAAKkW,IAAIxW,EAAOsZ,GAC/B,GAAK7R,EAAOzE,OAAS,IAAO,EACxB,MAAM,IAAIkE,MAAM,8BAAgClH,GAEpD,OAAOyH,CACV,GAvML,qBA2MI,SAAQzH,GACJ,OAAOwZ,EAAAA,GAAAA,IAAWxZ,EACrB,GA7ML,yBA+MI,SAAYA,GACR,KAAKuZ,EAAAA,EAAAA,IAAYvZ,EAAO,IAAO,OAAO,KACtC,IAAMoW,GAAUoD,EAAAA,GAAAA,KAAWC,EAAAA,EAAAA,IAAazZ,EAAO,KAC/C,MC/OmB,+CD+OXoW,EAA2B,KAAMA,CAC5C,GAnNL,6BAqNI,SAAgBpW,GACZ,OAAO0Z,EAAAA,GAAAA,IAAmB1Z,EAC7B,GAvNL,sBA0NI,SAASuW,GACL,GAAgB,MAAZA,EAAoB,MAAO,SAE/B,GAAiB,aAAbA,EAA2B,MAAO,MAEtC,OAAQA,GACJ,IAAK,WAAY,MAAO,MACxB,IAAK,SAAU,IAAK,UAAW,IAAK,OAAQ,IAAK,YAC7C,OAAOA,EAGf,GAAyB,kBAAdA,IAA0BgD,EAAAA,EAAAA,IAAYhD,GAC7C,OAAOoD,EAAAA,EAAAA,IAA0BpD,GAGrC,MAAM,IAAIrP,MAAM,mBACnB,GA1OL,kBA6OI,SAAKlH,EAAYsZ,GACb,IAAM7R,EAASnH,KAAKkW,IAAIxW,EAAOsZ,GAC/B,OAA8B,MAA1BM,EAAAA,EAAAA,IAAcnS,GACP5H,GAAOsF,mBAAmB,eAAgB,QAASnF,GAEvDyH,CACV,GAnPL,wBAsPI,SAAWzH,GACP,GAAa,MAATA,EAAiB,OAAO,KAE5B,IAAMkI,EAAIhH,EAAAA,GAAAA,KAAelB,GAEzB,IACI,OAAOkI,EAAEmR,UACM,CAAjB,MAAOxY,GAAU,CAEpB,OAAO,IACT,GAhQL,qBAkQI,SAAQb,GACJ,KAAKuZ,EAAAA,EAAAA,IAAYvZ,GACb,MAAM,IAAIkH,MAAM,mBAEpB,OAAO2S,EAAAA,EAAAA,IAAW7Z,EAAO,GAC5B,GAvQL,oBAyQI,SAAOA,EAAY8Z,GACK,MAAhB9Z,EAAM+Z,QAAiC,MAAf/Z,EAAMyY,QAC9BzY,EAAMyY,MAAQzY,EAAM+Z,QAGxB,IAAMvB,EAAmC,MAArBxY,EAAMga,YAAuBha,EAAMga,YAAaha,EAAMwY,WACpE/Q,EAASwO,EAAUnJ,MAAMgN,EAAQ9Z,GAEvC,OADAyH,EAAOuS,YAA8B,MAAdxB,EAAsB,KAAMtX,EAAAA,GAAAA,KAAesX,GAC3D/Q,CACV,GAlRL,mBAoRI,SAAMzH,GACF,OAAOM,KAAK2Z,OAAOja,EAAOM,KAAK4V,QAAQ1V,MAC1C,GAtRL,mCAwRI,SAAsBR,GAClB,OAAOM,KAAK2Z,OAAOja,EAAOM,KAAK4V,QAAQ0C,sBAC1C,GA1RL,gCA6RI,SAAmB5Y,GACf,OAAOiW,EAAUnJ,MAAMxM,KAAK4V,QAAQsB,mBAAoBxX,EAC3D,GA/RL,iCAiSI,SAAoB0W,GAGO,MAAnBA,EAAYwD,KAAuC,MAAxBxD,EAAYQ,WACvCR,EAAYQ,SAAWR,EAAYwD,KAKnCxD,EAAYS,IAAMjW,EAAAA,GAAAA,KAAewV,EAAYS,IAAIgD,WACjDzD,EAAYS,GAAK,8CAII,MAArBT,EAAY3I,OAAqC,MAApB2I,EAAYlR,OACzCkR,EAAYlR,KAAOkR,EAAY3I,OAIb,MAAlB2I,EAAYS,IAAqC,MAAvBT,EAAYY,UACtCZ,EAAYY,QAAUhX,KAAKyX,gBAAgBrB,IAGrB,IAArBA,EAAY7E,MAAmC,IAArB6E,EAAY7E,MAAwC,MAA1B6E,EAAYC,aACjED,EAAYC,WAAa,IAG7B,IAAMlP,EAA8BwO,EAAUnJ,MAAMxM,KAAK4V,QAAQQ,YAAaA,GAE9E,GAA2B,MAAvBA,EAAYlT,QAAiB,CAC7B,IAAIA,EAAUkT,EAAYlT,SAEtB+V,EAAAA,EAAAA,IAAY/V,KACZA,EAAUtC,EAAAA,GAAAA,KAAesC,GAAS6V,YAGtC5R,EAAOjE,QAAUA,CAEpB,KAAM,CACH,IAAIA,EAAUkT,EAAY0D,UAGX,MAAX5W,GAA+B,MAAZiE,EAAOS,IAC1B1E,EAAUkT,EAAYlT,UAGtB+V,EAAAA,EAAAA,IAAY/V,KACZA,EAAUtC,EAAAA,GAAAA,KAAesC,GAAS6V,YAGd,kBAAb7V,GAAqC,MAAZiE,EAAOS,KACvC1E,GAAWiE,EAAOS,EAAI,IAAM,GACd,IAAK1E,EAAU,GAC7BA,EAAUuR,SAASvR,IAGC,kBAAbA,IAAyBA,EAAU,GAE9CiE,EAAOjE,QAAUA,CACpB,CAOD,OAJIiE,EAAOoP,WAAoD,MAAvCpP,EAAOoP,UAAUwD,QAAQ,KAAM,MACnD5S,EAAOoP,UAAY,MAGhBpP,CACV,GApWL,yBAsWI,SAAYzH,GACR,OAAOsa,EAAAA,GAAAA,OAAiBta,EAC3B,GAxWL,wBA0WI,SAAWA,GACP,OAAOiW,EAAUnJ,MAAMxM,KAAK4V,QAAQuB,WAAYzX,EACnD,GA5WL,qBA8WI,SAAQA,GACJ,IAAMyH,EAA6BwO,EAAUnJ,MAAMxM,KAAK4V,QAAQ4B,QAAS9X,GAGzE,GAAmB,MAAfyH,EAAOuQ,KACP,GAAIvQ,EAAOuQ,KAAKhV,QAAU,EAAG,CAEzB,IAAMhD,EAAQkB,EAAAA,GAAAA,KAAeuG,EAAOuQ,MAAMqB,WAC5B,IAAVrZ,GAAyB,IAAVA,GAEM,MAAjByH,EAAO2J,QAAmB3J,EAAO2J,SAAWpR,GAC5CH,GAAOsF,mBAAmB,kCAAmC,QAAS,CAAE6S,KAAMvQ,EAAOuQ,KAAM5G,OAAQ3J,EAAO2J,SAE9G3J,EAAO2J,OAASpR,SACTyH,EAAOuQ,MAEdnY,GAAOsF,mBAAmB,0BAA2B,aAAcsC,EAAOuQ,KAEjF,MAAiC,KAAvBvQ,EAAOuQ,KAAKhV,QAEnBnD,GAAOsF,mBAAmB,oBAAqB,aAAcsC,EAAOuQ,MAQ5E,OAJqB,MAAjBvQ,EAAO2J,SACP3J,EAAO8S,WAAY,GAGhB9S,CACV,GA3YL,oBA6YI,SAAOzH,GAAU,WACb,OAAI+H,MAAMC,QAAQhI,GACPA,EAAM8J,KAAI,SAAC5B,GAAD,OAAO,EAAKyP,OAAOzP,EAAnB,IAED,MAATlI,EACAM,KAAKsP,KAAK5P,GAAO,GAGrB,IACV,GAtZL,oBAwZI,SAAOA,GACH,OAAOiW,EAAUnJ,MAAMxM,KAAK4V,QAAQ9I,OAAQpN,EAC/C,GA1ZL,uBA4ZI,SAAUA,GACN,OAAOiW,EAAUnJ,MAAMxM,KAAK4V,QAAQ8C,UAAWhZ,EAClD,IA9ZL,oBAgaI,SAAa8Z,EAA0CU,GACnD,IAAM/S,EAAc,CAAC,EACrB,IAAK,IAAMuJ,KAAO8I,EACd,IACI,IAAM9Z,EAAQ8Z,EAAO9I,GAAKwJ,EAAOxJ,SACnB/J,IAAVjH,IAAuByH,EAAOuJ,GAAOhR,EAK5C,CAJC,MAAOa,GAGL,MAFAA,EAAM4Z,SAAWzJ,EACjBnQ,EAAM6Z,WAAaF,EAAOxJ,GACpBnQ,CACT,CAEL,OAAO4G,CACV,GA7aL,uBAgbI,SAAiBqS,EAAoBa,GACjC,OAAQ,SAAS3a,GACb,OAAa,MAATA,EAAwB2a,EACrBb,EAAO9Z,EACjB,CACJ,GArbL,0BAwbI,SAAoB8Z,EAAoBc,GACpC,OAAQ,SAAS5a,GACb,OAAKA,EACE8Z,EAAO9Z,GADO4a,CAExB,CACJ,GA7bL,qBAgcI,SAAed,GACX,OAAQ,SAASvS,GACb,IAAKQ,MAAMC,QAAQT,GAAU,MAAM,IAAIL,MAAM,gBAE7C,IAAMO,EAAc,GAMpB,OAJAF,EAAMG,SAAQ,SAAS1H,GACnByH,EAAOvF,KAAK4X,EAAO9Z,GACtB,IAEMyH,CACV,CACJ,KA5cL,KAmdM,SAAUoT,GAAuB7a,GACnC,OAAQA,GAA+C,oBAA/BA,EAAM8a,mBACjC,CAEK,SAAUA,GAAoB9a,GAChC,OAAQ6a,GAAuB7a,IAAUA,EAAM8a,qBAClD,CAGD,IAAIC,IAAkB,EAChB,SAAUC,KACRD,KACJA,IAAkB,EAElBE,QAAQC,IAAI,8BACZD,QAAQC,IAAI,8DACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,6EACZD,QAAQC,IAAI,sEACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,2EACZD,QAAQC,IAAI,0EACZD,QAAQC,IAAI,iFACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,sDACZD,QAAQC,IAAI,8BACf,C,2SEnfKrb,GAAS,IAAIC,EAAAA,GAAOuH,IAS1B,SAAS8T,GAAWC,GACf,OAAa,MAATA,EAAwB,QACC,MAAzBxB,EAAAA,EAAAA,IAAcwB,IACdvb,GAAOsF,mBAAmB,gBAAiB,QAASiW,GAEjDA,EAAMnK,cACjB,CAED,SAASoK,GAAgB1D,GAGrB,IADAA,EAASA,EAAOvM,QACTuM,EAAO3U,OAAS,GAAkC,MAA7B2U,EAAOA,EAAO3U,OAAS,IAAc2U,EAAOxJ,MAExE,OAAOwJ,EAAO7N,KAAI,SAACsR,GACf,GAAIrT,MAAMC,QAAQoT,GAAQ,CAGtB,IAAME,EAAyC,CAAC,EAChDF,EAAM1T,SAAQ,SAAC0T,GACXE,EAAOH,GAAWC,KAAU,CAC/B,IAGD,IAAMlP,EAASqG,OAAOjG,KAAKgP,GAG3B,OAFApP,EAAOC,OAEAD,EAAOqP,KAAK,IAEtB,CACG,OAAOJ,GAAWC,EAEzB,IAAEG,KAAK,IACX,CAgBD,SAASC,GAAYna,GACjB,GAA0B,kBAAfA,EAAyB,CAGhC,GAFAA,EAAYA,EAAU4P,cAEW,MAA7B2I,EAAAA,EAAAA,IAAcvY,GACd,MAAO,MAAQA,EAGnB,IAAgC,IAA5BA,EAAUqB,QAAQ,KAClB,OAAOrB,CAGd,KAAM,IAAI0G,MAAMC,QAAQ3G,GACrB,MAAO,YAAcga,GAAgBha,GAElC,GAAItB,EAAU0b,YAAYpa,GAE7B,MADAxB,GAAO6b,KAAK,mBACN,IAAIxU,MAAM,mBAEb,GAAI7F,GAAmC,kBAAfA,EAC3B,MAAO,WAAaA,EAAU+U,SAAW,KAAO,IAAMiF,GAAgBha,EAAUsW,QAAU,GAC7F,CAED,MAAM,IAAIzQ,MAAM,mBAAqB7F,EACxC,CAKD,SAASsa,KACL,OAAQ,IAAIC,MAAQD,SACvB,CAED,SAAS9G,GAAMrD,GACX,OAAO,IAAIC,SAAQ,SAACC,GAChBC,WAAWD,EAASF,EACvB,GACJ,CAmBD,IAAMqK,GAAiB,CAAE,QAAS,UAAW,UAAW,QAE3CC,GAAb,WAQI,WAAYC,EAAaza,EAAoByU,IAAa,gBACtD1V,EAAAA,EAAAA,IAAeC,KAAM,MAAOyb,IAC5B1b,EAAAA,EAAAA,IAAeC,KAAM,WAAYgB,IACjCjB,EAAAA,EAAAA,IAAeC,KAAM,OAAQyV,GAE7BzV,KAAK0b,kBAAoB,EACzB1b,KAAK2b,WAAY,CACpB,CAfL,kCAiBI,WACI,OAAQ3b,KAAKuR,MACT,IAAK,KACF,OAAOvR,KAAKsP,KACf,IAAK,SACF,OAAOtP,KAAK8M,OAEnB,OAAO9M,KAAKyb,GACf,GAzBL,gBA2BI,WACI,OAAOzb,KAAKyb,IAAIxO,MAAM,KAAK,EAC9B,GA7BL,gBA+BI,WACI,IAAM8B,EAAQ/O,KAAKyb,IAAIxO,MAAM,KAC7B,MAAiB,OAAb8B,EAAM,GAAsB,KACzBA,EAAM,EAChB,GAnCL,kBAqCI,WACI,IAAMA,EAAQ/O,KAAKyb,IAAIxO,MAAM,KAC7B,GAAiB,WAAb8B,EAAM,GAAmB,OAAO,KACpC,IAhHmB7J,EAgHb4Q,EAAU/G,EAAM,GAEhBsI,EAjHG,MADUnS,EAkHc6J,EAAM,IAjHjB,GAEnB7J,EAAK+H,MAAM,MAAMzD,KAAI,SAACsR,GACzB,GAAc,KAAVA,EAAgB,MAAO,GAE3B,IAAM/L,EAAQ+L,EAAM7N,MAAM,KAAKzD,KAAI,SAACsR,GAChC,MAAmB,SAAVA,EAAoB,KAAMA,CACtC,IAED,OAA0B,IAAjB/L,EAAMrM,OAAgBqM,EAAM,GAAIA,CAC5C,IAwGSjC,EAAiB,CAAC,EAKxB,OAHIuK,EAAO3U,OAAS,IAAKoK,EAAOuK,OAASA,GACrCvB,GAAuB,MAAZA,IAAmBhJ,EAAOgJ,QAAUA,GAE5ChJ,CACV,GAjDL,sBAmDI,WACI,OAAQ9M,KAAKyb,IAAIrZ,QAAQ,MAAQ,GAAKmZ,GAAenZ,QAAQpC,KAAKyb,MAAQ,CAC7E,KArDL,KA4FMG,GAAgD,CAClD,EAAO,CAAEC,OAAQ,MAAQC,MAAO,EAAMC,KAAM,EAAMC,OAAQ,MAC1D,EAAO,CAAEH,OAAQ,MAAQC,MAAO,GAAMC,KAAM,GAAMC,OAAQ,OAC1D,EAAO,CAAEH,OAAQ,OAAQC,MAAO,GAAMC,KAAM,IAC5C,GAAO,CAAEF,OAAQ,MAAQI,IAAK,OAC9B,GAAO,CAAEJ,OAAQ,MAAQI,IAAK,OAC9B,IAAO,CAAEJ,OAAQ,OAAQI,IAAK,QAGlC,SAASC,GAAWxc,GAChB,OAAO6Z,EAAAA,EAAAA,IAAW3Y,EAAAA,GAAAA,KAAelB,GAAOyc,cAAe,GAC1D,CAGD,SAASC,GAAalX,GAClB,OAAO4B,EAAOxB,QAAO6J,EAAAA,EAAAA,IAAO,CAAEjK,GAAMiU,EAAAA,EAAAA,IAAa9J,GAAOA,GAAOnK,IAAQ,EAAG,KAC7E,CAOD,IAAMmX,GAAc,IAAIjJ,OAAO,kBAAoB,KAC7CkJ,GAAW,CACb,IAAIlJ,OAAO,mBAAqB,KAChC,IAAIA,OAAO,gBAAiB,KAC5BiJ,GACA,IAAIjJ,OAAO,mCAAoC,MAGnD,SAASmJ,GAAapV,EAAgB+B,GAClC,IACI,OAAOwI,EAAAA,EAAAA,IAAa8K,GAAYrV,EAAQ+B,GAC1B,CAAhB,MAAM3I,GAAU,CAClB,OAAO,IACV,CAED,SAASic,GAAYrV,EAAgB+B,GACjC,GAAe,OAAX/B,EAAmB,OAAO,KAE9B,IAAMoC,EAAS3I,EAAAA,GAAAA,MAAeuY,EAAAA,EAAAA,IAAahS,EAAQ+B,EAAOA,EAAQ,KAAK6P,WACjErW,EAAS9B,EAAAA,GAAAA,MAAeuY,EAAAA,EAAAA,IAAahS,EAAQoC,EAAQA,EAAS,KAAKwP,WAEzE,OAAOI,EAAAA,EAAAA,IAAahS,EAAQoC,EAAS,GAAIA,EAAS,GAAK7G,EAC1D,CAGD,SAAS+Z,GAAYC,GASjB,OARIA,EAAKpJ,MAAM,qBACXoJ,EAAOA,EAAK7J,UAAU,IACf6J,EAAKpJ,MAAM,eAClBoJ,EAAOA,EAAK7J,UAAU,GAEtBtT,GAAOsF,mBAAmB,0BAA2B,OAAQ6X,GAG1D,gCAAP,OAAyCA,EAC5C,CAED,SAASC,GAAOjd,GACZ,IAAMyH,GAAS9B,EAAAA,EAAAA,IAAS3F,GACxB,GAAIyH,EAAOzE,OAAS,GAAM,MAAM,IAAIkE,MAAM,+BAE1C,IAAMgW,EAAS,IAAInW,WAAW,IAE9B,OADAmW,EAAO3Q,IAAI9E,EAAQ,GAAKA,EAAOzE,QACxBka,CACV,CAED,SAASC,GAASnd,GACd,GAAKA,EAAMgD,OAAS,KAAQ,EAAK,OAAOhD,EAExC,IAAMyH,EAAS,IAAIV,WAA0C,GAA/BgC,KAAKqU,KAAKpd,EAAMgD,OAAS,KAEvD,OADAyE,EAAO8E,IAAIvM,GACJyH,CACV,CAGD,SAAS4V,GAAYC,GAMjB,IALA,IAAM7V,EAA4B,GAE9B8V,EAAY,EAGP9X,EAAI,EAAGA,EAAI6X,EAAMta,OAAQyC,IAC9BgC,EAAOvF,KAAK,MACZqb,GAAa,GAGjB,IAAK,IAAI9X,EAAI,EAAGA,EAAI6X,EAAMta,OAAQyC,IAAK,CACnC,IAAMD,GAAOG,EAAAA,EAAAA,IAAS2X,EAAM7X,IAG5BgC,EAAOhC,GAAKwX,GAAOM,GAGnB9V,EAAOvF,KAAK+a,GAAOzX,EAAKxC,SACxByE,EAAOvF,KAAKib,GAAS3X,IACrB+X,GAAa,GAAmC,GAA9BxU,KAAKqU,KAAK5X,EAAKxC,OAAS,GAC7C,CAED,OAAOwa,EAAAA,EAAAA,IAAU/V,EACpB,CAEM,IAAMgW,GAAb,WAYI,WAAYhb,EAAwB2T,EAAiBzT,EAAc+a,IAAwB,gBACvFrd,EAAAA,EAAAA,IAAeC,KAAM,WAAYmC,IACjCpC,EAAAA,EAAAA,IAAeC,KAAM,OAAQqC,IAC7BtC,EAAAA,EAAAA,IAAeC,KAAM,UAAWmC,EAASkb,UAAUvH,QAAQA,KAC3D/V,EAAAA,EAAAA,IAAeC,KAAM,mBAAoBod,EAC5C,CAjBL,+CAmBI,WAAgB,WAgBZ,OAfKpd,KAAKsd,mBAENtd,KAAKsd,iBAAmBtd,KAAKmC,SAASoF,KAAK,CACvCsP,GAAI7W,KAAK8V,QACT5Q,KAAM,+EACPqQ,MAAK,SAACpO,GACL,OAAOvG,EAAAA,GAAAA,KAAeuG,GAAQoW,GAAG,EACpC,IAAEjd,OAAM,SAACC,GACN,GAAIA,EAAMid,OAAShe,EAAAA,GAAAA,OAAAA,eAAgC,OAAO,EAG1D,MADA,EAAK8d,iBAAmB,KAClB/c,CACT,KAGEP,KAAKsd,gBACf,GApCL,oBAsCU,SAAOG,EAAkBC,G,0IAWvB,OAREC,EAAK,CACP9G,GAAI7W,KAAK8V,QACT8H,iBAAiB,EACjB1Y,MAAMgY,EAAAA,EAAAA,IAAU,CAAEO,EAAUxO,GAASjP,KAAKqC,MAAQqb,GAAc,QAIhEG,GAAa,E,SACP7d,KAAK8d,mB,kCACXD,GAAa,EAGbF,EAAGzY,MAAOgY,EAAAA,EAAAA,IAAU,CAAE,aAAcH,GAAY,ET9TlC1a,ES8T8CrC,KAAKqC,MT7TlE+M,EAAAA,EAAAA,KAAQD,EAAAA,EAAAA,IAAON,GAAaxM,GAAMmH,KAAI,SAACoF,GAE1C,GAAIA,EAAKlM,OAAS,GACd,MAAM,IAAIkE,MAAM,sDAGpB,IAAMJ,EAAQ,IAAIC,WAAWmI,EAAKlM,OAAS,GAG3C,OAFA8D,EAAMyF,IAAI2C,EAAM,GAChBpI,EAAM,GAAKA,EAAM9D,OAAS,EACnB8D,CAEV,MAAM,MSkTyEmX,EAAGzY,S,OAI9D,O,mBAAMlF,KAAKmC,SAASoF,KAAKoW,G,eAAlCxW,EAAS,EAATA,MACC9B,EAAAA,EAAAA,IAAS8B,GAAQzE,OAAS,KAAQ,GACnCnD,GAAOwT,WAAW,uBAAwBvT,EAAAA,GAAAA,OAAAA,eAA8B,CACpE4W,YAAauH,EAAIzY,KAAMiC,IAG3B0W,IAAc1W,EAASqV,GAAYrV,EAAQ,I,kBACxCA,G,qCAEH,KAAMqW,OAAShe,EAAAA,GAAAA,OAAAA,eAA4Bue,C,yCAAW,M,qDT3UhE,IAAoB1b,C,uBS8UrB,GArEL,yBAuEU,SAAYob,EAAkBC,G,sIACjB,O,SAAM1d,KAAKge,OAAOP,EAAUC,G,UAC7B,OADRvW,EAAS,EAATA,MACQ,C,wCAAeqV,GAAYrV,EAAQ,I,gCAC1C,M,+CACV,GA3EL,yBA6EI,SAAY8W,EAAkBC,GAC1B,IAAMC,EAAWvC,GAAUrW,OAAO0Y,IAQlC,GANgB,MAAZE,GACA5e,GAAOwT,WAAP,iCAA6CkL,GAAaze,EAAAA,GAAAA,OAAAA,sBAAqC,CAC3F4e,UAAW,cAAF,OAAiBH,EAAjB,OAII,QAAjBE,EAASlC,IACT,OAAOjc,KAAKmC,SAASkb,UAAUvH,QAAQoI,GAG3C,IAAM1X,GAAQnB,EAAAA,EAAAA,IAAS6Y,GAGvB,GAAsB,MAAlBC,EAASrC,MAAe,CACxB,IAAMA,EAAQoC,EAAS5K,MAAM,6CAC7B,GAAIwI,EAAO,CACP,IAAMpZ,EAAS+R,SAASqH,EAAM,GAAI,IAClC,GAAIA,EAAM,GAAGpZ,SAAoB,EAATA,GAAcA,GAAU,GAAKA,GAAU,GAC3D,OAAO0Z,IAAajN,EAAAA,EAAAA,IAAO,CAAE,CAAEgP,EAASrC,OAAU,KAAOA,EAAM,KAEtE,CACJ,CAGD,GAAqB,MAAjBqC,EAASpC,KAAc,CACvB,IAAMA,EAAOmC,EAAS5K,MAAM,yCAC5B,GAAIyI,EAAM,CACN,IAAMrZ,EAAS+R,SAASsH,EAAK,GAAI,IACjC,GAAIA,EAAK,GAAGrZ,SAAoB,EAATA,GAAcA,GAAU,GAAKA,GAAU,GAC1D,OAAO0Z,IAAajN,EAAAA,EAAAA,IAAO,CAAE,CAAEgP,EAASpC,MAAS,KAAOA,EAAK,KAEpE,CACJ,CAGD,GAAuB,MAAnBoC,EAASnC,OAAgB,CACzB,IAAMtZ,EAAS8D,EAAM,GAGjBO,EAAUP,EAAM,GASpB,GARgB,IAAZO,EACe,KAAXrE,GAA4B,KAAXA,IACjBqE,GAAW,GAGfA,GAAW,EAGXA,GAAW,GAAKP,EAAM9D,SAAW,EAAIA,GAAUA,GAAU,GAAKA,GAAU,GAAI,CAC5E,IAAM2b,EAAQC,KAAAA,QAAe9X,EAAMsE,MAAM,IAEzC,OADAuT,EAAME,QAAQxX,GACPuX,KAAAA,OAAcH,EAASnC,OAAQqC,EACzC,CACJ,CAED,OAAO,IACV,GAxIL,wBA2IU,SAAWJ,G,6IACG,MAAZA,IAAoBA,EAAW,IAGlB,KAAbA,EAAa,C,gBAGM,O,kBAAMje,KAAKge,OAAO,c,UAGlB,QAHT7W,EAAS,EAATA,OCheE,uEDmeeA,EAAmBqX,C,wCAAW,M,gCAE9Cxe,KAAKmC,SAASkb,UAAUoB,YAAYtX,I,qCAEvC,KAAMqW,OAAShe,EAAAA,GAAAA,OAAAA,eAA4Bue,C,yCAAW,M,2BAMjD,O,UAAM/d,KAAK0e,YAAY,aAAcxC,GAAW+B,I,WAGjD,OAHVC,EAAW,EAAXA,OAG+B,OAAbA,EAAa,C,yCAAe,M,eAKrC,OAFTpI,EAAU9V,KAAK2e,YAAYV,EAAUC,KAGvC3e,GAAOwT,WAAP,mCAAsDvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACvF4e,UAAW,cAAF,OAAiBH,EAAjB,KACTA,SAAUA,EACV/Y,KAAMgZ,I,kBAIPpI,G,yDACV,GAhLL,uBAkLU,W,oKAKiB,OAJb8I,EAAoD,CAAE,CAAErN,KAAM,OAAQsN,QAAS7e,KAAKqC,O,kBAIjErC,KAAK8e,QAAQ,U,UACpB,OADRC,EAAS,EAATA,MACQ,C,wCAAe,M,OAEpB5Z,EAAI,E,YAAGA,EAAImX,GAAS5Z,QAAAA,C,mBAEZ,OADP4Q,EAAQyL,EAAOzL,MAAMgJ,GAASnX,KACvB,C,uDAEP6Z,EAAS1L,EAAM,GAAG3C,c,KAEhBqO,E,OACC,U,KAAA,GAIA,SAJA,KAIA,GAIA,SAJA,KAIA,GAIA,WAJA,MAKA,YADA,QACA,G,qBAZDJ,EAAQhd,KAAK,CAAE2P,KAAM,MAAOsN,QAASE,I,kBAC9B,CAAEH,QAAAA,EAAS7b,IAAKgc,I,eAGvBH,EAAQhd,KAAK,CAAE2P,KAAM,OAAQsN,QAASE,I,kBAC/B,CAAEH,QAAAA,EAAS7b,IAAKgc,I,eAGvBH,EAAQhd,KAAK,CAAE2P,KAAM,OAAQsN,QAASE,I,kBAC/B,CAAEH,QAAAA,EAAS7b,IAAK0Z,GAAYsC,K,WAK7BtB,EAAuB,WAAXuB,EAAuB,aAAc,aACvDJ,EAAQhd,KAAK,CAAE2P,KAAMyN,EAAQH,QAASE,I,KAGvB/e,KAAKif,iB,sBAAoB,O,UAAMjf,KAAKkZ,a,+BAA7CgG,EAAQ,EAARA,GAGe,KADfnQ,GAASuE,EAAM,IAAM,IAAIrG,MAAM,MAC3BvK,OAAW,C,yCAAY,M,QAEpB,O,UAAM1C,KAAKmC,SAASkb,UAAUvH,QAAQ/G,EAAM,I,WAAnDoQ,EAAO,EAAPA,KACAC,GAAU7F,EAAAA,EAAAA,IAAW3Y,EAAAA,GAAAA,KAAemO,EAAM,IAAIoN,cAAe,IAGpD,WAAX6C,EAAW,C,gBAE4C,O,KAApChf,KAAKmC,SAASkb,U,UAA4Brd,KAAKmC,SAASoF,KAAK,CAC5EsP,GAAIsI,EAAMja,MAAMgY,EAAAA,EAAAA,IAAU,CAAE,aAAckC,M,uBADxCC,EAAa,EAAbA,GAAqCZ,YAAAA,KAAAA,EAAAA,GAAAA,EAAAA,IAGvCS,IAAUG,EAAAA,C,yCAAqB,M,QACnCT,EAAQhd,KAAK,CAAE2P,KAAM,QAASsN,QAASQ,I,2BAErB,YAAXL,EAAW,C,gBAEa,O,KAAfpe,EAAAA,G,UAAqBZ,KAAKmC,SAASoF,KAAK,CACpDsP,GAAIsI,EAAMja,MAAMgY,EAAAA,EAAAA,IAAU,CAAE,cAAc3D,EAAAA,EAAAA,IAAW2F,EAAO,IAAKE,M,yBAD/DE,EAAU,EAAVA,GAAoB3I,KAAAA,KAAAA,EAAAA,GAAAA,EAAAA,KAGdkD,SAAR,C,yCAA2B,M,QAC/B+E,EAAQhd,KAAK,CAAE2P,KAAM,UAAWsN,QAASS,EAAQvR,a,QAStB,OALzB4P,EAAK,CACP9G,GAAI7W,KAAKmC,SAASkb,UAAUvH,QAAQ/G,EAAM,IAC1C7J,MAAMgY,EAAAA,EAAAA,IAAU,CAAEO,EAAU2B,K,KAGd7C,G,UAAmBvc,KAAKmC,SAASoF,KAAKoW,G,uBACrC,OADf4B,GAAc,EAAdA,EAAAA,IAAAA,EAAAA,GAAyD,IAC1C,C,yCAAe,M,QAiBjB,OAhBjBX,EAAQhd,KAAK,CAAE2P,KAAM,oBAAqBsN,QAASU,IAGpC,YAAXP,IACAO,EAAcA,EAAYxF,QAAQ,OAAQqF,EAAQvM,UAAU,IAC5D+L,EAAQhd,KAAK,CAAE2P,KAAM,wBAAyBsN,QAASU,KAIvDA,EAAYjM,MAAM,aAClBiM,EAAc9C,GAAY8C,IAG9BX,EAAQhd,KAAK,CAAE2P,KAAM,eAAgBsN,QAASU,I,UAGvB5N,GAAU4N,G,WAA3BC,EAAW,EAAXA,KACS,C,yCAAS,M,WACxBZ,EAAQhd,KAAK,CAAE2P,KAAM,WAAYsN,QAAS7J,KAAKyK,UAAUD,KAIhC,kBADrBE,EAAWF,EAASG,OACC,C,yCAAmB,M,YAExCD,EAASpM,MAAM,wBAAf,C,2CAKY,MADCoM,EAASpM,MAAM+I,IAChB,C,yCAAe,M,QAE3BuC,EAAQhd,KAAK,CAAE2P,KAAM,WAAYsN,QAASa,IAC1CA,EAAWjD,GAAYiD,G,eAG3Bd,EAAQhd,KAAK,CAAE2P,KAAM,MAAOsN,QAASa,I,kBAE9B,CAAEd,QAAAA,EAAS7b,IAAK2c,I,QAjGEva,I,0GAuGlC,M,yDACV,GAlSL,4BAoSU,W,sJAGe,O,SAAMnF,KAAK0e,YAAY,c,UAGxB,OAHVR,EAAW,EAAXA,OAG+B,OAAbA,EAAa,C,wCAAe,M,YAG9C0B,EAAO1B,EAAS5K,MAAM,kEAClB,C,mBACA5Q,EAAS+R,SAASmL,EAAK,GAAI,IAC7BA,EAAK,GAAGld,SAAoB,EAATA,EAAS,C,yCACrB,UAAaoE,EAAOxB,OAAO,KAAOsa,EAAK,K,aAKhDC,EAAO3B,EAAS5K,MAAM,kEAClB,C,mBACA5Q,EAAS+R,SAASoL,EAAK,GAAI,IAC7BA,EAAK,GAAGnd,SAAoB,EAATA,EAAS,C,yCACrB,UAAaoE,EAAOxB,OAAO,KAAOua,EAAK,K,aAKhDC,EAAQ5B,EAAS5K,MAAM,kCAClB,C,mBACkB,KAArBwM,EAAM,GAAGpd,OAAqB,C,yCACvB,SAAYod,EAAM,I,aAI3BC,EAAS7B,EAAS5K,MAAM,4BAClB,C,mBACkB,KAAtByM,EAAO,GAAGrd,OAAqB,C,uBAEzBsd,EAAkC,CAAE,IAAK,GAAI,IAAK,IAAK,IAAK,KAC5D1Q,EAAO4D,EAAa,KAAO6M,EAAO,IAAIhG,QAAQ,WAAW,SAAC1Q,GAAD,OAAQ2W,EAAQ3W,EAAhB,I,kBACxD,SAAYiG,G,iCAIpB/P,GAAOwT,WAAP,2CAA8DvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACtG4e,UAAW,mBACXlZ,KAAMgZ,K,gDAEb,GApVL,qBAsVU,SAAQxN,G,wIAcO,OAXbuP,GAAWnR,EAAAA,EAAAA,IAAY4B,IAI3BuP,GAAW9Q,EAAAA,EAAAA,IAAO,CAAE+M,GAAW,IAAKA,GAAW+D,EAASvd,QAASud,KAGnDvd,OAAS,KAAQ,IAC3Bud,GAAW9Q,EAAAA,EAAAA,IAAO,CAAE8Q,GAAU1G,EAAAA,EAAAA,IAAW,KAAM,GAAM7I,EAAIhO,OAAS,O,SAG/C1C,KAAK0e,YAAY,cAActP,EAAAA,EAAAA,IAAQ6Q,I,UAC9C,OADV/B,EAAW,EAAXA,OAC+B,OAAbA,EAAa,C,wCAAe,M,iCAE7CxM,EAAAA,EAAAA,IAAawM,I,+CACvB,KAxWL,KA2WIgC,GAA8B,KAE9BC,GAAa,EAEJC,GAAb,0CAiDI,WAAY/e,GAAsC,MAkB9C,IAlB8C,gBAC9C,gBAGKgf,QAAU,GAEf,EAAKC,SAAW,CAAEpgB,OAAQ,GAE1B,EAAKqgB,iBAAkB,EAEvB,EAAKlD,WAAY,2CAAWmD,gBAK5BzgB,EAAAA,EAAAA,KAAe,UAAM,aAA2B,QAAZsB,GAChC,EAAKof,aAAcpf,EAAU,EAAKqf,iBAElCrf,aAAmB8P,QACnB,EAAKwP,gBAAkBtf,EAGvBA,EAAQf,OAAM,SAACC,GAAa,IAG5B,EAAKqgB,SAAStgB,OAAM,SAACC,GAAa,QAE/B,CACH,IAAMsgB,GAAeC,EAAAA,EAAAA,IAAS,0CAA+C,aAAxDA,CAAsEzf,GACvFwf,IACA9gB,EAAAA,EAAAA,KAAe,UAAM,WAAY8gB,GACjC,EAAKE,KAAK,UAAWF,EAAc,OAGnCthB,GAAOsF,mBAAmB,kBAAmB,UAAWxD,EAE/D,CApC6C,OAsC9C,EAAK2f,yBAA2B,KAEhC,EAAKtF,kBAAoB,EACzB,EAAKuF,qBAAuB,GAE5B,EAAKC,iBAAmB,IAExB,EAAKC,eAAiB,EA7CwB,CA8CjD,CA/FL,qCAiGU,W,yIACmB,MAAjBnhB,KAAKohB,SAAY,C,mBACb/f,EAAmB,MACnBrB,KAAK2gB,gBAAiB,C,gBAER,O,kBAAM3gB,KAAK2gB,gB,OAArBtf,EAAU,EAAVA,K,2DAKO,MAAXA,EAAW,C,gBACD,O,UAAMrB,KAAK0gB,gB,QAArBrf,EAAU,EAAVA,K,QAKCA,GACD9B,GAAOwT,WAAW,sBAAuBvT,EAAAA,GAAAA,OAAAA,cAA6B,CAAC,GAItD,MAAjBQ,KAAKohB,WACDphB,KAAKygB,WACLzgB,KAAKohB,SAAW/f,GAEhBtB,EAAAA,EAAAA,IAAeC,KAAM,WAAYqB,GAErCrB,KAAK+gB,KAAK,UAAW1f,EAAS,O,iCAI/BrB,KAAKohB,U,wDACf,GAjIL,iBAsII,WAAS,WACL,OAAOlM,IAAK,WACR,OAAO,EAAK0L,SAASrL,MAAK,SAAClU,GACvB,OAAOA,CACV,IAAE,SAACd,GAEA,GAAIA,EAAMid,OAAShe,EAAAA,GAAAA,OAAAA,eAA+C,cAAhBe,EAAM8gB,MAGxD,MAAM9gB,CACT,GACJ,GACJ,GAlJL,2BAiKU,SAAcod,EAAiB2D,EAAkBC,G,0JAC/CvhB,KAAKugB,iBAAmC,IAAhBgB,EAAK7e,OAAW,C,wCAAY,M,OAElD8e,EAAS7D,EAAG9G,GAAGlG,cACfzL,EAAOoc,EAAS3Q,cAEhB8Q,EAA+B,GAE5Btc,EAAI,E,YAAGA,EAAIoc,EAAK7e,QAAAA,C,gBASN,OARTK,EAAMwe,EAAKpc,GAGXuK,EAAO3M,EAAIgX,QAAQ,WAAYyH,GAAQzH,QAAQ,SAAU7U,GAGzD2M,EAAuB9O,EAAIX,QAAQ,WAAa,EAAK,KAAM4S,KAAKyK,UAAU,CAAEva,KAAAA,EAAMsc,OAAAA,I,UAEnE7P,GAAU,CAAE5O,IAAK2M,EAAM6C,kBAAkB,GAAQV,GAAM,SAACnS,EAAO8Q,GAEhF,OADA9Q,EAAMoR,OAASN,EAASK,WACjBnR,CACV,I,aAHKyH,EAAS,EAATA,MAKKjC,KAAM,C,yCAASiC,EAAOjC,M,WAE3Bwc,EAAgBva,EAAOmG,SAAW,kBAGpCnG,EAAO2J,QAAU,KAAO3J,EAAO2J,OAAS,M,yCACjCvR,GAAOwT,WAAP,gDAA4D2O,GAAiBliB,EAAAA,GAAAA,OAAAA,aAA4B,CAAEuD,IAAAA,EAAK2e,aAAAA,K,QAI3HD,EAAc7f,KAAK8f,G,QAxBUvc,I,gDA2B1B5F,GAAOwT,WAAP,+CAA2D0O,EAAcjY,KAAI,SAACe,GAAD,OAAOyK,KAAKyK,UAAUlV,EAAtB,IAA0B0Q,KAAK,OAAUzb,EAAAA,GAAAA,OAAAA,aAA4B,CACrJ+hB,KAAAA,EAAME,cAAAA,K,gDAEb,GAvML,qCA2MU,SAAwBE,G,mJAC1B,O,SAAM3hB,KAAK4gB,S,YAGPe,EAAS,I,2BAGF3hB,KAAK4hB,qBAAsB,C,gBAOX,OAJbC,EAAsB7hB,KAAK4hB,qB,kBAIRC,E,UAAf1a,EAAS,EAATA,OACDkU,KAAYlU,EAAO2a,UAAaH,GAAAA,C,yCAC1Bxa,EAAOqP,a,yEAYdxW,KAAK4hB,uBAAyBC,EAAAA,C,2EAyCtC,OAlCFE,EAAU1G,KAEV2G,GAA2B/hB,EAAAA,EAAAA,IAAkB,CAC/CuW,YAAaxW,KAAKiiB,QAAQ,iBAAkB,CAAC,GAC7CC,aAAcliB,KAAK2E,aAAa4Q,MAAK,SAAClU,GAAD,OAAc,IAAd,IAAqB,SAACd,GAAD,OAAYA,CAAZ,MAC3DgV,MAAK,YAAkC,IAA/BiB,EAA+B,EAA/BA,YAAa0L,EAAkB,EAAlBA,aACpB,GAAIA,EAKA,MAHI,EAAKN,uBAAyBI,IAC9B,EAAKJ,qBAAuB,MAE1BM,EAGV,IAAMJ,EAAWzG,KAOjB,OALA7E,EAAc5V,EAAAA,GAAAA,KAAe4V,GAAauC,YACxB,EAAKiI,0BAA2BxK,EAAc,EAAKwK,yBAErE,EAAKA,wBAA0BxK,EAC/B,EAAK2L,oBAAoB3L,GAClB,CAAEA,YAAAA,EAAauL,QAAAA,EAASD,SAAAA,EAClC,IAED9hB,KAAK4hB,qBAAuBI,EAG5BA,EAAyB1hB,OAAM,SAACC,GAExB,EAAKqhB,uBAAyBI,IAC9B,EAAKJ,qBAAuB,KAEnC,I,UAEaI,E,wCAA0BxL,a,yDAC3C,GAjRL,kBAmRU,W,mJAQgB,OAPZ4L,EAASjC,KAGTkC,EAAgC,GAElC7L,EAAsB,K,kBAEFxW,KAAKsiB,wBAAwB,IAAMtiB,KAAKuiB,gBAAkB,G,OAA9E/L,EAAc,EAAdA,K,uDAEAxW,KAAK+gB,KAAK,QAAV,M,8BAGJ/gB,KAAKmiB,oBAAoB3L,GAGzBxW,KAAK+gB,KAAK,OAAQqB,EAAQ5L,GAGtBA,IAAgBxW,KAAK0b,iBAAAA,C,uBACrB1b,KAAK+gB,KAAK,UAAWqB,G,2BASzB,IAJ6B,IAAzBpiB,KAAKsgB,SAASpgB,QACdF,KAAKsgB,SAASpgB,MAAQsW,EAAc,GAGpC/N,KAAK+Z,IAAcxiB,KAAKsgB,SAASpgB,MAAUsW,GAAe,IAC1DjX,GAAO6b,KAAP,sEAA4Epb,KAAKsgB,SAASpgB,MAA1F,uBAAgHsW,EAAhH,MACAxW,KAAK+gB,KAAK,QAASxhB,GAAOyU,UAAU,8BAA+BxU,EAAAA,GAAAA,OAAAA,cAA6B,CAC5FgX,YAAaA,EACb6K,MAAO,YACPoB,oBAAqBziB,KAAKsgB,SAASpgB,SAEvCF,KAAK+gB,KAAK,QAASvK,QAInB,IAASrR,EAAanF,KAAKsgB,SAASpgB,MAAS,EAAGiF,GAAKqR,EAAarR,IAC9DnF,KAAK+gB,KAAK,QAAS5b,G,OAKdnF,KAAKsgB,SAASpgB,QAAWsW,IAClCxW,KAAKsgB,SAASpgB,MAAQsW,EAEtBvE,OAAOjG,KAAKhM,KAAKsgB,UAAUlZ,SAAQ,SAACsJ,GAEhC,GAAY,UAARA,EAAJ,CAGA,IAAMgS,EAAmB,EAAKpC,SAAS5P,GAKd,YAArBgS,GAIAlM,EAAckM,EAAmB,WAC1B,EAAKpC,SAAS5P,EAbO,CAenC,MAI0B,IAA3B1Q,KAAK0b,mBACL1b,KAAK0b,iBAAmBlF,EAAc,GAG1CxW,KAAKqgB,QAAQjZ,SAAQ,SAACia,GAClB,OAAQA,EAAM9P,MACV,IAAK,KACD,IAAMjC,EAAO+R,EAAM/R,KACfqT,EAAS,EAAKC,sBAAsBtT,GAAMiG,MAAK,SAACiC,GAChD,OAAKA,GAAkC,MAAvBA,EAAQhB,aACxB,EAAK8J,SAAS,KAAOhR,GAAQkI,EAAQhB,YACrC,EAAKuK,KAAKzR,EAAMkI,GACT,MAH+C,IAIzD,IAAElX,OAAM,SAACC,GAAmB,EAAKwgB,KAAK,QAASxgB,EAAS,IAEzD8hB,EAAQzgB,KAAK+gB,GAEb,MAGJ,IAAK,SAED,IAAKtB,EAAM1F,UAAW,CAClB0F,EAAM1F,WAAY,GAIc,IAA5B0F,EAAM3F,mBACN2F,EAAM3F,iBAAmBlF,EAAc,GAO3C,IAAM1J,EAASuU,EAAMvU,OACrBA,EAAO0L,UAAY6I,EAAM3F,iBAAmB,EAC5C5O,EAAO2L,QAAUjC,EAIjB,IAAMqM,EAAe/V,EAAO2L,QAAU,EAAKwI,qBACvC4B,EAAe/V,EAAO0L,YAAa1L,EAAO0L,UAAYqK,GAEtD/V,EAAO0L,UAAY,IAAK1L,EAAO0L,UAAY,GAE/C,IAAMmK,EAAS,EAAKG,QAAQhW,GAAQyI,MAAK,SAACsC,GAEtCwJ,EAAM1F,WAAY,EAEE,IAAhB9D,EAAKnV,QAETmV,EAAKzQ,SAAQ,SAACwT,GAGNA,EAAIpE,YAAc6K,EAAM3F,mBACxB2F,EAAM3F,iBAAmBd,EAAIpE,aAIjC,EAAK8J,SAAS,KAAO1F,EAAIrE,WAAaqE,EAAIpE,YAC1C,EAAK8J,SAAS,KAAO1F,EAAIxD,iBAAmBwD,EAAIpE,YAEhD,EAAKuK,KAAKjU,EAAQ8N,EACrB,GACJ,IAAEta,OAAM,SAACC,GACN,EAAKwgB,KAAK,QAASxgB,GAGnB8gB,EAAM1F,WAAY,CACrB,IACD0G,EAAQzgB,KAAK+gB,EAChB,EAKZ,IAED3iB,KAAK0b,iBAAmBlF,EAGxBrF,QAAQ4R,IAAIV,GAAS9M,MAAK,WACtB,EAAKwL,KAAK,UAAWqB,EACxB,IAAE9hB,OAAM,SAACC,GAAY,EAAKwgB,KAAK,QAASxgB,EAAS,I,2EAGrD,GAhbL,8BAmbI,SAAiBiW,GACbxW,KAAK0b,iBAAmBlF,EAAc,EAClCxW,KAAKgjB,SAAWhjB,KAAKkV,MAC5B,GAtbL,mBAwbI,WACI,OAAOlV,KAAKohB,QACf,GA1bL,2BA8bU,W,yJACK7hB,GAAOwT,WAAW,8CAA+CvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACzG4e,UAAW,4B,0CAElB,GAlcL,wBAocU,W,0IACc,O,SAAMpe,KAAK4gB,S,OAKJ,OALjBvf,EAAU,EAAVA,K,SAKuBrB,KAAK0gB,gB,UAA5BuC,EAAiB,EAAjBA,KACF5hB,EAAQ6B,UAAY+f,EAAe/f,QAAAA,C,oBAI/BlD,KAAKygB,WAAY,C,gBAgBjB,OAfAzgB,KAAKohB,SAAW6B,EAGhBjjB,KAAK0b,kBAAoB,EACzB1b,KAAKkjB,iBAAmB,KACxBljB,KAAKmjB,wBAA0B,KAC/BnjB,KAAKmhB,eAAiB,EACtBnhB,KAAKsgB,SAASpgB,OAAS,EACvBF,KAAKghB,yBAA2B,KAChChhB,KAAK4hB,qBAAuB,KAK5B5hB,KAAK+gB,KAAK,UAAWkC,EAAgB5hB,G,UAC/BkT,GAAM,G,iCAELvU,KAAKohB,U,cAGV7gB,EAAQhB,GAAOyU,UAAU,6BAA8BxU,EAAAA,GAAAA,OAAAA,cAA6B,CACtF6hB,MAAO,UACPhgB,QAASA,EACT+hB,gBAAiBH,IAGrBjjB,KAAK+gB,KAAK,QAASxgB,GACbA,E,iCAGHc,G,gDACV,GA/eL,uBAifI,WAAe,WAKX,OAJArB,KAAKsiB,wBAAwB,IAAMtiB,KAAKuiB,gBAAkB,GAAGhN,MAAK,SAACiB,GAC/D,EAAK2L,oBAAoB3L,EAC5B,IAAE,SAACjW,GAAa,IAEgB,MAAzBP,KAAKkjB,iBAA4BljB,KAAKkjB,kBAAmB,CACpE,GAvfL,mBAyfI,WACI,OAAwB,MAAhBljB,KAAKqjB,OAChB,EA3fL,IA6fI,SAAY3jB,GAAc,WAClBA,IAAUM,KAAKqjB,SACfrjB,KAAKqjB,QAAUC,aAAY,WAAQ,EAAKpO,MAAS,GAAElV,KAAKuiB,iBAEnDviB,KAAKujB,iBACNvjB,KAAKujB,eAAiBlS,YAAW,WAC7B,EAAK6D,OAIL,EAAKqO,eAAiBlS,YAAW,WAGxB,EAAKgS,SAAW,EAAKnO,OAG1B,EAAKqO,eAAiB,IACzB,GAAE,EAAKhB,gBACX,GAAE,MAGC7iB,GAASM,KAAKqjB,UACtBG,cAAcxjB,KAAKqjB,SACnBrjB,KAAKqjB,QAAU,KAEtB,GAthBL,2BAwhBI,WACI,OAAOrjB,KAAKkhB,gBACf,EA1hBL,IA4hBI,SAAoBxhB,GAAa,WAC7B,GAAsB,kBAAXA,GAAuBA,GAAS,GAAK+U,SAASlP,OAAO7F,KAAWA,EACvE,MAAM,IAAIkH,MAAM,4BAGpB5G,KAAKkhB,iBAAmBxhB,EAEpBM,KAAKqjB,UACLG,cAAcxjB,KAAKqjB,SACnBrjB,KAAKqjB,QAAUC,aAAY,WAAQ,EAAKpO,MAAS,GAAElV,KAAKkhB,kBAE/D,GAviBL,iCAyiBI,WAAmB,WACTuC,EAAMpI,KAaZ,OAVKoI,EAAMzjB,KAAKmhB,eAAkB,EAAInhB,KAAKkhB,mBACvClhB,KAAKmhB,eAAiBsC,EACtBzjB,KAAKmjB,wBAA0BnjB,KAAK0jB,iBAAiBnO,MAAK,SAACiB,GAIvD,OAH6B,MAAzB,EAAK0M,kBAA4B1M,EAAc,EAAK0M,oBACpD,EAAKA,iBAAmB1M,GAErB,EAAK0M,gBACf,KAGEljB,KAAKmjB,uBACf,GAxjBL,iCA0jBI,SAAoB3M,GAEa,MAAzBxW,KAAKkjB,kBAA4B1M,EAAcxW,KAAKkjB,mBAGxDljB,KAAKmhB,eAAiB9F,MAGO,MAAzBrb,KAAKkjB,kBAA4B1M,EAAcxW,KAAKkjB,oBACpDljB,KAAKkjB,iBAAmB1M,EACxBxW,KAAKmjB,wBAA0BhS,QAAQC,QAAQoF,IAEtD,GAtkBL,gCAwkBU,SAAmBY,EAAyBV,EAAwBjE,G,yJAC/DzS,KAAK2jB,oBAAoBvM,EAAmC,MAAjBV,EAAyB,EAAGA,EAAejE,GAAW,EAAG,O,+CAC9G,GA1kBL,iCA4kBU,SAAoB2E,EAAyBV,EAAuBjE,EAAiBmR,G,6IACvE,O,SAAM5jB,KAAK4iB,sBAAsBxL,G,cAA3CI,EAAU,EAAVA,MAGSA,EAAQd,cAAe,IAAMA,GAAAA,C,wCAAwBc,G,gCAG7D,IAAIrG,SAAQ,SAACC,EAAS2C,GACzB,IAAM8P,EAAiC,GAEnCxO,GAAO,EACLyO,EAAc,WAChB,QAAIzO,IACJA,GAAO,EACPwO,EAAYzc,SAAQ,SAAC9F,GAAWA,GAAS,KAClC,EACV,EAEKyiB,EAAe,SAACvM,GACdA,EAAQd,cAAgBA,GACxBoN,KACJ1S,EAAQoG,EACX,EAID,GAHA,EAAKvW,GAAGmW,EAAiB2M,GACzBF,EAAYjiB,MAAK,WAAQ,EAAKoiB,eAAe5M,EAAiB2M,EAAgB,IAE1EH,EAAa,CACb,IAAIK,EAAkBL,EAAYM,WAC9BC,EAAuB,KACrBC,EAAiB,SAAjBA,EAAwB5N,GAAP,OAA8B6N,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,qFAC7ChP,EAD6C,iDAMjD,OANiD,SAM3Cd,GAAM,KANqC,OAQjDvU,KAAKskB,oBAAoBV,EAAYjN,MAAMpB,MAAK,SAAOuB,GAAP,OAAgBuN,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,0FACxDhP,EADwD,sDAGxDyB,GAAS8M,EAAY9M,OAHmC,gBAIxDmN,EAAkBzN,EAJsC,uBAStC,OATsC,SAShCxW,KAAKukB,eAAenN,GATY,YAS9CoN,EAT8C,SAUlB,MAArBA,EAAMhO,YAViC,mDAiBpC,MAAhB2N,IACAA,EAAeF,EAAkB,GACdL,EAAYM,aAC3BC,EAAeP,EAAYM,YApBqB,aAwBjDC,GAAgB3N,GAxBiC,qBAyBhDnB,EAzBgD,mDA2BtC,OA3BsC,UA2BhCrV,KAAKykB,yBAAyBN,GA3BE,QA2B9CjkB,EA3B8C,OA4B3CwkB,EAAK,EA5BsC,aA4BnCA,EAAKxkB,EAAMmY,aAAa3V,QA5BW,qBA6B1Cib,EAAKzd,EAAMmY,aAAaqM,IAGvBpV,OAAS8H,EAhCgC,sDAmC5CuG,EAAGhH,OAASiN,EAAYjN,MAAQgH,EAAG7G,QAAU8M,EAAY9M,MAnCb,qBAoCxCzB,EApCwC,mDAuC5B,OAvC4B,UAuCtBrV,KAAK2kB,mBAAmBhH,EAAGrO,KAAMoH,GAvCX,WAuCtCc,EAvCsC,QA0CxCsM,IA1CwC,0DA6CxCc,EAAS,WACTjH,EAAGzY,OAAS0e,EAAY1e,MAAQyY,EAAG9G,KAAO+M,EAAY/M,IAAM8G,EAAGje,MAAM6d,GAAGqG,EAAYlkB,OACpFklB,EAAS,WACW,OAAZjH,EAAGzY,MAAiByY,EAAGhH,OAASgH,EAAG9G,IAAM8G,EAAGje,MAAMma,WAC1D+K,EAAS,aAIb7Q,EAAOxU,GAAOyU,UAAU,2BAA4BxU,EAAAA,GAAAA,OAAAA,qBAAoC,CACpFqlB,UAAuB,aAAXD,GAAoC,cAAXA,EACrCA,OAAAA,EACAE,YAAa9kB,KAAK+kB,iBAAiBpH,GACnCrO,KAAM8H,EACNI,QAAAA,KA1DwC,2BA4BHkN,IA5BG,wBAgEpDP,IAhEoD,4BAoExD9O,EApEwD,mDAqE5DrV,KAAKyV,KAAK,QAAS2O,GArEyC,gDAAhB,IAuE7C,SAAC7jB,GACI8U,GACJ,EAAKI,KAAK,QAAS2O,EACtB,IAlFgD,+CAA9B,EAqFvB,GAAI/O,EAAQ,OACZ,EAAKI,KAAK,QAAS2O,GAEnBP,EAAYjiB,MAAK,WACb,EAAKoiB,eAAe,QAASI,EAChC,GACJ,CAED,GAAwB,kBAAb3R,GAAyBA,EAAU,EAAG,CAC7C,IAAMoB,EAAQxC,YAAW,WACjByS,KACJ/P,EAAOxU,GAAOyU,UAAU,mBAAoBxU,EAAAA,GAAAA,OAAAA,QAAuB,CAAEiT,QAASA,IACjF,GAAEA,GACCoB,EAAMmR,OAASnR,EAAMmR,QAEzBnB,EAAYjiB,MAAK,WAAQsS,aAAaL,EAAS,GAClD,CACJ,K,+CACJ,GAhtBL,4BAktBU,W,yJACK7T,KAAKsiB,wBAAwB,I,+CACvC,GAptBL,yBAstBU,W,sIACF,O,SAAMtiB,KAAK2E,a,OAEI,O,SAAM3E,KAAKiiB,QAAQ,cAAe,CAAC,G,cAA5C9a,EAAS,EAATA,K,2BAEKvG,EAAAA,GAAAA,KAAeuG,I,yDAEf5H,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC5EoQ,OAAQ,cACRzI,OAAAA,EAAQ5G,MAAK,Q,wDAGxB,GAluBL,wBAouBU,SAAW0kB,EAAyChP,G,wIACtD,O,SAAMjW,KAAK2E,a,OACI,O,UAAM1E,EAAAA,EAAAA,IAAkB,CACnC6V,QAAS9V,KAAK2e,YAAYsG,GAC1BhP,SAAUjW,KAAKklB,aAAajP,K,OAGjB,OALTkP,EAAS,EAATA,K,SAKenlB,KAAKiiB,QAAQ,aAAckD,G,cAA1Che,EAAS,EAATA,K,2BAEKvG,EAAAA,GAAAA,KAAeuG,I,2DAEf5H,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC5EoQ,OAAQ,aACRuV,OAAAA,EAAQhe,OAAAA,EAAQ5G,MAAK,Q,yDAGhC,GApvBL,iCAsvBU,SAAoB0kB,EAAyChP,G,wIAC/D,O,SAAMjW,KAAK2E,a,OACI,O,UAAM1E,EAAAA,EAAAA,IAAkB,CACnC6V,QAAS9V,KAAK2e,YAAYsG,GAC1BhP,SAAUjW,KAAKklB,aAAajP,K,OAGjB,OALTkP,EAAS,EAATA,K,SAKenlB,KAAKiiB,QAAQ,sBAAuBkD,G,cAAnDhe,EAAS,EAATA,K,2BAEKvG,EAAAA,GAAAA,KAAeuG,GAAQ4R,Y,2DAEvBxZ,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC5EoQ,OAAQ,sBACRuV,OAAAA,EAAQhe,OAAAA,EAAQ5G,MAAK,Q,yDAGhC,GAtwBL,qBAwwBU,SAAQ0kB,EAAyChP,G,wIACnD,O,SAAMjW,KAAK2E,a,OACI,O,UAAM1E,EAAAA,EAAAA,IAAkB,CACnC6V,QAAS9V,KAAK2e,YAAYsG,GAC1BhP,SAAUjW,KAAKklB,aAAajP,K,OAGjB,OALTkP,EAAS,EAATA,K,SAKenlB,KAAKiiB,QAAQ,UAAWkD,G,cAAvChe,EAAS,EAATA,K,4BAEKiI,EAAAA,EAAAA,IAAQjI,I,2DAER5H,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC5EoQ,OAAQ,UACRuV,OAAAA,EAAQhe,OAAAA,EAAQ5G,MAAK,Q,yDAGhC,GAxxBL,0BA0xBU,SAAa0kB,EAAyCG,EAAgDnP,G,wIACxG,O,SAAMjW,KAAK2E,a,OACI,O,UAAM1E,EAAAA,EAAAA,IAAkB,CACnC6V,QAAS9V,KAAK2e,YAAYsG,GAC1BhP,SAAUjW,KAAKklB,aAAajP,GAC5BmP,SAAUjU,QAAQC,QAAQgU,GAAU7P,MAAK,SAAC8P,GAAD,OAAOhM,EAAAA,EAAAA,IAASgM,EAAhB,M,OAE9B,OALTF,EAAS,EAATA,K,SAKenlB,KAAKiiB,QAAQ,eAAgBkD,G,cAA5Che,EAAS,EAATA,K,4BAEKiI,EAAAA,EAAAA,IAAQjI,I,2DAER5H,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC5EoQ,OAAQ,eACRuV,OAAAA,EAAQhe,OAAAA,EAAQ5G,MAAK,Q,yDAGhC,GA1yBL,8BA6yBI,SAAiBod,EAAiBrO,EAAe4U,GAAmB,WAChE,GAAY,MAAR5U,GAAwC,MAAxBgK,EAAAA,EAAAA,IAAchK,GAAgB,MAAM,IAAI1I,MAAM,sCAElE,IAAMO,EAA8BwW,EAwCpC,OArCY,MAARrO,GAAgBqO,EAAGrO,OAASA,GAC5B/P,GAAOwT,WAAW,2DAA4DvT,EAAAA,GAAAA,OAAAA,cAA6B,CAAE8lB,aAAc3H,EAAGrO,KAAMiW,aAAcjW,IAGtJnI,EAAOqe,KAAO,SAAOC,EAAmBhT,GAA1B,OAA8C4R,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,8EAiBxC,OAhBA,MAAZoB,IAAoBA,EAAW,GACpB,MAAXhT,IAAmBA,EAAU,GAG7BqS,OAAcne,EACD,IAAb8e,GAAgC,MAAdvB,IAClBY,EAAc,CACV5f,KAAMyY,EAAGzY,KACTyR,KAAMgH,EAAGhH,KACTG,MAAO6G,EAAG7G,MACVD,GAAI8G,EAAG9G,GACPnX,MAAOie,EAAGje,MACVwkB,WAAAA,IAbgD,SAiBlClkB,KAAK2jB,oBAAoBhG,EAAGrO,KAAMmW,EAAUhT,EAASqS,GAjBnB,UAkBzC,OADTtN,EAjBkD,SAkBpB,IAAbiO,EAlBiC,yCAkBR,MAlBQ,cAqBxDzlB,KAAKsgB,SAAS,KAAO3C,EAAGrO,MAAQkI,EAAQhB,YAEjB,IAAnBgB,EAAQ1G,QACRvR,GAAOwT,WAAW,qBAAsBvT,EAAAA,GAAAA,OAAAA,eAA8B,CAClE4X,gBAAiBuG,EAAGrO,KACpB8G,YAAauH,EACbnG,QAASA,IA3BuC,kBA8BjDA,GA9BiD,gDAA9C,EAiCPrQ,CACV,GAz1BL,6BA21BU,SAAgBue,G,4IAClB,O,SAAM1lB,KAAK2E,a,OACG,O,SAAMwM,QAAQC,QAAQsU,GAAmBnQ,MAAK,SAAAoQ,GAAC,OAAIvW,EAAAA,EAAAA,IAAQuW,EAAZ,I,OAGzC,OAHdC,EAAQ,EAARA,KAEkB,OADlBjI,EAAK3d,KAAKqd,UAAUjH,YAAYsP,IAC/BhP,gBAAyBiH,EAAGjH,cAAgB,G,SACzB1W,KAAKsiB,wBAAwB,IAAM,EAAItiB,KAAKuiB,iB,OAErD,OAFX/L,EAAc,EAAdA,K,oBAEiBxW,KAAKiiB,QAAQ,kBAAmB,CAAEyD,kBAAmBE,I,eAAlEtW,EAAO,EAAPA,K,kBACCtP,KAAK+kB,iBAAiBpH,EAAIrO,EAAMkH,I,yCAEjC,KAAOJ,YAAcuH,EACrB,KAAOvG,gBAAkBuG,EAAGrO,K,+DAGzC,GAz2BL,oCA22BU,SAAuB8G,G,+IACL,O,SAAMA,E,OA4Be,OA5BnCyP,EAAAA,EAAAA,KAEAlI,EAAU,CAAC,EAEjB,CAAC,OAAQ,MAAMvW,SAAQ,SAACsJ,GACD,MAAfmV,EAAOnV,KACXiN,EAAGjN,GAAOS,QAAQC,QAAQyU,EAAOnV,IAAM6E,MAAK,SAAC3N,GAAD,OAAQA,EAAI,EAAK+W,YAAY/W,GAAI,IAAjC,IAC/C,IAED,CAAC,WAAY,WAAY,eAAgB,uBAAwB,SAASR,SAAQ,SAACsJ,GAC5D,MAAfmV,EAAOnV,KACXiN,EAAGjN,GAAOS,QAAQC,QAAQyU,EAAOnV,IAAM6E,MAAK,SAAC3N,GAAD,OAAQA,EAAIhH,EAAAA,GAAAA,KAAegH,GAAI,IAA/B,IAC/C,IAED,CAAC,QAAQR,SAAQ,SAACsJ,GACK,MAAfmV,EAAOnV,KACXiN,EAAGjN,GAAOS,QAAQC,QAAQyU,EAAOnV,IAAM6E,MAAK,SAAC3N,GAAD,OAAc,MAALA,EAAaA,EAAG,IAAzB,IAC/C,IAEGie,EAAOxP,aACPsH,EAAGtH,WAAarW,KAAKqd,UAAUhH,WAAWwP,EAAOxP,aAGrD,CAAC,QAAQjP,SAAQ,SAACsJ,GACK,MAAfmV,EAAOnV,KACXiN,EAAGjN,GAAOS,QAAQC,QAAQyU,EAAOnV,IAAM6E,MAAK,SAAC3N,GAAD,OAAQA,GAAIwH,EAAAA,EAAAA,IAAQxH,GAAI,IAAxB,IAC/C,I,KAEM5H,KAAKqd,U,WAAmCpd,EAAAA,EAAAA,IAAkB0d,G,kDAA3CzG,mBAAAA,KAAAA,EAAAA,GAAAA,EAAAA,K,gDACzB,GAz4BL,wBA24BU,SAAWpK,G,6IACJ,O,SAAMA,E,OAkBc,OAlB7BA,EAAS,EAATA,KAEM3F,EAAc,CAAC,EAEC,MAAlB2F,EAAOgJ,UACP3O,EAAO2O,QAAU9V,KAAK2e,YAAY7R,EAAOgJ,UAG7C,CAAC,YAAa,UAAU1O,SAAQ,SAACsJ,GACH,MAAhB5D,EAAQ4D,KAClBvJ,EAAOuJ,GAAa5D,EAAQ4D,GAC/B,IAED,CAAC,YAAa,WAAWtJ,SAAQ,SAACsJ,GACJ,MAAhB5D,EAAQ4D,KAClBvJ,EAAOuJ,GAAO,EAAKwU,aAAmBpY,EAAQ4D,IACjD,I,KAEM1Q,KAAKqd,U,WAAuBpd,EAAAA,EAAAA,IAAkBkH,G,kDAA/B2F,OAAAA,KAAAA,EAAAA,GAAAA,EAAAA,K,gDACzB,GA/5BL,mBAi6BU,SAAMsJ,EAAiCH,EAAoB7B,G,kKAS9C,OARXA,GApkDe,IAqkDf7U,GAAOwT,WAAW,0CAA2CvT,EAAAA,GAAAA,OAAAA,aAA4B,CACrFsmB,UAAW1R,EAASgC,YAAAA,IAItB2P,EAAW3P,EAAYS,G,SAER7W,KAAKiiB,QAAQ,OAAQ,CAAE7L,YAAAA,EAAaH,SAAAA,I,UAAnD9O,EAAS,EAATA,OAGFiN,GAAW,GAAkB,WAAb6B,GAAqC,MAAZ8P,GAAgD,eAA5B5e,EAAO0L,UAAU,EAAG,MAAyByG,EAAAA,EAAAA,IAAcnS,GAAU,KAAO,GAAI,C,gBAmBzI,I,SAjBMjC,GAAOiU,EAAAA,EAAAA,IAAahS,EAAQ,GAG5Bqa,GAASrI,EAAAA,EAAAA,IAAajU,EAAM,EAAG,IAChCtE,EAAAA,GAAAA,KAAe4gB,GAAQjE,GAAGwI,IAC3BxmB,GAAOwT,WAAW,iCAAkCvT,EAAAA,GAAAA,OAAAA,eAA8B,CAC9E6C,KAAM,iBACN2jB,UAAW,sDACX5P,YAAAA,EAAalR,KAAMiC,IAKrBoa,EAAsB,GACtB0E,EAAarlB,EAAAA,GAAAA,MAAeuY,EAAAA,EAAAA,IAAajU,EAAM,GAAI,KAAK6T,WACxDmN,EAAatlB,EAAAA,GAAAA,MAAeuY,EAAAA,EAAAA,IAAajU,EAAM+gB,EAAYA,EAAa,KAAKlN,WAC7EoN,GAAWhN,EAAAA,EAAAA,IAAajU,EAAM+gB,EAAa,IACxCG,EAAI,EAAGA,EAAIF,EAAYE,IAEjB,OADLrjB,EAAMwZ,GAAa4J,EAAc,GAAJC,KAE/B7mB,GAAOwT,WAAW,yCAA0CvT,EAAAA,GAAAA,OAAAA,eAA8B,CACtF6C,KAAM,iBACN2jB,UAAW,sDACX5P,YAAAA,EAAalR,KAAMiC,IAG3Boa,EAAK3f,KAAKmB,GAmBK,OAfbue,EAAW9E,GAAYtX,EAAM,IAG9BtE,EAAAA,GAAAA,MAAeuY,EAAAA,EAAAA,IAAajU,EAAM,IAAK,MAAM2U,UAC9Cta,GAAOwT,WAAW,4CAA6CvT,EAAAA,GAAAA,OAAAA,eAA8B,CACzF6C,KAAM,iBACN2jB,UAAW,sDACX5P,YAAAA,EAAalR,KAAMiC,IAGrBkf,GAAmBlN,EAAAA,EAAAA,IAAajU,EAAM,GAAI,KAG1CkT,EAAYoE,GAAYtX,EAAM,K,UAEXlF,KAAKsmB,cAA2BlQ,EAAakL,EAAUC,G,eAC9D,OADZgF,EAAa,EAAbA,OAEFhnB,GAAOwT,WAAW,yCAA0CvT,EAAAA,GAAAA,OAAAA,eAA8B,CACtF6C,KAAM,iBACN2jB,UAAW,sDACX5P,YAAAA,EAAalR,KAAMiC,IAIrBwW,EAAK,CACP9G,GAAIkP,EACJ7gB,MAAMgY,EAAAA,EAAAA,IAAU,CAAEmJ,EAAkBtJ,GAAY,CAAEwJ,EAAYnO,O,kBAG3DpY,KAAKwmB,MAAM7I,EAAI1H,EAAU7B,EAAU,I,qCAGtC,KAAMoJ,OAAShe,EAAAA,GAAAA,OAAAA,aAA0BinB,C,uEAK1CrX,EAAAA,EAAAA,IAAQjI,I,4DAER5H,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC5EoQ,OAAQ,OACRuV,OAAQ,CAAE/O,YAAAA,EAAaH,SAAAA,GAAY9O,OAAAA,EAAQ5G,MAAK,Q,iEAI3D,GA1/BL,kBA4/BU,SAAK6V,EAA6CH,G,sIACpD,O,SAAMjW,KAAK2E,a,OACM,O,UAAM1E,EAAAA,EAAAA,IAAkB,CACrCmW,YAAapW,KAAK0mB,uBAAuBtQ,GACzCH,SAAUjW,KAAKklB,aAAajP,GAC5B2H,gBAAiBzM,QAAQC,QAAQgF,EAAYwH,mB,cAH3C+I,EAAW,EAAXA,K,kBAKC3mB,KAAKwmB,MAAMG,EAASvQ,YAAauQ,EAAS1Q,SAAU0Q,EAAS/I,gBAAkB,GAAI,I,+CAC7F,GApgCL,yBAsgCU,SAAYxH,G,wIACd,O,SAAMpW,KAAK2E,a,OACI,O,UAAM1E,EAAAA,EAAAA,IAAkB,CACnCmW,YAAapW,KAAK0mB,uBAAuBtQ,K,OAG9B,OAJT+O,EAAS,EAATA,K,SAIenlB,KAAKiiB,QAAQ,cAAekD,G,cAA3Che,EAAS,EAATA,K,2BAEKvG,EAAAA,GAAAA,KAAeuG,I,2DAEf5H,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC5EoQ,OAAQ,cACRuV,OAAAA,EAAQhe,OAAAA,EAAQ5G,MAAK,Q,yDAGhC,GArhCL,yBAuhCU,SAAY0kB,G,sIACE,O,SAAMA,E,OAKN,MAJc,kBAD9BA,EAAgB,EAAhBA,OAEI1lB,GAAOsF,mBAAmB,8BAA+B,OAAQogB,G,SAG/CjlB,KAAK4mB,YAAY3B,G,cACxB,OADTnP,EAAU,EAAVA,OAEFvW,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,sBAAqC,CAC9E4e,UAAW,eAAF,OAAkBpJ,KAAKyK,UAAUwF,GAAjC,O,kBAGVnP,G,+CACV,GApiCL,uBAsiCU,SAAU+Q,EAAqEC,G,+IACjF,O,SAAM9mB,KAAK2E,a,OAEW,O,SAAMkiB,E,UAA5BA,EAAsB,EAAtBA,KAGIrQ,GAAe,IAEb2O,EAAiC,CACnC2B,sBAAuBA,KAGvB7N,EAAAA,EAAAA,IAAY4N,EAAqB,IAAtB,C,gBACX1B,EAAO5O,UAAYsQ,E,wBAGG,O,oBAAM7mB,KAAKklB,aAAa2B,G,QAA1C1B,EAAOlP,SAAW,EAAXA,MACHgD,EAAAA,EAAAA,IAAYkM,EAAOlP,YACnBO,EAAc/B,SAAS0Q,EAAOlP,SAASpD,UAAU,GAAI,K,mDAGzDtT,GAAOsF,mBAAmB,kCAAmC,sBAAuBgiB,G,iCAIrF3R,IAAK,kBAAWmP,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,6FACL,OADK,SACCrkB,KAAKiiB,QAAQ,WAAYkD,GAD1B,UAIN,OAHPjlB,EADa,4BASS,MAApBilB,EAAO5O,UATI,mBAUmC,MAA1CvW,KAAKsgB,SAAS,KAAO6E,EAAO5O,WAVrB,yCAUkD,MAVlD,UAcQ,MAAnB4O,EAAOlP,SAdI,sBAePO,EAAcxW,KAAKsgB,SAASpgB,OAfrB,0CAeqC,MAfrC,sCAmBRyG,GAnBQ,YAuBfmgB,EAvBe,iBAwBXtQ,EAAsB,KACjBrR,EAAI,EAzBE,aAyBCA,EAAIjF,EAAMmY,aAAa3V,QAzBxB,oBA2BW,OADhBib,EAAKzd,EAAMmY,aAAalT,IACvBqR,YA3BI,iBA4BPmH,EAAGjH,cAAgB,EA5BZ,2BA8BoB,MAApBiH,EAAGjH,cA9BH,oBA+BY,MAAfF,EA/BG,iBAgCW,OAhCX,UAgCiBxW,KAAKsiB,wBAAwB,IAAM,EAAItiB,KAAKuiB,iBAhC7D,QAgCH/L,EAhCG,gBAoCHE,EAAiBF,EAAcmH,EAAGnH,YAAe,IAChC,IAAKE,EAAgB,GAC1CiH,EAAGjH,cAAgBA,EAtCZ,QAyBgCvR,IAzBhC,+BA0CT4hB,EAAoB/mB,KAAKqd,UAAU/E,sBAAsBpY,IAClDmY,aAAe0O,EAAa1O,aAAa7O,KAAI,SAACmU,GAAD,OAA6B,EAAKoH,iBAAiBpH,EAAnD,IA3C3C,kBA4CRoJ,GA5CQ,iCA+CZ/mB,KAAKqd,UAAUnd,MAAMA,IA/CT,gDAAX,GAiDT,CAAEsV,SAAUxV,Q,0DAClB,GAjnCL,sBAmnCI,SAAS6mB,GACL,OAAwB7mB,KAAKgnB,UAAUH,GAAqB,EAC/D,GArnCL,sCAunCI,SAAyBA,GACrB,OAAwC7mB,KAAKgnB,UAAUH,GAAqB,EAC/E,GAznCL,4BA2nCU,SAAezP,G,6IACjB,O,SAAMpX,KAAK2E,a,OACO,O,SAAMyS,E,cAAxBA,EAAkB,EAAlBA,KAEM+N,EAAS,CAAE/N,gBAAiBpX,KAAKqd,UAAU/N,KAAK8H,GAAiB,I,kBAEhElC,IAAK,kBAAWmP,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,kFACJ,OADI,SACErkB,KAAKiiB,QAAQ,iBAAkBkD,GADjC,UAGL,OAFRhe,EADa,2BAI8B,MAAzCnH,KAAKsgB,SAAS,KAAOlJ,GAJV,yCAKJ,MALI,qCAORzQ,GAPQ,UAYG,OAFhBgX,EAAK3d,KAAKqd,UAAU9E,oBAAoBpR,IAEvCqP,YAZY,iBAafmH,EAAGjH,cAAgB,EAbJ,2BAeY,MAApBiH,EAAGjH,cAfK,iBAgBK,OAhBL,UAgBW1W,KAAKsiB,wBAAwB,IAAM,EAAItiB,KAAKuiB,iBAhBvD,QAgBT/L,EAhBS,QAmBXE,EAAiBF,EAAcmH,EAAGnH,YAAe,IAChC,IAAKE,EAAgB,GAC1CiH,EAAGjH,cAAgBA,EArBJ,iCAwBZ1W,KAAK+kB,iBAAiBpH,IAxBV,gDAAX,GAyBT,CAAEnI,SAAUxV,Q,+CAClB,GA3pCL,mCA6pCU,SAAsBoX,G,6IACxB,O,SAAMpX,KAAK2E,a,OAEO,O,SAAMyS,E,cAAxBA,EAAkB,EAAlBA,KAEM+N,EAAS,CAAE/N,gBAAiBpX,KAAKqd,UAAU/N,KAAK8H,GAAiB,I,kBAEhElC,IAAK,kBAAWmP,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,kFACJ,OADI,SACErkB,KAAKiiB,QAAQ,wBAAyBkD,GADxC,UAGL,OAFRhe,EADa,2BAI8B,MAAzCnH,KAAKsgB,SAAS,KAAOlJ,GAJV,yCAKJ,MALI,qCAORzQ,GAPQ,UAWK,MAApBQ,EAAOoP,UAXQ,8CAWoB5P,GAXpB,UAeQ,OAFrB6Q,EAAUxX,KAAKqd,UAAU7F,QAAQrQ,IAE3BqP,YAfO,iBAgBfgB,EAAQd,cAAgB,EAhBT,2BAkBiB,MAAzBc,EAAQd,cAlBA,iBAmBK,OAnBL,UAmBW1W,KAAKsiB,wBAAwB,IAAM,EAAItiB,KAAKuiB,iBAnBvD,QAmBT/L,EAnBS,QAsBXE,EAAiBF,EAAcgB,EAAQhB,YAAe,IACrC,IAAKE,EAAgB,GAC1Cc,EAAQd,cAAgBA,EAxBT,iCA2BZc,GA3BY,gDAAX,GA4BT,CAAEhC,SAAUxV,Q,+CAClB,GAjsCL,qBAmsCU,SAAQ8M,G,wIACV,O,SAAM9M,KAAK2E,a,OACI,O,UAAM1E,EAAAA,EAAAA,IAAkB,CAAE6M,OAAQ9M,KAAKinB,WAAWna,K,OACxC,OADnBqY,EAAS,EAATA,K,SACyBnlB,KAAKiiB,QAAQ,UAAWkD,G,cAAjDtN,EAAAA,EAAAA,MACDzQ,SAAQ,SAACwT,GACS,MAAfA,EAAIjC,UAAmBiC,EAAIjC,SAAU,EAC5C,I,kBACMhD,GAAU2B,QAAQtX,KAAKqd,UAAU3E,UAAU3C,KAAK/V,KAAKqd,WAArD1H,CAAiEkC,I,gDAC3E,GA3sCL,2BA6sCU,W,gIACF,O,SAAM7X,KAAK2E,a,gCACJ3E,KAAKiiB,QAAQ,gBAAiB,CAAC,I,+CACzC,GAhtCL,0BAktCU,SAAahM,G,sIACJ,O,SAAMA,E,YAEQ,kBAFzBA,EAAW,EAAXA,OAEqCA,EAAW,I,gBAK1B,OAJdA,EAAW,GACX1W,GAAOsF,mBAAmB,mBAAoB,WAAYoR,G,SAGtCjW,KAAKsiB,wBAAwB,IAAM,EAAItiB,KAAKuiB,iB,cAAhE/L,EAAc,EAAdA,MACJA,GAAeP,GACG,IAAKO,EAAc,G,kBAC9BxW,KAAKqd,UAAUpH,SAASO,I,iCAG5BxW,KAAKqd,UAAUpH,SAASA,I,gDAClC,GAjuCL,yBAouCU,SAAY5T,G,0IACV6kB,EAAc7kB,E,UAEM,KAAhB6kB,GAAsC,MAAhBA,EAAgB,C,wCAAc,M,UAI3C,QAAT7kB,GAAkC,QAAhB6kB,EAAgB,C,wCAAgB,M,OAGzC,O,SAAMlnB,KAAKmnB,aAAaD,EAAa,e,UAGtC,OAHN/H,EAAO,EAAPA,MAGM,C,mBACFiI,EAAW,IAAIjK,GAASnd,KAAMmf,EAAM9c,G,KAGtC6kB,IAAgB7kB,G,sBAAU,O,UAAM+kB,EAAStJ,mB,gFAA8B,M,iCAEpEsJ,G,QAIXF,EAAcA,EAAYja,MAAM,KAAKnC,MAAM,GAAGmQ,KAAK,K,+DAG1D,GA9vCL,0BAgwCU,SAAa5Y,EAAc+b,G,wIAGb,OAFC,MAAbA,IAAqBA,EAAY,O,SAEfpe,KAAK2E,a,OAaN,OAbftD,EAAU,EAAVA,MAGO8B,YACT5D,GAAOwT,WACH,+BACAvT,EAAAA,GAAAA,OAAAA,sBACA,CAAE4e,UAAAA,EAAW/c,QAASA,EAAQgB,O,kBAMXrC,KAAKuH,KAAK,CAC7BsP,GAAIxV,EAAQ8B,WACZ+B,KAAO,aAAe+J,GAAS5M,GAAMwQ,UAAU,K,cAF7CwU,EAAW,EAAXA,K,kBAICrnB,KAAKqd,UAAUoB,YAAY4I,I,mEAK/B,M,yDACV,GA1xCL,yBA4xCU,SAAYhlB,G,sIACP,O,SAAMA,E,cAAbA,EAAO,EAAPA,K,2BAIW8O,QAAQC,QAAQpR,KAAKqd,UAAUvH,QAAQzT,K,qCAG1C4W,EAAAA,EAAAA,IAAY5W,GAAD,C,mCAQF,MALI,kBAAVA,GACP9C,GAAOsF,mBAAmB,mBAAoB,OAAQxC,G,UAInCrC,KAAKsnB,YAAYjlB,G,WAAlC+kB,EAAW,EAAXA,KACS,C,yCAAS,M,QAEjB,O,UAAMA,EAASlO,a,iGACzB,GAhzCL,2BAkzCU,SAAcpD,G,0IACN,O,SAAMA,E,OAKK,OALrBA,EAAU,EAAVA,KACAA,EAAU9V,KAAKqd,UAAUvH,QAAQA,GAE3B5J,EAAO4J,EAAQjD,UAAU,GAAGlC,cAAgB,gB,SAEvB3Q,KAAKmnB,aAAajb,EAAM,iB,UAC/B,OADdqb,EAAe,EAAfA,MACc,C,yCAAe,M,QAGT,O,KAAbhL,G,UAAmBvc,KAAKuH,KAAK,CACtCsP,GAAI0Q,EACJriB,KAAO,aAAe+J,GAAS/C,GAAM2G,UAAU,K,QAGtC,O,YALPxQ,GAAO,EAAPA,EAAAA,IAAAA,EAAAA,GAGF,G,UAEerC,KAAK4mB,YAAYvkB,G,WAAvB,EAAP8c,MACMrJ,EAAAA,C,yCAAkB,M,iCAEvBzT,G,gDACV,GAr0CL,uBAu0CU,SAAUmlB,G,qJACRJ,EAAqB,OACrBnO,EAAAA,EAAAA,IAAYuO,GAAD,C,gBAMa,OAJlB1R,EAAU9V,KAAKqd,UAAUvH,QAAQ0R,GAEjCtb,EAAO4J,EAAQjD,UAAU,GAAGlC,cAAgB,gB,SAEpB3Q,KAAKmnB,aAAajb,EAAM,a,UAAhDub,EAAkB,EAAlBA,KACgB,C,wCAAS,M,OAKZ,OAFnBL,EAAW,IAAIjK,GAASnd,KAAMynB,EAAiBvb,G,oBAEtBkb,EAASM,Y,aAAxB3I,EAAAA,EAAAA,MACFA,C,yCAAiBA,EAAOhc,K,8DAExB,KAAMya,OAAShe,EAAAA,GAAAA,OAAAA,eAA4Bue,C,mCAMrB,O,eAAbxB,G,UAAmBvc,KAAKuH,KAAK,CACtCsP,GAAI4Q,EACJviB,KAAO,aAAe+J,GAAS/C,GAAM2G,UAAU,K,QAExC,O,YAJLxQ,GAAO,EAAPA,EAAAA,IAAAA,EAAAA,GAGF,G,UACarC,KAAKsnB,YAAYjlB,G,QAAlC+kB,EAAW,EAAXA,K,sDAEI,KAAM5J,OAAShe,EAAAA,GAAAA,OAAAA,eAA4Bue,C,4DACxC,M,gCAKA,O,UAAM/d,KAAKsnB,YAAYE,G,WAAlCJ,EAAW,EAAXA,KACe,C,yCAAS,M,QAGb,O,UAAMA,EAASM,Y,WAChB,OADR3I,EAAS,EAATA,MACQ,C,yCAAe,M,iCAEtBA,EAAOhc,K,kEACjB,GAl3CL,qBAo3CI,SAAQ6M,EAAgBuV,GACpB,OAAO5lB,GAAOwT,WAAWnD,EAAS,mBAAoBpQ,EAAAA,GAAAA,OAAAA,gBAA+B,CAAE4e,UAAWxO,GACrG,GAt3CL,yBAw3CI,SAAYyR,GACRrhB,KAAKgjB,QAAWhjB,KAAKqgB,QAAQvT,QAAO,SAAC6a,GAAD,OAAOA,EAAEC,UAAT,IAAqBllB,OAAS,CACrE,GA13CL,wBA43CI,SAAW2e,GACPrhB,KAAKgjB,QAAWhjB,KAAKqgB,QAAQvT,QAAO,SAAC6a,GAAD,OAAOA,EAAEC,UAAT,IAAqBllB,OAAS,CACrE,GA93CL,+BAg4CI,SAAkB3B,EAAsBC,EAAoByU,GACxD,IAAM4L,EAAQ,IAAI7F,GAAMN,GAAYna,GAAYC,EAAUyU,GAI1D,OAHAzV,KAAKqgB,QAAQze,KAAKyf,GAClBrhB,KAAK6nB,YAAYxG,GAEVrhB,IACV,GAt4CL,gBAw4CI,SAAGe,EAAsBC,GACrB,OAAOhB,KAAK8nB,kBAAkB/mB,EAAWC,GAAU,EACtD,GA14CL,kBA44CI,SAAKD,EAAsBC,GACvB,OAAOhB,KAAK8nB,kBAAkB/mB,EAAWC,GAAU,EACtD,GA94CL,kBAi5CI,SAAKD,GAAyC,kCAAhBgnB,EAAgB,iCAAhBA,EAAgB,kBAC1C,IAAI5gB,GAAS,EAET6gB,EAAwB,GAExBC,EAAW/M,GAAYna,GAoB3B,OAnBAf,KAAKqgB,QAAUrgB,KAAKqgB,QAAQvT,QAAO,SAACuU,GAChC,OAAIA,EAAM5F,MAAQwM,IAElB5W,YAAW,WACPgQ,EAAMrgB,SAASknB,MAAM,EAAMH,EAC9B,GAAE,GAEH5gB,GAAS,GAELka,EAAM5L,OACNuS,EAAQpmB,KAAKyf,IACN,GAId,IAED2G,EAAQ5gB,SAAQ,SAACia,GAAY,EAAK8G,WAAW9G,EAAS,IAE/Cla,CACV,GA36CL,2BA66CI,SAAcpG,GACV,IAAKA,EAAa,OAAOf,KAAKqgB,QAAQ3d,OAEtC,IAAIulB,EAAW/M,GAAYna,GAC3B,OAAOf,KAAKqgB,QAAQvT,QAAO,SAACuU,GACxB,OAAQA,EAAM5F,MAAQwM,CACzB,IAAEvlB,MACN,GAp7CL,uBAs7CI,SAAU3B,GACN,GAAiB,MAAbA,EACA,OAAOf,KAAKqgB,QAAQ7W,KAAI,SAAC6X,GAAD,OAAWA,EAAMrgB,QAAjB,IAG5B,IAAIinB,EAAW/M,GAAYna,GAC3B,OAAOf,KAAKqgB,QACPvT,QAAO,SAACuU,GAAD,OAAYA,EAAM5F,MAAQwM,CAA1B,IACPze,KAAI,SAAC6X,GAAD,OAAWA,EAAMrgB,QAAjB,GACZ,GA/7CL,iBAi8CI,SAAID,EAAsBC,GAAmB,WACzC,GAAgB,MAAZA,EACA,OAAOhB,KAAKooB,mBAAmBrnB,GAGnC,IAAMinB,EAAwB,GAE1BK,GAAQ,EAERJ,EAAW/M,GAAYna,GAW3B,OAVAf,KAAKqgB,QAAUrgB,KAAKqgB,QAAQvT,QAAO,SAACuU,GAChC,OAAIA,EAAM5F,MAAQwM,GAAY5G,EAAMrgB,UAAYA,MAC5CqnB,IACJA,GAAQ,EACRL,EAAQpmB,KAAKyf,IACN,GACV,IAED2G,EAAQ5gB,SAAQ,SAACia,GAAY,EAAK8G,WAAW9G,EAAS,IAE/CrhB,IACV,GAt9CL,gCAw9CI,SAAmBe,GAAqB,WAChCinB,EAAwB,GAC5B,GAAiB,MAAbjnB,EACAinB,EAAUhoB,KAAKqgB,QAEfrgB,KAAKqgB,QAAU,OACZ,CACH,IAAM4H,EAAW/M,GAAYna,GAC7Bf,KAAKqgB,QAAUrgB,KAAKqgB,QAAQvT,QAAO,SAACuU,GAChC,OAAIA,EAAM5F,MAAQwM,IAClBD,EAAQpmB,KAAKyf,IACN,EACV,GACJ,CAID,OAFA2G,EAAQ5gB,SAAQ,SAACia,GAAY,EAAK8G,WAAW9G,EAAS,IAE/CrhB,IACV,IA1+CL,2BAqJI,WAII,OAHwB,MAApBkgB,KACAA,GAAmB,IAAIvK,IAEpBuK,EACV,GA1JL,wBA6JI,SAAkB7e,GACd,OAAOsD,EAAuB,MAAXtD,EAAmB,YAAaA,EACtD,KA/JL,GAAkCxB,G,2UEprB5BN,GAAS,IAAIC,EAAAA,GCTI,yBDWjB8oB,GAAwC,CAC1C,aAAc,kBAAmB,UAAW,aAAc,OAAQ,OAAQ,WAAY,WAAY,eAAgB,uBAAwB,QAAS,KAAM,OAAQ,SAG/JC,GAAgB,CAClB/oB,EAAAA,GAAAA,OAAAA,mBACAA,EAAAA,GAAAA,OAAAA,cACAA,EAAAA,GAAAA,OAAAA,yBAuCkBgpB,GAAtB,WA8BI,6BACIjpB,GAAOO,cAAP,0CAAiC0oB,IACjCzoB,EAAAA,EAAAA,IAAeC,KAAM,aAAa,EACrC,CAjCL,yCAuCU,SAAWiW,G,gIAEN,OADPjW,KAAKyoB,eAAe,c,SACPzoB,KAAKmC,SAASumB,WAAW1oB,KAAKkZ,aAAcjD,G,uFAC5D,GA1CL,iCA4CU,SAAoBA,G,gIAEf,OADPjW,KAAKyoB,eAAe,uB,SACPzoB,KAAKmC,SAASmiB,oBAAoBtkB,KAAKkZ,aAAcjD,G,uFACrE,GA/CL,yBAkDU,SAAYG,G,sIAEH,OADXpW,KAAKyoB,eAAe,e,UACHxoB,EAAAA,EAAAA,IAAkBD,KAAK2oB,iBAAiBvS,I,OAClD,OADDuH,EAAK,EAALA,K,SACO3d,KAAKmC,SAASymB,YAAYjL,G,uFAC1C,GAtDL,kBAyDU,SAAKvH,EAA6CH,G,sIAEzC,OADXjW,KAAKyoB,eAAe,Q,UACHxoB,EAAAA,EAAAA,IAAkBD,KAAK2oB,iBAAiBvS,I,OAClD,OADDuH,EAAK,EAALA,K,SACO3d,KAAKmC,SAASoF,KAAKoW,EAAI1H,G,uFACvC,GA7DL,6BAgEU,SAAgBG,G,wIAEP,OADXpW,KAAKyoB,eAAe,mB,SACHzoB,KAAK6oB,oBAAoBzS,G,OACzB,OADXuH,EAAK,EAALA,K,SACiB3d,KAAK8oB,gBAAgBnL,G,OACrC,OADDoL,EAAW,EAAXA,K,SACO/oB,KAAKmC,SAAS6mB,gBAAgBD,G,wFAC9C,GArEL,wBAuEU,W,sIAEc,OADhB/oB,KAAKyoB,eAAe,c,SACEzoB,KAAKmC,SAASwC,a,cAA9BtD,EAAU,EAAVA,K,kBACCA,EAAQ6B,S,+CAClB,GA3EL,yBA6EU,W,gIAEK,OADPlD,KAAKyoB,eAAe,e,SACPzoB,KAAKmC,SAAS9B,c,uFAC9B,GAhFL,wBAkFU,W,gIAEK,OADPL,KAAKyoB,eAAe,c,SACPzoB,KAAKmC,SAAS8mB,a,uFAC9B,GArFL,yBAwFU,SAAY5mB,G,gIAEP,OADPrC,KAAKyoB,eAAe,e,SACPzoB,KAAKmC,SAASykB,YAAYvkB,G,uFAC1C,GA3FL,8BAwGI,SAAiB+T,GACb,IAAK,IAAM1F,KAAO0F,GAC+B,IAAzCkS,GAAuBlmB,QAAQsO,IAC/BnR,GAAOsF,mBAAmB,4BAA8B6L,EAAK,cAAe0F,GAIpF,IAAMuH,GAAK3L,EAAAA,EAAAA,IAAYoE,GAkBvB,OAhBe,MAAXuH,EAAGhH,KACHgH,EAAGhH,KAAO3W,KAAKkZ,aAIfyE,EAAGhH,KAAOxF,QAAQ4R,IAAI,CAClB5R,QAAQC,QAAQuM,EAAGhH,MACnB3W,KAAKkZ,eACN3D,MAAK,SAACpO,GAIL,OAHIA,EAAO,GAAGwJ,gBAAkBxJ,EAAO,GAAGwJ,eACtCpR,GAAOsF,mBAAmB,wBAAyB,cAAeuR,GAE/DjP,EAAO,EACjB,IAGEwW,CACV,GAlIL,iCA2IU,SAAoBvH,G,mJAEqB,O,UAAMnW,EAAAA,EAAAA,IAAkBD,KAAK2oB,iBAAiBvS,I,UAE5E,OAFPuH,EAAAA,EAAAA,MAEC9G,KACH8G,EAAG9G,GAAK1F,QAAQC,QAAQuM,EAAG9G,IAAItB,MAAK,SAAOsB,GAAP,OAAawN,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,+EACnC,MAANxN,EADyC,yCACpB,MADoB,OAE7B,OAF6B,SAEvB7W,KAAK4mB,YAAY/P,GAFM,cAG9B,OADTf,EAFuC,SAIzCvW,GAAOsF,mBAAmB,qCAAsC,QAASgS,GAJhC,kBAMtCf,GANsC,+CAAb,IAUpC6H,EAAG9G,GAAGvW,OAAM,SAACC,GAAc,KAIzB2oB,EAAiC,MAAnBvL,EAAGld,cAAmD,MAA3Bkd,EAAGjd,qBAC/B,MAAfid,EAAGvd,UAAiC,IAAZud,EAAGpM,OAAc2X,EAErB,IAAZvL,EAAGpM,MAA0B,IAAZoM,EAAGpM,OAAe2X,GAC3C3pB,GAAOsF,mBAAmB,4EAA6E,cAAeuR,GAFtH7W,GAAOsF,mBAAmB,+CAAgD,cAAeuR,GAK5E,IAAZuH,EAAGpM,MAAyB,MAAXoM,EAAGpM,MAAqC,MAAnBoM,EAAGld,cAAmD,MAA3Bkd,EAAGjd,qBAA+B,C,gBAEpGid,EAAGpM,KAAO,E,2BAES,IAAZoM,EAAGpM,MAA0B,IAAZoM,EAAGpM,KAAS,C,gBAIjB,MAAfoM,EAAGvd,WAAoBud,EAAGvd,SAAWJ,KAAKK,e,wBAK9B,O,UAAML,KAAKipB,a,QAArBE,EAAU,EAAVA,KAES,MAAXxL,EAAGpM,KAGyB,MAAxB4X,EAAQ1oB,cAAwD,MAAhC0oB,EAAQzoB,sBAIxCid,EAAGpM,KAAO,EAES,MAAfoM,EAAGvd,UAGGA,EAAWud,EAAGvd,gBACbud,EAAGvd,SACVud,EAAGld,aAAeL,EAClBud,EAAGjd,qBAAuBN,IAIH,MAAnBud,EAAGld,eAAwBkd,EAAGld,aAAe0oB,EAAQ1oB,cAC1B,MAA3Bkd,EAAGjd,uBAAgCid,EAAGjd,qBAAuByoB,EAAQzoB,wBAGlD,MAApByoB,EAAQ/oB,UAIX8oB,GACA3pB,GAAOwT,WAAW,oCAAqCvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACxF4e,UAAW,wBAKA,MAAfT,EAAGvd,WAAoBud,EAAGvd,SAAW+oB,EAAQ/oB,UAGjDud,EAAGpM,KAAO,GAIVhS,GAAOwT,WAAW,oCAAqCvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACxF4e,UAAW,sBAIA,IAAZT,EAAGpM,OAIa,MAAnBoM,EAAGld,eAAwBkd,EAAGld,aAAe0oB,EAAQ1oB,cAC1B,MAA3Bkd,EAAGjd,uBAAgCid,EAAGjd,qBAAuByoB,EAAQzoB,uB,QAiC1E,OA7BS,MAAZid,EAAG7G,QAAiB6G,EAAG7G,MAAQ9W,KAAKskB,oBAAoB,YAEzC,MAAf3G,EAAG/G,WACH+G,EAAG/G,SAAW5W,KAAK4oB,YAAYjL,GAAIrd,OAAM,SAACC,GACtC,GAAIgoB,GAAcnmB,QAAQ7B,EAAMid,OAAS,EACrC,MAAMjd,EAGV,OAAOhB,GAAOwT,WAAW,4EAA6EvT,EAAAA,GAAAA,OAAAA,wBAAuC,CACzIe,MAAOA,EACPod,GAAIA,GAEX,KAGa,MAAdA,EAAGza,QACHya,EAAGza,QAAUlD,KAAKopB,aAElBzL,EAAGza,QAAUiO,QAAQ4R,IAAI,CACrB5R,QAAQC,QAAQuM,EAAGza,SACnBlD,KAAKopB,eACN7T,MAAK,SAAC8T,GAIL,OAHmB,IAAfA,EAAQ,IAAYA,EAAQ,KAAOA,EAAQ,IAC3C9pB,GAAOsF,mBAAmB,2BAA4B,cAAeuR,GAElEiT,EAAQ,EAClB,I,WAGQppB,EAAAA,EAAAA,IAAkB0d,G,yFAClC,GAzQL,4BA+QI,SAAeS,GACNpe,KAAKmC,UAAY5C,GAAOwT,WAAW,mBAAoBvT,EAAAA,GAAAA,OAAAA,sBAAqC,CAC7F4e,UAAYA,GAAa,kBAEhC,IAnRL,uBAqRI,SAAgB1e,GACZ,SAAUA,IAASA,EAAM4pB,UAC5B,KAvRL,KEtDM,SAAUC,GAAGC,GACf,OAAOta,EAAAA,EAAAA,IAAUJ,EAAAA,EAAAA,IAAY0a,GAChC,C,2SCIKjqB,GAAS,IAAIC,EAAAA,GAAOuH,GAIpB0iB,GAAU,IAAIhjB,WAAW,IAC/BgjB,GAAQjf,KAAK,GAEb,IAAMkf,GAAyB9oB,EAAAA,GAAAA,MAAgB,GACzC+oB,GAAkB/oB,EAAAA,GAAAA,KAAe,GACjCgpB,GAAiBhpB,EAAAA,GAAAA,KAAe,GAChCipB,GAAwBjpB,EAAAA,GAAAA,KAAe,sEAW7C,IAAMkpB,IAAUvQ,EAAAA,EAAAA,IAAWqQ,GAAIzN,cAAe,IACxC4N,IAAWxQ,EAAAA,EAAAA,IAAWoQ,GAAKxN,cAAe,IAE1C6N,GAA2C,CAC7C3nB,KAAM,SACN0E,QAAS,SACT7D,QAAS,UACT+mB,kBAAmB,UACnBC,KAAM,WAGJC,GAAkC,CACpC,OAAQ,UAAW,UAAW,oBAAqB,QAGvD,SAASC,GAAY1Z,GACjB,OAAO,SAAUhR,GAIb,MAHsB,kBAAXA,GACPH,GAAOsF,mBAAP,mCAAuDmQ,KAAKyK,UAAU/O,IAAtE,iBAA0FA,GAAQhR,GAE/FA,CACV,CACJ,CAED,IAAM2qB,GAAoD,CACtDhoB,KAAM+nB,GAAY,QAClBrjB,QAASqjB,GAAY,WACrBlnB,QAAS,SAASxD,GACd,IACI,OAAOkB,EAAAA,GAAAA,KAAelB,GAAOqO,UACd,CAAjB,MAAOxN,GAAU,CACnB,OAAOhB,GAAOsF,mBAAP,qCAAgE,iBAAkBnF,EAC5F,EACDuqB,kBAAmB,SAASvqB,GACxB,IACI,OAAOwZ,EAAAA,GAAAA,IAAWxZ,GAAOiR,aACV,CAAjB,MAAOpQ,GAAU,CACnB,OAAOhB,GAAOsF,mBAAP,2CAAsE,2BAA4BnF,EAC5G,EACDwqB,KAAM,SAASxqB,GACX,IACI,IAAM8G,GAAQnB,EAAAA,EAAAA,IAAS3F,GACvB,GAAqB,KAAjB8G,EAAM9D,OAAiB,MAAM,IAAIkE,MAAM,cAC3C,OAAOwI,EAAAA,EAAAA,IAAQ5I,EACA,CAAjB,MAAOjG,GAAU,CACnB,OAAOhB,GAAOsF,mBAAP,8BAAyD,cAAenF,EAClF,GAGL,SAAS4qB,GAAe/Y,GAGhB,IAAM+B,EAAQ/B,EAAK+B,MAAM,kBACzB,GAAIA,EAAO,CACP,IAAM3J,EAAuB,KAAb2J,EAAM,GAEhBiX,EAAQ9V,SAASnB,EAAM,IAAM,QAC/BiX,EAAQ,IAAM,GAAKA,EAAQ,KAAQjX,EAAM,IAAMA,EAAM,KAAO/N,OAAOglB,KACnEhrB,GAAOsF,mBAAmB,wBAAyB,OAAQ0M,GAG/D,IAAMiZ,EAAcX,GAAWY,KAAK9gB,EAAU4gB,EAAQ,EAAIA,GACpDG,EAAc/gB,EAAS6gB,EAAY1pB,IAAI8oB,IAAK/oB,IAAI6oB,IAAcC,GAEpE,OAAO,SAASjqB,GACZ,IAAMkI,EAAIhH,EAAAA,GAAAA,KAAelB,GAMzB,OAJIkI,EAAE+iB,GAAGD,IAAgB9iB,EAAEgjB,GAAGJ,KAC1BjrB,GAAOsF,mBAAP,kCAAsD0M,GAAS,QAAS7R,IAGrE6Z,EAAAA,EAAAA,IAAW3R,EAAEijB,OAAO,KAAK1O,cAAe,GAClD,CACJ,CAKD,IAAM7I,EAAQ/B,EAAK+B,MAAM,gBACzB,GAAIA,EAAO,CACP,IAAMiX,EAAQ9V,SAASnB,EAAM,IAK7B,OAJc,IAAViX,GAAeA,EAAQ,IAAMjX,EAAM,KAAO/N,OAAOglB,KACjDhrB,GAAOsF,mBAAmB,sBAAuB,OAAQ0M,GAGtD,SAAS7R,GAKZ,OAJc2F,EAAAA,EAAAA,IAAS3F,GACbgD,SAAW6nB,GACjBhrB,GAAOsF,mBAAP,6BAAiD0M,GAAS,QAAS7R,GAjGvF,SAAqBA,GACjB,IAAM8G,GAAQnB,EAAAA,EAAAA,IAAS3F,GACjBorB,EAAYtkB,EAAM9D,OAAS,GACjC,OAAIooB,GACO5N,EAAAA,EAAAA,IAAU,CAAE1W,EAAOijB,GAAQ3e,MAAMggB,MAErC1b,EAAAA,EAAAA,IAAQ5I,EAClB,CA4FsBukB,CAAYrrB,EACtB,CACJ,CAGL,OAAQ6R,GACJ,IAAK,UAAW,OAAO,SAAS7R,GAC5B,OAAO6Z,EAAAA,EAAAA,KAAWL,EAAAA,GAAAA,IAAWxZ,GAAQ,GACxC,EACD,IAAK,OAAQ,OAAO,SAASA,GACzB,OAAUA,EAAmBoqB,GAAVC,EACtB,EACD,IAAK,QAAS,OAAO,SAASrqB,GAC1B,OAAOwP,EAAAA,EAAAA,GAAUxP,EACpB,EACD,IAAK,SAAU,OAAO,SAASA,GAC3B,OAAO6pB,GAAG7pB,EACb,EAGL,OAAO,IACV,CAED,SAASsrB,GAAW3oB,EAAc4oB,GAC9B,MAAO,GAAP,OAAW5oB,EAAX,YAAqB4oB,EAAOzhB,KAAI,gBAAGnH,EAAH,EAAGA,KAAH,SAASkP,KAAmB,IAAMlP,CAAlC,IAAyC4Y,KAAK,KAA9E,IACH,CAEM,IAAMiQ,GAAb,WAOI,WAAYC,IAA4C,gBACpDprB,EAAAA,EAAAA,IAAeC,KAAM,QAASiS,OAAOmZ,QAAOC,EAAAA,EAAAA,IAASF,MAErDprB,EAAAA,EAAAA,IAAeC,KAAM,gBAAiB,CAAC,IACvCD,EAAAA,EAAAA,IAAeC,KAAM,SAAU,CAAC,GAGhC,IAAMsrB,EAAiD,CAAC,EAGlDC,EAAyC,CAAC,EAG1CC,EAAoD,CAAC,EAE3DvZ,OAAOjG,KAAKmf,GAAO/jB,SAAQ,SAACmK,GACxB+Z,EAAM/Z,GAAQ,CAAC,EACfga,EAAQha,GAAQ,GAChBia,EAASja,GAAQ,CAAC,CACrB,IAnBmD,eAqBzClP,GAEP,IAAMopB,EAAuC,CAAC,EAE9CN,EAAM9oB,GAAM+E,SAAQ,SAACskB,GAGbD,EAAYC,EAAMrpB,OAClB9C,GAAOsF,mBAAP,kCAAsDmQ,KAAKyK,UAAUiM,EAAMrpB,MAA3E,eAAyF2S,KAAKyK,UAAUpd,IAAU,QAAS8oB,GAE/HM,EAAYC,EAAMrpB,OAAQ,EAG1B,IAAMspB,EAAWD,EAAMna,KAAK+B,MAAM,uBAAuB,GACrDqY,IAAatpB,GACb9C,GAAOsF,mBAAP,qCAAyDmQ,KAAKyK,UAAUkM,IAAc,QAASR,GAInFb,GAAeqB,KAG1BJ,EAAQI,IACTpsB,GAAOsF,mBAAP,uBAA2CmQ,KAAKyK,UAAUkM,IAAc,QAASR,GAIrFI,EAAQI,GAAU/pB,KAAKS,GACvBipB,EAAMjpB,GAAMspB,IAAY,EAC3B,GAlD+C,EAqBpD,IAAK,IAAMtpB,KAAQ8oB,EAAO,EAAf9oB,GAiCX,IAAMupB,EAAe3Z,OAAOjG,KAAKuf,GAASze,QAAO,SAACjD,GAAD,OAA8B,IAAtB0hB,EAAQ1hB,GAAGnH,MAAnB,IAmCjD,IAAK,IAAML,KAjCiB,IAAxBupB,EAAalpB,OACbnD,GAAOsF,mBAAmB,uBAAwB,QAASsmB,GACpDS,EAAalpB,OAAS,GAC7BnD,GAAOsF,mBAAP,mDAAuE+mB,EAAapiB,KAAI,SAACmc,GAAD,OAAQ3Q,KAAKyK,UAAUkG,EAAvB,IAA4B1K,KAAK,OAAU,QAASkQ,IAGhJprB,EAAAA,EAAAA,IAAeC,KAAM,cAAe4rB,EAAa,IAGjD,SAASC,EAActa,EAAc8W,GAC7BA,EAAM9W,IACNhS,GAAOsF,mBAAP,qCAAyDmQ,KAAKyK,UAAUlO,IAAU,QAAS4Z,GAG/F9C,EAAM9W,IAAQ,EAEdU,OAAOjG,KAAKsf,EAAM/Z,IAAOnK,SAAQ,SAAC0kB,GACzBP,EAAQO,KAGbD,EAAcC,EAAOzD,GAGrBpW,OAAOjG,KAAKqc,GAAOjhB,SAAQ,SAAC2kB,GACxBP,EAASO,GAASD,IAAS,CAC9B,IACJ,WAEMzD,EAAM9W,EAChB,CACDsa,CAAc7rB,KAAKgsB,YAAa,CAAC,GAGdR,EAAU,CACzB,IAAMS,EAAKha,OAAOjG,KAAKwf,EAASnpB,IAChC4pB,EAAGpgB,OACH7L,KAAKksB,OAAO7pB,GAAQ2oB,GAAW3oB,EAAM8oB,EAAM9oB,IAAS4pB,EAAGziB,KAAI,SAACmc,GAAD,OAAOqF,GAAWrF,EAAGwF,EAAMxF,GAA3B,IAAgC1K,KAAK,GACnG,CACJ,CArGL,yCAuGI,SAAW1J,GACP,IAAI4a,EAAUnsB,KAAKosB,cAAc7a,GAIjC,OAHK4a,IACDA,EAAUnsB,KAAKosB,cAAc7a,GAAQvR,KAAKqsB,YAAY9a,IAEnD4a,CACV,GA7GL,yBA+GI,SAAY5a,GAAY,WAIV4a,EAAU7B,GAAe/Y,GAC/B,GAAI4a,EAAW,OAAOA,EAI1B,IAAM7Y,EAAQ/B,EAAK+B,MAAM,yBACzB,GAAIA,EAAO,CACP,IAAMyY,EAAUzY,EAAM,GAChBgZ,EAAatsB,KAAKusB,WAAWR,GAC7BrpB,EAAS+R,SAASnB,EAAM,IAC9B,OAAO,SAAC5T,GACAgD,GAAU,GAAKhD,EAAMgD,SAAWA,GAChCnD,GAAOsF,mBAAmB,0DAA2D,QAASnF,GAGlG,IAAIyH,EAASzH,EAAM8J,IAAI8iB,GAKvB,OAJI,EAAKJ,OAAOH,KACZ5kB,EAASA,EAAOqC,IAAI0F,EAAAA,KAGjBA,EAAAA,EAAAA,IAAUgO,EAAAA,EAAAA,IAAU/V,GAC9B,CACJ,CAGD,IAAM8jB,EAASjrB,KAAKmrB,MAAM5Z,GAC1B,GAAI0Z,EAAQ,CACR,IAAMuB,EAAcjD,GAAGvpB,KAAKksB,OAAO3a,IACnC,OAAO,SAAC7R,GACJ,IAAMmmB,EAASoF,EAAOzhB,KAAI,YAAmB,IAAhBnH,EAAgB,EAAhBA,KAAMkP,EAAU,EAAVA,KACzBpK,EAAS,EAAKolB,WAAWhb,EAAhB,CAAsB7R,EAAM2C,IAC3C,OAAI,EAAK6pB,OAAO3a,IAAgBrC,EAAAA,EAAAA,GAAU/H,GACnCA,CACV,IAED,OADA0e,EAAOtH,QAAQiO,IACRtP,EAAAA,EAAAA,IAAU2I,EACpB,CACJ,CAED,OAAOtmB,GAAOsF,mBAAP,wBAA4C0M,GAAS,OAAQA,EACvE,GA3JL,wBA6JI,SAAWlP,GACP,IAAM8E,EAASnH,KAAKksB,OAAO7pB,GAI3B,OAHK8E,GACD5H,GAAOsF,mBAAP,wBAA4CmQ,KAAKyK,UAAUpd,IAAU,OAAQA,GAE1E8E,CACV,GAnKL,wBAqKI,SAAWoK,EAAc7R,GACrB,OAAOM,KAAKusB,WAAWhb,EAAhBvR,CAAsBN,EAChC,GAvKL,wBAyKI,SAAW2C,EAAc3C,GACrB,OAAOwP,EAAAA,EAAAA,GAAUlP,KAAKysB,WAAWpqB,EAAM3C,GAC1C,GA3KL,oBA6KI,SAAOA,GACH,OAAOM,KAAKysB,WAAWzsB,KAAKgsB,YAAatsB,EAC5C,GA/KL,kBAiLI,SAAKA,GACD,OAAOM,KAAK0sB,WAAW1sB,KAAKgsB,YAAatsB,EAC5C,GAnLL,oBAqLI,SAAO6R,EAAc7R,EAAYitB,GAA0C,WAInE,GADgBrC,GAAe/Y,GAChB,OAAOob,EAASpb,EAAM7R,GAIzC,IAAM4T,EAAQ/B,EAAK+B,MAAM,yBACzB,GAAIA,EAAO,CACP,IAAMyY,EAAUzY,EAAM,GAChB5Q,EAAS+R,SAASnB,EAAM,IAI9B,OAHI5Q,GAAU,GAAKhD,EAAMgD,SAAWA,GAChCnD,GAAOsF,mBAAmB,0DAA2D,QAASnF,GAE3FA,EAAM8J,KAAI,SAAC5B,GAAD,OAAY,EAAKglB,OAAOb,EAASnkB,EAAG+kB,EAApC,GACpB,CAGD,IAAM1B,EAASjrB,KAAKmrB,MAAM5Z,GAC1B,OAAI0Z,EACOA,EAAO4B,QAAO,SAACC,EAAD,GAA0B,IAAhBzqB,EAAgB,EAAhBA,KAAMkP,EAAU,EAAVA,KAEjC,OADAub,EAAMzqB,GAAQ,EAAKuqB,OAAOrb,EAAM7R,EAAM2C,GAAOsqB,GACtCG,CACV,GAAuB,CAAC,GAGtBvtB,GAAOsF,mBAAP,wBAA4C0M,GAAS,OAAQA,EACvE,GAjNL,mBAmNI,SAAM7R,EAA4BitB,GAC9B,OAAO3sB,KAAK4sB,OAAO5sB,KAAKgsB,YAAatsB,EAAOitB,EAC/C,IArNL,mBAuNI,SAAYxB,GACR,OAAO,IAAID,EAAiBC,EAC/B,GAzNL,4BA2NI,SAAsBA,GAClB,OAAOD,EAAiBvU,KAAKwU,GAAOa,WACvC,GA7NL,wBA+NI,SAAkB3pB,EAAc8oB,EAA8CzrB,GAC1E,OAAOwrB,EAAiBvU,KAAKwU,GAAOuB,WAAWrqB,EAAM3C,EACxD,GAjOL,wBAmOI,SAAkBqtB,GACd,IAAMC,EAAsC,GAC5C,IAAK,IAAM3qB,KAAQ0qB,EAAQ,CACvB,IAAMxb,EAAOyY,GAAiB3nB,GACzBkP,GACDhS,GAAOsF,mBAAP,yCAA6DmQ,KAAKyK,UAAUpd,IAAU,SAAU0qB,GAEpGC,EAAaprB,KAAK,CAAES,KAAAA,EAAMkP,KAAAA,GAC7B,CAMD,OAJAyb,EAAanhB,MAAK,SAACxC,EAAGC,GAClB,OAAO6gB,GAAiB/nB,QAAQiH,EAAEhH,MAAQ8nB,GAAiB/nB,QAAQkH,EAAEjH,KACxE,IAEM6oB,EAAiBwB,WAAW,eAAgB,CAAEO,aAAcD,GAAgBD,EACtF,GAlPL,oBAoPI,SAAcA,EAAyB5B,EAA8CzrB,GACjF,OAAOwd,EAAAA,EAAAA,IAAU,CACb,SACAgO,EAAiBgC,WAAWH,GAC5B7B,EAAiBvU,KAAKwU,GAAO7b,KAAK5P,IAEzC,GA1PL,kBA4PI,SAAYqtB,EAAyB5B,EAA8CzrB,GAC/E,OAAOwP,EAAAA,EAAAA,GAAUgc,EAAiB5lB,OAAOynB,EAAQ5B,EAAOzrB,GAC3D,GA9PL,0BAiQI,SAA0BqtB,EAAyB5B,EAA8CzrB,EAA4BknB,G,0IAEzHmG,GAAS/a,EAAAA,EAAAA,IAAY+a,GAGfI,EAAmC,CAAC,EAGtCJ,EAAO9C,qBAAsBhR,EAAAA,EAAAA,IAAY8T,EAAO9C,kBAAmB,MACnEkD,EAASJ,EAAO9C,mBAAqB,OAInCkC,EAAUjB,EAAiBvU,KAAKwU,IAG9BiC,MAAM1tB,GAAO,SAAC6R,EAAc7R,GAIhC,MAHa,YAAT6R,IAAuB0H,EAAAA,EAAAA,IAAYvZ,EAAO,MAC1CytB,EAASztB,GAAS,MAEfA,CACV,I,oBAGkBytB,G,8CACE,OADV9qB,EAAAA,EAAAA,GAAAA,M,UACgBukB,EAAYvkB,G,QAAnC8qB,EAAS9qB,GAAD,O,8BAIR0qB,EAAO9C,mBAAqBkD,EAASJ,EAAO9C,qBAC5C8C,EAAO9C,kBAAoBkD,EAASJ,EAAO9C,oBAI/CvqB,EAAQysB,EAAQiB,MAAM1tB,GAAO,SAAC6R,EAAc7R,GACxC,MAAa,YAAT6R,GAAsB4b,EAASztB,GAAiBytB,EAASztB,GACtDA,CACV,I,kBAEM,CAAEqtB,OAAAA,EAAQrtB,MAAAA,I,2CACpB,GAzSL,wBA2SI,SAAkBqtB,EAAyB5B,EAA8CzrB,GAErFwrB,EAAiBgC,WAAWH,GAG5B,IAAMM,EAAoC,CAAC,EACrCC,EAAoD,GAE1DnD,GAAiB/iB,SAAQ,SAAC/E,GACtB,IAAM3C,EAAcqtB,EAAQ1qB,GACf,MAAT3C,IACJ2tB,EAAahrB,GAAQgoB,GAAahoB,GAAM3C,GACxC4tB,EAAY1rB,KAAK,CAAES,KAAAA,EAAMkP,KAAMyY,GAAiB3nB,KACnD,IAED,IAAM8pB,EAAUjB,EAAiBvU,KAAKwU,GAEhCoC,GAAkBvb,EAAAA,EAAAA,IAAYmZ,GAUpC,OATIoC,EAAgBN,aAChB1tB,GAAOsF,mBAAmB,2CAA4C,qBAAsBsmB,GAE5FoC,EAAgBN,aAAeK,EAInCnB,EAAQ7mB,OAAO5F,GAER,CACHyrB,MAAOoC,EACPR,OAAQM,EACRrB,YAAaG,EAAQH,YACrB1e,QAAS6e,EAAQiB,MAAM1tB,GAAO,SAAC6R,EAAc7R,GAGzC,GAAI6R,EAAK+B,MAAM,eACX,OAAOlE,EAAAA,EAAAA,KAAQ/J,EAAAA,EAAAA,IAAS3F,IAI5B,GAAI6R,EAAK+B,MAAM,UACX,OAAO1S,EAAAA,GAAAA,KAAelB,GAAOqO,WAGjC,OAAQwD,GACJ,IAAK,UACD,OAAO7R,EAAMiR,cACjB,IAAK,OACD,QAASjR,EACb,IAAK,SAID,MAHsB,kBAAXA,GACPH,GAAOsF,mBAAP,iBAA4C,QAASnF,GAElDA,EAGf,OAAOH,GAAOsF,mBAAmB,mBAAoB,OAAQ0M,EAChE,IAER,KArWL,K,uSClIMhS,GAAS,IAAIC,EAAAA,GAAOuH,IAKpBymB,GAAW,CAAE,OAAQ,eAE3B,SAASC,GAAQ/tB,EAAYguB,GACzB,GAAa,MAAThuB,EAAiB,OAAO,KAG5B,GAA8B,kBAAnBA,EAAM4N,SAAyB5N,EAAM4N,QAAQgG,MAAM,YAAa,CACvE,IAAMpO,GAAO+T,EAAAA,EAAAA,IAAYvZ,EAAMwF,MAAQxF,EAAMwF,KAAM,KACnD,IAAKwoB,GAAexoB,EAChB,MAAO,CAAEoI,QAAS5N,EAAM4N,QAASpI,KAAAA,EAExC,CAGD,GAAsB,kBAAXxF,EAAqB,CAC5B,IAAK,IAAMgR,KAAOhR,EAAO,CACrB,IAAMyH,EAASsmB,GAAQ/tB,EAAMgR,GAAMgd,GACnC,GAAIvmB,EAAU,OAAOA,CACxB,CACD,OAAO,IACV,CAGD,GAAsB,kBAAXzH,EACP,IACI,OAAO+tB,GAAQzY,KAAKC,MAAMvV,GAAQguB,EACnB,CAAjB,MAAOntB,GAAU,CAGvB,OAAO,IACV,CAED,SAASotB,GAAW/d,EAAgBrP,EAAY4kB,GAE5C,IAAM/O,EAAc+O,EAAO/O,aAAe+O,EAAOO,kBAIjD,GAAe,SAAX9V,EAAmB,CACnB,IAAMzI,EAASsmB,GAAQltB,GAAO,GAC9B,GAAI4G,EAAU,OAAOA,EAAOjC,KAG5B3F,GAAOwT,WAAW,sFAAuFvT,EAAAA,GAAAA,OAAAA,eAA8B,CACnI0F,KAAM,KAAMkR,YAAAA,EAAa7V,MAAAA,GAEhC,CAED,GAAe,gBAAXqP,EAA0B,CAE1B,IAAIzI,EAASsmB,GAAQltB,EAAMuP,MAAM,GACnB,MAAV3I,IAAkBA,EAASsmB,GAAQltB,GAAO,IAG1C4G,GACA5H,GAAOwT,WAAW,4EAA6EvT,EAAAA,GAAAA,OAAAA,wBAAuC,CAClIolB,OAAQzd,EAAOmG,QAASsC,OAAAA,EAAQwG,YAAAA,EAAa7V,MAAAA,GAGxD,CAID,IAAI+M,EAAU/M,EAAM+M,QA4CpB,MA3CI/M,EAAMid,OAAShe,EAAAA,GAAAA,OAAAA,cAA8Be,EAAMA,OAAyC,kBAAzBA,EAAMA,MAAM+M,QAC/EA,EAAU/M,EAAMA,MAAM+M,QACQ,kBAAhB/M,EAAMuP,KACpBxC,EAAU/M,EAAMuP,KACsB,kBAAxBvP,EAAMqtB,eACpBtgB,EAAU/M,EAAMqtB,eAEpBtgB,GAAWA,GAAW,IAAIqD,eAGd2C,MAAM,mDACd/T,GAAOwT,WAAW,oDAAqDvT,EAAAA,GAAAA,OAAAA,mBAAkC,CACrGe,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAKnB9I,EAAQgG,MAAM,yBACd/T,GAAOwT,WAAW,8BAA+BvT,EAAAA,GAAAA,OAAAA,cAA6B,CAC1Ee,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAKnB9I,EAAQgG,MAAM,wEACd/T,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,wBAAuC,CAChFe,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAKnB9I,EAAQgG,MAAM,2BACd/T,GAAOwT,WAAW,gDAAiDvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACpGe,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAInBoX,GAASprB,QAAQwN,IAAW,GAAKtC,EAAQgG,MAAM,iFAC/C/T,GAAOwT,WAAW,4EAA6EvT,EAAAA,GAAAA,OAAAA,wBAAuC,CAClIe,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAIjB7V,CACT,CAED,SAASsT,GAAMpB,GACX,OAAO,IAAItB,SAAQ,SAASC,GACxBC,WAAWD,EAASqB,EACvB,GACJ,CAED,SAASob,GAAUC,GACf,GAAIA,EAAQvtB,MAAO,CAEf,IAAMA,EAAa,IAAIqG,MAAMknB,EAAQvtB,MAAM+M,SAG3C,MAFA/M,EAAMid,KAAOsQ,EAAQvtB,MAAMid,KAC3Bjd,EAAM2E,KAAO4oB,EAAQvtB,MAAM2E,KACrB3E,CACT,CAED,OAAOutB,EAAQ3mB,MAClB,CAED,SAAS4mB,GAAaruB,GAClB,OAAIA,EAAgBA,EAAMiR,cACnBjR,CACV,CAED,IAAMsuB,GAAoB,CAAC,EAEdC,GAAb,0CAKI,WAAYC,EAAuB/rB,EAA2BgsB,GAAgC,MAG1F,IAH0F,eAC1F,eAEID,IAAqBF,GACrB,MAAM,IAAIpnB,MAAM,8EAJsE,OAO1F7G,EAAAA,EAAAA,KAAe,UAAM,WAAYoC,GAEX,MAAlBgsB,IAA0BA,EAAiB,GAEhB,kBAApBA,IACPpuB,EAAAA,EAAAA,KAAe,UAAM,WAAY,EAAKoC,SAASkb,UAAUvH,QAAQqY,KACjEpuB,EAAAA,EAAAA,KAAe,UAAM,SAAU,OAEG,kBAApBouB,IACdpuB,EAAAA,EAAAA,KAAe,UAAM,SAAUouB,IAC/BpuB,EAAAA,EAAAA,KAAe,UAAM,WAAY,OAGjCR,GAAOsF,mBAAmB,2BAA4B,iBAAkBspB,GApBc,CAsB7F,CA3BL,sCA6BI,SAAQhsB,GACJ,OAAO5C,GAAOwT,WAAW,0CAA2CvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACrG4e,UAAW,WAElB,GAjCL,8BAmCI,WACI,OAAO,IAAIgQ,GAAuBJ,GAAmBhuB,KAAKmC,SAAUnC,KAAKquB,UAAYruB,KAAKsuB,OAC7F,GArCL,wBAuCI,WAAU,WACN,OAAItuB,KAAKquB,SACEld,QAAQC,QAAQpR,KAAKquB,UAGzBruB,KAAKmC,SAASosB,KAAK,eAAgB,IAAIhZ,MAAK,SAACiZ,GAMhD,OALIA,EAAS9rB,QAAU,EAAK4rB,QACxB/uB,GAAOwT,WAAW,oBAAsB,EAAKub,OAAQ9uB,EAAAA,GAAAA,OAAAA,sBAAqC,CACtF4e,UAAW,eAGZ,EAAKjc,SAASkb,UAAUvH,QAAQ0Y,EAAS,EAAKF,QACxD,GACJ,GApDL,sCAsDI,SAAyBlY,GAA2C,WAChEA,GAAcpE,EAAAA,EAAAA,IAAYoE,GAE1B,IAAMqY,EAAczuB,KAAKkZ,aAAa3D,MAAK,SAACO,GAExC,OADIA,IAAWA,EAAUA,EAAQnF,eAC1BmF,CACV,IAKD,GAA4B,MAAxBM,EAAYQ,SAAkB,CAC9B,IAAM8X,GAAW1c,EAAAA,EAAAA,IAAYoE,GAC7BsY,EAAS/X,KAAO8X,EAChBrY,EAAYQ,SAAW5W,KAAKmC,SAASymB,YAAY8F,EACpD,CAaD,OAXsB,MAAlBtY,EAAYS,KACZT,EAAYS,GAAK1F,QAAQC,QAAQgF,EAAYS,IAAItB,MAAK,SAAOsB,GAAP,OAAawN,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,+EACrD,MAANxN,EAD2D,yCACtC,MADsC,OAE/C,OAF+C,SAEzC7W,KAAKmC,SAASykB,YAAY/P,GAFe,cAGhD,OADTf,EAFyD,SAI3DvW,GAAOsF,mBAAmB,qCAAsC,QAASgS,GAJd,kBAMxDf,GANwD,+CAAb,MAUnD7V,EAAAA,EAAAA,IAAkB,CACrB0d,IAAI1d,EAAAA,EAAAA,IAAkBmW,GACtBoL,OAAQiN,IACTlZ,MAAK,YAAmB,IAAhBoI,EAAgB,EAAhBA,GAAI6D,EAAY,EAAZA,OAEI,MAAX7D,EAAGhH,KACCgH,EAAGhH,KAAKhG,gBAAkB6Q,GAC1BjiB,GAAOsF,mBAAmB,wBAAyB,cAAeuR,GAGtEuH,EAAGhH,KAAO6K,EAGd,IAAMoE,EAAc,EAAKzjB,SAASwsB,YAAaC,mBAAmBjR,EAAI,CAAEhH,MAAM,IAE9E,OAAO,EAAKxU,SAASosB,KAAK,sBAAuB,CAAE3I,IAASrQ,MAAK,SAACjG,GAC9D,OAAOA,CACV,IAAE,SAAC/O,GAQA,MAP8B,kBAAnBA,EAAM+M,SAAyB/M,EAAM+M,QAAQgG,MAAM,iBAC1D/T,GAAOwT,WAAW,4BAA6BvT,EAAAA,GAAAA,OAAAA,gBAA+B,CAC1EqvB,OAAQ,kBACRzY,YAAauH,IAIdgQ,GAAW,kBAAmBptB,EAAOqlB,EAC/C,GACJ,GACJ,GA9GL,6BAgHI,SAAgBxP,GACZ,OAAO7W,GAAOwT,WAAW,sCAAuCvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACjG4e,UAAW,mBAElB,GApHL,6BAsHU,SAAgBhI,G,+IAEE,O,SAAMpW,KAAKmC,SAASmgB,wBAAwB,IAAM,EAAItiB,KAAKmC,SAASogB,iB,OAG3E,OAHP/L,EAAc,EAAdA,K,SAGaxW,KAAK8uB,yBAAyB1Y,G,OAMtC,OANL9G,EAAO,EAAPA,K,kBAMW4F,IAAK,kBAAWmP,GAAAA,OAAAA,OAAAA,GAAAA,EAAAA,EAAAA,KAAAA,MAAAA,SAAAA,IAAA,4EACd,OADc,SACRrkB,KAAKmC,SAASoiB,eAAejV,GADrB,UAEd,QADLqO,EADmB,sDAEChX,GAFD,gCAGlB3G,KAAKmC,SAAS4iB,iBAAiBpH,EAAIrO,EAAMkH,IAHvB,+CAAX,GAIf,CAAEhB,SAAUxV,KAAKmC,W,gFAEd,KAAOiV,gBAAkB9H,E,8DAGtC,GA1IL,yBA4IU,SAAYhC,G,wIAEE,OADVpI,EAA6B,kBAAboI,GAAyBwB,EAAAA,EAAAA,IAAYxB,GAAUA,E,SAC/CtN,KAAKkZ,a,OAIhB,OAJLpD,EAAU,EAAVA,K,kBAIW9V,KAAKmC,SAASosB,KAAK,gBAAiB,EAAEnf,EAAAA,EAAAA,IAAQlK,GAAO4Q,EAAQnF,gB,gFAE5C,kBAAnB,KAAMrD,SAAyB,KAAMA,QAAQgG,MAAM,iBAC1D/T,GAAOwT,WAAW,wBAAyBvT,EAAAA,GAAAA,OAAAA,gBAA+B,CACtEqvB,OAAQ,cACRlY,KAAMb,EACNxI,QAASpI,I,8DAKxB,GA7JL,gCA+JU,SAAmBoI,G,wIAEL,OADVpI,EAA6B,kBAAboI,GAAyBwB,EAAAA,EAAAA,IAAYxB,GAAUA,E,SAC/CtN,KAAKkZ,a,OAIhB,OAJLpD,EAAU,EAAVA,K,kBAIW9V,KAAKmC,SAASosB,KAAK,WAAY,CAAEzY,EAAQnF,eAAevB,EAAAA,EAAAA,IAAQlK,K,gFAE/C,kBAAnB,KAAMoI,SAAyB,KAAMA,QAAQgG,MAAM,iBAC1D/T,GAAOwT,WAAW,wBAAyBvT,EAAAA,GAAAA,OAAAA,gBAA+B,CACtEqvB,OAAQ,qBACRlY,KAAMb,EACNxI,QAASpI,I,8DAKxB,GAhLL,4BAkLU,SAAe6nB,EAAyB5B,EAA8CzrB,G,+IAEtE,O,SAAMqvB,GAAAA,aAA+BhC,EAAQ5B,EAAOzrB,GAAO,SAAC2C,GAC1E,OAAO,EAAKF,SAASykB,YAAYvkB,EACpC,I,OAEe,OAJV2sB,EAAY,EAAZA,K,SAIgBhvB,KAAKkZ,a,OAGhB,OAHLpD,EAAU,EAAVA,K,kBAGW9V,KAAKmC,SAASosB,KAAK,uBAAwB,CACpDzY,EAAQnF,cACRqE,KAAKyK,UAAUsP,GAAAA,WAA6BC,EAAUjC,OAAQ5B,EAAO6D,EAAUtvB,U,gFAGrD,kBAAnB,KAAM4N,SAAyB,KAAMA,QAAQgG,MAAM,iBAC1D/T,GAAOwT,WAAW,wBAAyBvT,EAAAA,GAAAA,OAAAA,gBAA+B,CACtEqvB,OAAQ,iBACRlY,KAAMb,EACNxI,QAAS,CAAEyf,OAAQiC,EAAUjC,OAAQ5B,MAAAA,EAAOzrB,MAAOsvB,EAAUtvB,S,8DAK5E,GAzML,oBA2MU,SAAOkT,G,wIAGO,OAFVzQ,EAAWnC,KAAKmC,S,SAEAnC,KAAKkZ,a,cAArBpD,EAAU,EAAVA,K,kBAEC3T,EAASosB,KAAK,yBAA0B,CAAEzY,EAAQnF,cAAeiC,EAAU,Q,+CACrF,KAjNL,GAAmC4V,IAoN7B4F,GAAAA,SAAAA,I,sIACF,SAAgBhY,GAA2C,WACvD,OAAOpW,KAAK8uB,yBAAyB1Y,GAAab,MAAK,SAACjG,GACpD,MAA4B,CACxBA,KAAMA,EACNwH,MAAO,KACPF,SAAU,KACVxW,SAAU,KACV8E,KAAM,KACNxF,MAAO,KACPwD,QAAS,KACTwT,cAAe,EACfC,KAAM,KACN6O,KAAM,SAAC9O,GAA6B,OAAO,EAAKvU,SAASwiB,mBAAmBrV,EAAMoH,EAAiB,EAE1G,GACJ,K,EAhBC0X,CAA+BH,IAmB/B3F,GAAuD,CACzDplB,SAAS,EAAMgC,MAAM,EAAM0R,UAAU,EAAMxW,UAAS,EAAM0W,OAAO,EAAMD,IAAI,EAAMnX,OAAO,EACxF6R,MAAM,EAAM8E,YAAY,EACxB5V,cAAc,EAAMC,sBAAsB,GAGjCsC,GAAb,0CAiBI,WAAYD,EAA+B1B,GAAoB,sBAC3D,IAAI4tB,EAAgD5tB,EADO,OAIrC,MAAlB4tB,IACAA,EAAiB,IAAI9d,SAAQ,SAACC,EAAS2C,GACnC1C,YAAW,WACP,EAAKqP,gBAAgBnL,MAAK,SAAClU,GACvB+P,EAAQ/P,EACX,IAAE,SAACd,GACAwT,EAAOxT,EACV,GACJ,GAAE,EACN,KAGL,cAAM0uB,GAGDlsB,IAAOA,GAAM+d,EAAAA,EAAAA,IAAwB,EAAK6N,YAAa,aAA1C7N,IAEE,kBAAT/d,GACPhD,EAAAA,EAAAA,KAAe,UAAM,aAAakS,OAAOmZ,OAAO,CAC5CroB,IAAKA,MAGThD,EAAAA,EAAAA,KAAe,UAAM,aAAckS,OAAOmZ,QAAOpZ,EAAAA,EAAAA,IAAYjP,KAGjE,EAAKmsB,QAAU,GA7B4C,CA8B9D,CA/CL,mCAUI,WAII,OAH4B,MAAxBlvB,KAAKmvB,kBACLnvB,KAAKmvB,gBAAkB,CAAC,GAErBnvB,KAAKmvB,eACf,GAfL,2BAqDI,WAAa,WAST,OARKnvB,KAAKovB,OAAL,gBACDpvB,KAAKovB,OAAL,cAA+BpvB,KAAKqvB,yBAGpChe,YAAW,WACP,EAAK+d,OAAL,cAA+B,IAClC,GAAE,IAEApvB,KAAKovB,OAAL,aACV,GA/DL,oCAiEU,W,wIACF,O,SAAMvb,GAAM,G,OAIE,OAFV3Q,EAAU,K,kBAEMlD,KAAKuuB,KAAK,cAAe,I,OAAzCrrB,EAAU,EAAVA,K,uBAGc,O,6CAAMlD,KAAKuuB,KAAK,cAAe,I,QAAzCrrB,EAAU,EAAVA,K,8DAIO,MAAXA,EAAW,C,uBACLyB,GAAamc,EAAAA,EAAAA,IAA4C9gB,KAAK2uB,YAAa,c,4BAEtEhqB,EAAW/D,EAAAA,GAAAA,KAAesC,GAAS6V,a,4DAEnCxZ,GAAOwT,WAAW,2BAA4BvT,EAAAA,GAAAA,OAAAA,cAA6B,CAC9E0D,QAASA,EACTme,MAAO,iBACPzM,YAAa,EAAF,M,iCAKhBrV,GAAOwT,WAAW,2BAA4BvT,EAAAA,GAAAA,OAAAA,cAA6B,CAC9E6hB,MAAO,e,wEAEd,GA7FL,uBA+FI,SAAU8M,GACN,OAAO,IAAIF,GAAcD,GAAmBhuB,KAAMmuB,EACrD,GAjGL,gCAmGI,SAAmBA,GACf,OAAOnuB,KAAKsvB,UAAUnB,GAAgBoB,kBACzC,GArGL,0BAuGI,WAAY,WACR,OAAOvvB,KAAKuuB,KAAK,eAAgB,IAAIhZ,MAAK,SAACiZ,GACvC,OAAOA,EAAShlB,KAAI,SAACH,GAAD,OAAO,EAAKgU,UAAUvH,QAAQzM,EAA9B,GACvB,GACJ,GA3GL,kBA6GI,SAAKuG,EAAgBuV,GAAkB,WAC7BxV,EAAU,CACZC,OAAQA,EACRuV,OAAQA,EACRoE,GAAKvpB,KAAKkvB,UACVM,QAAS,OAGbxvB,KAAK+gB,KAAK,QAAS,CACf8N,OAAQ,UACRlf,SAAS0b,EAAAA,EAAAA,IAAS1b,GAClBxN,SAAUnC,OAKd,IAAMiQ,EAAS,CAAE,cAAe,mBAAoB7N,QAAQwN,IAAW,EACvE,GAAIK,GAASjQ,KAAKovB,OAAOxf,GACrB,OAAO5P,KAAKovB,OAAOxf,GAGvB,IAAMzI,EAASwK,GAAU3R,KAAK4R,WAAYoD,KAAKyK,UAAU9P,GAAUke,IAAWtY,MAAK,SAACpO,GAQhF,OAPA,EAAK4Z,KAAK,QAAS,CACf8N,OAAQ,WACRlf,QAASA,EACTa,SAAUrJ,EACVhF,SAAU,IAGPgF,CAEV,IAAE,SAAC5G,GAQA,MAPA,EAAKwgB,KAAK,QAAS,CACf8N,OAAQ,WACRtuB,MAAOA,EACPoP,QAASA,EACTxN,SAAU,IAGR5B,CACT,IAUD,OAPI0P,IACAjQ,KAAKovB,OAAOxf,GAAUzI,EACtBkK,YAAW,WACP,EAAK+d,OAAOxf,GAAU,IACzB,GAAE,IAGAzI,CACV,GAhKL,4BAkKI,SAAeyI,EAAgBuV,GAC3B,OAAQvV,GACJ,IAAK,iBACD,MAAO,CAAE,kBAAmB,IAEhC,IAAK,cACD,MAAO,CAAE,eAAgB,IAE7B,IAAK,aACD,MAAO,CAAE,iBAAkB,CAAEme,GAAa5I,EAAOrP,SAAUqP,EAAOlP,WAEtE,IAAK,sBACD,MAAO,CAAE,0BAA2B,CAAE8X,GAAa5I,EAAOrP,SAAUqP,EAAOlP,WAE/E,IAAK,UACD,MAAO,CAAE,cAAe,CAAE8X,GAAa5I,EAAOrP,SAAUqP,EAAOlP,WAEnE,IAAK,eACD,MAAO,CAAE,mBAAoB,CAAE8X,GAAa5I,EAAOrP,UAAUyD,EAAAA,EAAAA,IAAW4L,EAAOC,SAAU,IAAKD,EAAOlP,WAEzG,IAAK,kBACD,MAAO,CAAE,yBAA0B,CAAEkP,EAAOO,oBAEhD,IAAK,WACD,OAAIP,EAAOlP,SACA,CAAE,uBAAwB,CAAEkP,EAAOlP,WAAYkP,EAAO2B,sBACtD3B,EAAO5O,UACP,CAAE,qBAAsB,CAAE4O,EAAO5O,YAAa4O,EAAO2B,sBAEzD,KAEX,IAAK,iBACD,MAAO,CAAE,2BAA4B,CAAE3B,EAAO/N,kBAElD,IAAK,wBACD,MAAO,CAAE,4BAA6B,CAAE+N,EAAO/N,kBAEnD,IAAK,OAED,MAAO,CAAE,WAAY,EADM0J,EAAAA,EAAAA,IAAgG9gB,KAAK2uB,YAAa,qBACtHC,CAAmBzJ,EAAO/O,YAAa,CAAEO,MAAM,IAASwO,EAAOlP,WAG1F,IAAK,cAED,MAAO,CAAE,kBAAmB,EADD6K,EAAAA,EAAAA,IAAgG9gB,KAAK2uB,YAAa,qBAC/GC,CAAmBzJ,EAAO/O,YAAa,CAAEO,MAAM,MAGjF,IAAK,UAID,OAHIwO,EAAOrY,QAAmC,MAAzBqY,EAAOrY,OAAOgJ,UAC/BqP,EAAOrY,OAAOgJ,QAAUiY,GAAa5I,EAAOrY,OAAOgJ,UAEhD,CAAE,cAAe,CAAEqP,EAAOrY,SAMzC,OAAO,IACV,GA5NL,qBA8NU,SAAQ8C,EAAgBuV,G,6IAGX,SAAXvV,GAAgC,gBAAXA,EAAW,C,oBAC1B+N,EAAKwH,EAAO/O,cACG,MAAXuH,EAAGpM,OAAgB3Q,EAAAA,GAAAA,KAAe+c,EAAGpM,MAAMsI,SAAxB,C,kBAEF,MAAnB8D,EAAGld,cAAmD,MAA3Bkd,EAAGjd,qBAAwB,C,eACtC,O,SAAMV,KAAKipB,a,OACC,OADtBE,EAAU,EAAVA,MACM1oB,cAAwD,MAAhC0oB,EAAQzoB,wBAExCykB,GAASnT,EAAAA,EAAAA,IAAYmT,IACd/O,aAAcpE,EAAAA,EAAAA,IAAY2L,UAC1BwH,EAAO/O,YAAY7E,M,OAY/B,OAJC,OAFNwW,EAAO/nB,KAAKyvB,eAAe7f,EAASuV,KAGtC5lB,GAAOwT,WAAWnD,EAAS,mBAAoBpQ,EAAAA,GAAAA,OAAAA,gBAA+B,CAAE4e,UAAWxO,I,oBAG9E5P,KAAKuuB,KAAKxG,EAAK,GAAIA,EAAK,I,qGAE9B4F,GAAW/d,EAAD,KAAgBuV,I,0DAExC,GA3PL,yBA6PI,SAAY9D,GACU,YAAdA,EAAM5F,KAAqBzb,KAAK0vB,iBACpC,4DAAkBrO,EACrB,GAhQL,2BAkQI,WACI,GAA2B,MAAvBrhB,KAAK2vB,eAAT,CACA,IAAMC,EAAO5vB,KAEP6vB,EAAiC7vB,KAAKuuB,KAAK,kCAAmC,IACpFvuB,KAAK2vB,eAAiBE,EAEtBA,EAActa,MAAK,SAASua,GAgCxB,OA/BA,SAAS5a,IACL0a,EAAKrB,KAAK,uBAAwB,CAAEuB,IAAYva,MAAK,SAASwa,GAC1D,GAAIH,EAAKD,gBAAkBE,EAAiB,OAAO,KAEnD,IAAIG,EAAM7e,QAAQC,UAYlB,OAXA2e,EAAO3oB,SAAQ,SAASkI,GAEpBsgB,EAAKtP,SAAS,KAAOhR,EAAKqB,eAAiB,UAC3Cqf,EAAMA,EAAIza,MAAK,WACX,OAAOqa,EAAKrL,eAAejV,GAAMiG,MAAK,SAASoI,GAE3C,OADAiS,EAAK7O,KAAK,UAAWpD,GACd,IACV,GACJ,GACJ,IAEMqS,EAAIza,MAAK,WACZ,OAAO1B,GAAM,IAChB,GACJ,IAAE0B,MAAK,WACJ,GAAIqa,EAAKD,gBAAkBE,EAM3B,OAFAxe,YAAW,WAAa6D,GAAS,GAAE,GAE5B,KALH0a,EAAKrB,KAAK,sBAAuB,CAAEuB,GAM1C,IAAExvB,OAAM,SAACC,GAAoB,GACjC,CACD2U,GAEO4a,CACV,IAAExvB,OAAM,SAACC,GAAoB,GAvCc,CAwC/C,GA3SL,wBA6SI,SAAW8gB,GACW,YAAdA,EAAM5F,KAAuD,IAAlCzb,KAAKiwB,cAAc,aAC9CjwB,KAAK2vB,eAAiB,OAE1B,2DAAiBtO,EACpB,IAlTL,yBAiDI,WACI,MAAO,uBACV,GAnDL,gCA6TI,SAA0BjL,EAAiC8Z,GAEvD,IAAMC,GAAUne,EAAAA,EAAAA,IAAYsW,IAC5B,GAAI4H,EACA,IAAK,IAAMxf,KAAOwf,EACVA,EAAWxf,KAAQyf,EAAQzf,IAAO,IAI9C0f,EAAAA,EAAAA,IAAgBha,EAAa+Z,GAE7B,IAAMhpB,EAAiD,CAAC,EAmBxD,MAhBA,CAAC,UAAW,WAAY,WAAY,OAAQ,eAAgB,uBAAwB,QAAS,SAASC,SAAQ,SAASsJ,GACnH,GAA+B,MAArB0F,EAAa1F,GAAvB,CACA,IAAMhR,GAAQ2Z,EAAAA,EAAAA,IAASzY,EAAAA,GAAAA,KAAqBwV,EAAa1F,KAC7C,aAARA,IAAsBA,EAAM,OAChCvJ,EAAOuJ,GAAOhR,CAHkC,CAInD,IAED,CAAC,OAAQ,KAAM,QAAQ0H,SAAQ,SAASsJ,GACL,MAArB0F,EAAa1F,KACvBvJ,EAAOuJ,IAAOtB,EAAAA,EAAAA,IAAcgH,EAAa1F,IAC5C,IAES0F,EAAaC,aACnBlP,EAAM,YAAiB2R,EAAAA,GAAAA,eAAoB1C,EAAaC,aAGrDlP,CACV,KA5VL,GAAqCiZ,ICrYjCiQ,GAAU,KAEd,IAEI,GAAU,OADVA,GAAMC,WACY,MAAM,IAAI1pB,MAAM,gBAQrC,CAPC,MAAOrG,IACL,IAAMhB,GAAS,IAAIC,EAAAA,GAAOuH,IAC1BspB,GAAK,WACD9wB,GAAOwT,WAAW,+CAAgDvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACnG4e,UAAW,mBAElB,CACJ,C,2SCLK7e,GAAS,IAAIC,EAAAA,GAAOuH,IAiBtBwpB,GAAS,EA0BAC,GAAb,0CAaI,WAAYztB,EAA6B1B,GAAoB,wBAGzC,QAAZA,GACA9B,GAAOwT,WAAW,uDAAwDvT,EAAAA,GAAAA,OAAAA,sBAAqC,CAC3G4e,UAAW,iBAKf,EADgB,kBAATrb,EACP,YAAMA,EAAK1B,GAEX,YAAM,aAAcA,IAGnB6f,kBAAoB,EAEzB,EAAKuP,UAAW,EAEI,kBAAT1tB,GACPhD,EAAAA,EAAAA,KAAe,UAAM,aAAc,IAAIuwB,GAAU,EAAK1e,WAAW7O,OAEjEhD,EAAAA,EAAAA,KAAe,UAAM,aAAcgD,IAGvChD,EAAAA,EAAAA,KAAe,UAAM,YAAa,CAAC,IACnCA,EAAAA,EAAAA,KAAe,UAAM,QAAS,CAAC,IAC/BA,EAAAA,EAAAA,KAAe,UAAM,UAAW,CAAC,IACjCA,EAAAA,EAAAA,KAAe,UAAM,kBAAP,yEAGd,EAAK2wB,UAAUC,OAAS,WACpB,EAAKF,UAAW,EAChBxe,OAAOjG,KAAK,EAAK4kB,WAAWxpB,SAAQ,SAACmiB,GACjC,EAAKmH,UAAUnC,KAAK,EAAKqC,UAAUrH,GAAIuE,QAC1C,GACJ,EAED,EAAK4C,UAAUG,UAAY,SAACC,GACxB,IAAM5rB,EAAO4rB,EAAa5rB,KACpBiC,EAAS6N,KAAKC,MAAM/P,GAC1B,GAAiB,MAAbiC,EAAOoiB,GAAY,CACnB,IAAMA,EAAKhkB,OAAO4B,EAAOoiB,IACnB5Z,EAAU,EAAKihB,UAAUrH,GAG/B,UAFO,EAAKqH,UAAUrH,QAEA5iB,IAAlBQ,EAAOA,OACPwI,EAAQgd,SAAS,KAAMxlB,EAAOA,QAE9B,EAAK4Z,KAAK,QAAS,CACf8N,OAAQ,WACRlf,QAASqF,KAAKC,MAAMtF,EAAQme,SAC5Btd,SAAUrJ,EAAOA,OACjBhF,UAAU,gBAGX,CACH,IAAI5B,EAAe,KACf4G,EAAO5G,OACPA,EAAQ,IAAIqG,MAAMO,EAAO5G,MAAM+M,SAAW,kBAC1CvN,EAAAA,EAAAA,IAAoBQ,EAAO,OAAQ4G,EAAO5G,MAAMid,MAAQ,OACxDzd,EAAAA,EAAAA,IAAoBQ,EAAO,WAAY2E,IAEvC3E,EAAQ,IAAIqG,MAAM,iBAGtB+I,EAAQgd,SAASpsB,OAAOoG,GAExB,EAAKoa,KAAK,QAAS,CACf8N,OAAQ,WACRtuB,MAAOA,EACPoP,QAASqF,KAAKC,MAAMtF,EAAQme,SAC5B3rB,UAAU,WAGjB,CAEJ,MAAM,GAAsB,qBAAlBgF,EAAOyI,OAA+B,CAE7C,IAAMmhB,EAAM,EAAKC,MAAM7pB,EAAOge,OAAO8L,cACjCF,GAEAA,EAAIjf,YAAY3K,EAAOge,OAAOhe,OAGrC,MACGwT,QAAQS,KAAK,yBAEpB,EAKD,IAAM8V,EAAW5N,aAAY,WACzB,EAAKvC,KAAK,OACb,GAAE,KA/FsD,OAgGrDmQ,EAASlM,OAASkM,EAASlM,SAhG0B,UAiG5D,CA9GL,sCAkHI,WAAiC,OAAOhlB,KAAKmxB,UAAa,GAlH9D,2BAoHI,WACI,OAAOnxB,KAAKoxB,cACf,GAtHL,2BAwHI,WACI,OAAO,CACV,EA1HL,IAkII,SAAoB1xB,GAChBH,GAAOwT,WAAW,mDAAoDvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACvG4e,UAAW,sBAElB,GAtIL,8BA4HI,SAAiB5H,GACbjX,GAAOwT,WAAW,iDAAkDvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACrG4e,UAAW,mBAElB,GAhIL,kBAwIU,W,yJACK,M,0CACV,GA1IL,mBA4II,SAAY1e,GACHA,GAELH,GAAOwT,WAAW,0CAA2CvT,EAAAA,GAAAA,OAAAA,sBAAqC,CAC9F4e,UAAW,cAElB,GAlJL,kBAoJI,SAAKxO,EAAgBuV,GAAmB,WAC9BkM,EAAMd,KAEZ,OAAO,IAAIpf,SAAQ,SAACC,EAAS2C,GAMzB,IAAM+Z,EAAU9Y,KAAKyK,UAAU,CAC3B7P,OAAQA,EACRuV,OAAQA,EACRoE,GAAI8H,EACJ7B,QAAS,QAGb,EAAKzO,KAAK,QAAS,CACf8N,OAAQ,UACRlf,QAASqF,KAAKC,MAAM6Y,GACpB3rB,SAAU,IAGd,EAAKyuB,UAAUrrB,OAAO8rB,IAAQ,CAAE1E,SAlBhC,SAAkBpsB,EAAc4G,GAC5B,OAAI5G,EAAgBwT,EAAOxT,GACpB6Q,EAAQjK,EAClB,EAeyC2mB,QAAAA,GAEtC,EAAK2C,UAAY,EAAKC,UAAUnC,KAAKT,EAC5C,GACJ,GA9KL,wBAoLU,SAAWrS,EAAa6V,EAAmBxf,G,+IAQ/B,OANM,OADhByf,EAAevxB,KAAKwxB,QAAQ/V,MAE5B8V,EAAepgB,QAAQ4R,IAAIuO,GAAO/b,MAAK,SAAC+b,GACpC,OAAO,EAAK/C,KAAK,gBAAiB+C,EACrC,IACDtxB,KAAKwxB,QAAQ/V,GAAO8V,G,SAEJA,E,OAAdE,EAAQ,EAARA,KACNzxB,KAAKgxB,MAAMS,GAAS,CAAEhW,IAAAA,EAAK3J,YAAAA,G,+CAC9B,GA9LL,yBAgMI,SAAYuP,GAAY,WACpB,OAAQA,EAAM9P,MACV,IAAK,QACDvR,KAAK0xB,WAAW,QAAS,CAAE,aAAc,SAACvqB,GACtC,IAAMqP,EAAc5V,EAAAA,GAAAA,KAAeuG,EAAOgP,QAAQ4C,WAClD,EAAKuH,SAASpgB,MAAQsW,EACtB,EAAKuK,KAAK,QAASvK,EACtB,IACD,MAEJ,IAAK,UACDxW,KAAK0xB,WAAW,UAAW,CAAE,2BAA4B,SAACvqB,GACtD,EAAK4Z,KAAK,UAAW5Z,EACxB,IACD,MAEJ,IAAK,SACDnH,KAAK0xB,WAAWrQ,EAAM5F,IAAK,CAAE,OAAQzb,KAAKinB,WAAW5F,EAAMvU,UAAW,SAAC3F,GAC7C,MAAlBA,EAAOwR,UAAmBxR,EAAOwR,SAAU,GAC/C,EAAKoI,KAAKM,EAAMvU,OAAQ,EAAKuQ,UAAU3E,UAAUvR,GACpD,IACD,MAEJ,IAAK,KACD,IAAMwqB,EAAc,SAACtQ,GACjB,IAAM/R,EAAO+R,EAAM/R,KACnB,EAAKsT,sBAAsBtT,GAAMiG,MAAK,SAACiC,GAC9BA,GACL,EAAKuJ,KAAKzR,EAAMkI,EACnB,GACJ,EAGDma,EAAYtQ,GAMZrhB,KAAK0xB,WAAW,KAAM,CAAE,aAAc,SAACvqB,GACnC,EAAKkZ,QAAQvT,QAAO,SAAC6a,GAAD,MAAmB,OAAXA,EAAEpW,IAAV,IAA0BnK,QAAQuqB,EACzD,IACD,MAIJ,IAAK,QACL,IAAK,OACL,IAAK,WACL,IAAK,UACL,IAAK,QACD,MAEJ,QACIhX,QAAQC,IAAI,aAAcyG,GAGrC,GAzPL,wBA2PI,SAAWA,GAAY,WACf5F,EAAM4F,EAAM5F,IAEhB,GAAmB,OAAf4F,EAAM9P,KAAe,CAErB,GAAIvR,KAAKqgB,QAAQvT,QAAO,SAAC6a,GAAD,MAAmB,OAAXA,EAAEpW,IAAV,IAA0B7O,OAC9C,OAEJ+Y,EAAM,IACT,MAAM,GAAIzb,KAAKiwB,cAAc5O,EAAMA,OAEhC,OAGJ,IAAMoQ,EAAQzxB,KAAKwxB,QAAQ/V,GACtBgW,WAECzxB,KAAKwxB,QAAQ/V,GACpBgW,EAAMlc,MAAK,SAACkc,GACF,EAAKT,MAAMS,YACT,EAAKT,MAAMS,GAClB,EAAKlD,KAAK,kBAAmB,CAAEkD,IAClC,IACJ,GAlRL,qBAoRU,W,8IAEEzxB,KAAK0wB,UAAUkB,aAAetB,GAAAA,WAAoBuB,C,eAClD,O,SAAO,IAAI1gB,SAAQ,SAACC,GAChB,EAAKsf,UAAUC,OAAS,WACpBvf,GAAQ,EACX,EAED,EAAKsf,UAAUoB,QAAU,WACrB1gB,GAAQ,EACX,CACJ,I,OAKLpR,KAAK0wB,UAAUqB,MAAM,K,+CACxB,IArSL,yBAgLI,WACI,MAAO,qBACV,KAlLL,GAAuC/uB,I,uSC9CjCzD,GAAS,IAAIC,EAAAA,GAAOuH,IAkBbirB,GAAb,iJACU,WAAa,W,yPAEA,OADX3wB,EAAUrB,KAAKqB,SACJ,C,eACD,O,SAAM4wB,EAAMvR,cAAanZ,KAAA,M,QAAnClG,EAAU,EAAVA,OAGI9B,GAAOwT,WAAW,sBAAuBvT,EAAAA,GAAAA,OAAAA,cAA6B,CAAC,GAItD,MAAjBQ,KAAKohB,YAELrhB,EAAAA,EAAAA,IAAeC,KAAM,WAAYqB,GAEjCrB,KAAK+gB,KAAK,UAAW1f,EAAS,O,gCAG/BA,G,+CACV,KAnBL,GAA2C2B,IAsBrBkvB,GAAtB,0CAGI,WAAY7wB,EAAsB8wB,GAAY,sBAC1C5yB,GAAOO,cAAP,0CAAiCoyB,GAGjC7wB,GAAUyf,EAAAA,EAAAA,IAAS,0CAA+C,aAAxDA,CAAsEzf,GAChF8wB,GAASrR,EAAAA,EAAAA,IAAS,0CAAyC,YAAlDA,CAA+DqR,GAExE,IAAMvgB,GAAakP,EAAAA,EAAAA,IAAS,0CAAyB,SAAlCA,CAA4Czf,EAAS8wB,GAP9B,OAS1C,cAAMvgB,EAAYvQ,GAEK,kBAAZ8wB,GACPpyB,EAAAA,EAAAA,KAAe,UAAM,SAAUoyB,GACd,MAAVA,GACPlgB,OAAOjG,KAAKmmB,GAAQ/qB,SAAQ,SAACsJ,IACzB3Q,EAAAA,EAAAA,KAAc,UAAiB2Q,EAAKyhB,EAAOzhB,GAC9C,IAhBqC,CAkB7C,CArBL,4CAuBI,WACInR,GAAO6b,KAAK,yDACf,GAzBL,iCA2BI,WACI,OAAO,CACV,GA7BL,uBA+BI,SAAUtF,GACN,OAAOvW,GAAOwT,WACV,wCACAvT,EAAAA,GAAAA,OAAAA,sBACA,CAAE4e,UAAW,aAEpB,GArCL,0BAuCI,WACI,OAAOjN,QAAQC,QAAQ,GAC1B,IAzCL,wBA4CI,SAAiB+gB,GACb,OAAOA,CACV,GA9CL,oBAmDI,SAAc9wB,EAAkB8wB,GAC5B,OAAO5yB,GAAOwT,WAAW,oDAAqDvT,EAAAA,GAAAA,OAAAA,gBAA+B,CACzG4e,UAAW,UAElB,KAvDL,GAAiD4T,ICtC3CzyB,GAAS,IAAIC,EAAAA,GAAOuH,IASpBqrB,GAAgB,mCAETC,GAAb,0CAGI,WAAYhxB,EAAsB8wB,GAAY,sBAC1C,IAAMhwB,EAAW,IAAIJ,GAAgBV,EAAS8wB,GAExCpvB,EAAMZ,EAASyP,WAAW7O,IAAIgX,QAAQ,SAAU,MAClBA,QAAQ,eAAgB,mBAJlB,OAM1C,cAAMhX,EAAKZ,EAASd,UACpBtB,EAAAA,EAAAA,KAAe,UAAM,SAAUoC,EAASgwB,QAPE,CAQ7C,CAXL,kDAaI,WACI,OAAQnyB,KAAKmyB,SAAWC,EAC3B,KAfL,GAA8C5B,IAkBjCzuB,GAAb,uJAwEI,WACI,OAAQ/B,KAAKmyB,SAAWC,EAC3B,IA1EL,mCAEI,SAA4B/wB,EAAsB8wB,GAC9C,OAAO,IAAIE,GAAyBhxB,EAAS8wB,EAChD,GAJL,uBAMI,SAAiBA,GACb,OAAc,MAAVA,EAAyBC,IACzBD,GAA6B,kBAAZA,GACjB5yB,GAAOsF,mBAAmB,iBAAkB,SAAUstB,GAEnDA,EACV,GAZL,oBAcI,SAAc9wB,EAAkB8wB,GAC5B,IAAIG,EAAO,KACX,OAAQjxB,EAAQgB,MACZ,IAAK,YACDiwB,EAAO,gCACP,MACJ,IAAK,UACDA,EAAO,gCACP,MACJ,IAAK,UACDA,EAAO,gCACP,MACJ,IAAK,SACDA,EAAO,+BACP,MACJ,IAAK,QACDA,EAAO,8BACP,MACJ,IAAK,QACDA,EAAO,oCACP,MACJ,IAAK,WACDA,EAAO,mCACP,MACJ,IAAK,WACDA,EAAO,gCACP,MACJ,IAAK,mBACDA,EAAO,gCACP,MACJ,IAAK,kBACDA,EAAO,+BACP,MACJ,IAAK,WACDA,EAAO,gCACP,MACJ,IAAK,iBACDA,EAAO,8BACP,MACJ,IAAK,kBACDA,EAAO,+BACP,MACJ,QACG/yB,GAAOsF,mBAAmB,sBAAuB,UAAW0tB,UAAU,IAG7E,MAAO,CACH7f,WAAW,EACX3P,IAAM,WAAkBuvB,EAAOH,EAC/B9f,iBAAkB,SAAC+B,EAAiBrR,GAIhC,OAHIovB,IAAWC,IACX1X,KAEGvJ,QAAQC,SAAQ,EAC1B,EAER,KAtEL,GAAqC8gB,IC9B/B3yB,GAAS,IAAIC,EAAAA,GAAOuH,IAGpBqrB,GAAgB,mEAEtB,SAASI,GAAQnwB,GACb,OAAQA,GACJ,IAAK,YACD,MAAO,oBACX,IAAK,UACD,MAAO,4BACX,IAAK,UACD,MAAO,4BACX,IAAK,SACD,MAAO,2BAEX,IAAK,QACD,MAAO,wBAEX,IAAK,WACD,MAAO,yBAEf,OAAO9C,GAAOsF,mBAAmB,sBAAuB,OAAQxC,EACnE,CAEM,IAAMG,GAAb,uJAGI,WACI,OAAQxC,KAAKmyB,SAAWC,EAC3B,IALL,wBAOI,SAAiBD,GACb,OAAc,MAAVA,EAAyBC,GACtBD,CACV,GAVL,oBAYI,SAAc9wB,EAAkB8wB,GACd,MAAVA,IAAkBA,EAASC,IAC/B,IAAMxgB,EAA6B,CAC/Bc,WAAW,EACX3P,IAAM,WAAcyvB,GAAQnxB,EAAQgB,MAAQ8vB,EAC5C9f,iBAAkB,SAAC+B,EAAiBrR,GAIhC,OAHIovB,EAAOA,SAAWC,IAClB1X,KAEGvJ,QAAQC,SAAQ,EAC1B,GAQL,OAL4B,MAAxB+gB,EAAOM,gBACP7gB,EAAWe,KAAO,GAClBf,EAAWgB,SAAWuf,EAAOM,eAG1B7gB,CACV,KA/BL,GAAkCsgB,I,uSC5B5B3yB,GAAS,IAAIC,EAAAA,GAAOuH,IAEbzE,GAAb,2IAsBU,SAAQsN,EAAgBuV,GAAW,W,6OAGtB,mBAAXvV,EAAW,C,eACG,O,SAAMqiB,EAAMhQ,QAAO1a,KAAA,KAAC,WAAY,CAAE0O,SAAU,W,cAApD/V,EAAQ,EAARA,K,kBACCA,EAAMiW,Q,gCAGV8b,EAAMhQ,QAAO1a,KAAA,KAACqI,EAAQuV,I,+CAChC,IA/BL,wBAEI,SAAiBgN,GAIb,OAHc,MAAVA,GACA5yB,GAAOsF,mBAAmB,sCAAuC,SAAUstB,GAExE,IACV,GAPL,oBASI,SAAc9wB,EAAkB8wB,GAC5B,IAAIG,EAAO,KACX,GACS,cADDjxB,EAAQgB,KAERiwB,EAAO,mCAGR/yB,GAAOsF,mBAAmB,sBAAuB,UAAW0tB,UAAU,IAG7E,OAAOD,CACV,KApBL,GAAwCJ,I,uSCIlC3yB,GAAS,IAAIC,EAAAA,GAAOuH,IAM1B,SAAS2rB,GAAuBtc,GAC5B,IAAMjP,EAAiC,CAAC,EACxC,IAAK,IAAIuJ,KAAO0F,EACZ,GAA+B,MAArBA,EAAa1F,GAAvB,CACA,IAAIhR,EAAc0W,EAAa1F,GACnB,SAARA,GAA4B,IAAVhR,IAMlBA,EAHM,CAAE6R,MAAM,EAAMqF,UAAU,EAAMxW,UAAU,EAAMuyB,aAAa,EAAMjyB,sBAAsB,EAAMoW,OAAO,EAAMpX,OAAO,GAAQgR,IACvH2I,EAAAA,EAAAA,KAASjK,EAAAA,EAAAA,IAAQ1P,IACV,eAARgR,EACC,KAAMoI,EAAAA,GAAAA,eAAcpZ,GAAO8J,KAAI,SAACyC,GACpC,MAAO,aAAP,OAAqBA,EAAI6J,QAAzB,2BAAqD7J,EAAI2mB,YAAY3X,KAAK,OAA1E,MACH,IAAEA,KAAK,KAAO,KAEP7L,EAAAA,EAAAA,IAAQ1P,GAEpByH,EAAOuJ,GAAOhR,EAdoC,CAgBtD,OAAOyH,CACV,CAED,SAAS0mB,GAAU1mB,GAEf,GAAqB,GAAjBA,EAAO2J,SAAmC,qBAAnB3J,EAAOmG,SAAqD,0BAAnBnG,EAAOmG,SACvE,OAAOnG,EAAOA,OAGlB,GAAqB,GAAjBA,EAAO2J,QAA0C,kBAApB3J,EAAOmG,UAA0BnG,EAAOmG,QAAQgG,MAAM,OAAQ,CAC3F,IAAM/S,EAAa,IAAIqG,MAAM,oBAK7B,MAJArG,EAAM4G,OAAS6N,KAAKyK,UAAUtY,IACzBA,EAAOA,QAAU,IAAIwJ,cAAcvO,QAAQ,eAAiB,IAC7D7B,EAAMsU,eAAgB,GAEpBtU,CACT,CAED,OAAO4G,EAAOA,MACjB,CAED,SAAS0rB,GAAc1rB,GAEnB,GAAIA,GAAkC,GAAlBA,EAAQ2J,QAAwC,SAAnB3J,EAAQmG,UAAuBnG,EAAOA,QAAU,IAAIwJ,cAAcvO,QAAQ,eAAiB,EAAG,CAC3I,IAAM7B,EAAa,IAAIqG,MAAM,sBAG7B,MAFArG,EAAM4G,OAAS6N,KAAKyK,UAAUtY,GAC9B5G,EAAMsU,eAAgB,EAChBtU,CACT,CAED,GAAsB,OAAlB4G,EAAOqoB,QAAkB,CAEzB,IAAMjvB,EAAa,IAAIqG,MAAM,oBAE7B,MADArG,EAAM4G,OAAS6N,KAAKyK,UAAUtY,GACxB5G,CACT,CAED,GAAI4G,EAAO5G,MAAO,CAEd,IAAMA,EAAa,IAAIqG,MAAMO,EAAO5G,MAAM+M,SAAW,iBAGrD,MAFInG,EAAO5G,MAAMid,OAAQjd,EAAMid,KAAOrW,EAAO5G,MAAMid,MAC/CrW,EAAO5G,MAAM2E,OAAQ3E,EAAM2E,KAAOiC,EAAO5G,MAAM2E,MAC7C3E,CACT,CAED,OAAO4G,EAAOA,MACjB,CAGD,SAAS2rB,GAAY7c,GACjB,GAAiB,YAAbA,EAA0B,MAAM,IAAIrP,MAAM,yBAC9C,MAAiB,WAAbqP,EAAgCA,EAE7BxB,SAASwB,EAASpD,UAAU,GAAI,GAC1C,CAGD,SAAS8a,GAAW/d,EAAgBrP,EAAY6V,GAG5C,GAAe,SAAXxG,GAAqBrP,EAAMid,OAAShe,EAAAA,GAAAA,OAAAA,aAA4B,CAChE,IAAMmoB,EAAIpnB,EAAMA,MAGhB,GAAIonB,IAAMA,EAAEra,QAAQgG,MAAM,cAAgBqU,EAAEra,QAAQgG,MAAM,wBAAyB,CAE/E,IAAIpO,EAAOyiB,EAAEziB,KAGb,GAFIA,IAAQA,EAAO,KAAOA,EAAK6U,QAAQ,SAAU,MAE7Cd,EAAAA,EAAAA,IAAY/T,GAAS,OAAOA,EAEhC3F,GAAOwT,WAAW,wCAAyCvT,EAAAA,GAAAA,OAAAA,eAA8B,CACrFe,MAAAA,EAAO2E,KAAM,MAEpB,CACJ,CAGD,IAAIoI,EAAU/M,EAAM+M,QAuCpB,MAtCI/M,EAAMid,OAAShe,EAAAA,GAAAA,OAAAA,eACXe,EAAMA,OAAyC,kBAAzBA,EAAMA,MAAM+M,QAClCA,EAAU/M,EAAMA,MAAM+M,QACQ,kBAAhB/M,EAAMuP,KACpBxC,EAAU/M,EAAMuP,KACsB,kBAAxBvP,EAAMqtB,eACpBtgB,EAAU/M,EAAMqtB,gBAGxBtgB,GAAWA,GAAW,IAAIqD,eAGd2C,MAAM,uBACd/T,GAAOwT,WAAW,oDAAqDvT,EAAAA,GAAAA,OAAAA,mBAAkC,CACtGe,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAKlB9I,EAAQgG,MAAM,8EACd/T,GAAOwT,WAAW,8BAA+BvT,EAAAA,GAAAA,OAAAA,cAA6B,CAC3Ee,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAKlB9I,EAAQgG,MAAM,wCACb/T,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,wBAAuC,CACjFe,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAInB9I,EAAQgG,MAAM,4DACd/T,GAAOwT,WAAW,4EAA6EvT,EAAAA,GAAAA,OAAAA,wBAAuC,CAClIe,MAAAA,EAAOqP,OAAAA,EAAQwG,YAAAA,IAIjB7V,CACT,CAEM,IAAMsB,GAAb,0CAII,WAAYR,EAAsB8wB,GAAe,4BAC7C,cAAM9wB,IAENtB,EAAAA,EAAAA,KAAe,UAAM,UAAW,EAAKgzB,eACrChzB,EAAAA,EAAAA,KAAe,UAAM,SAAUoyB,GAAU,MAJI,CAKhD,CATL,yCAWI,WACI,OAAOnyB,KAAKqB,QAAUrB,KAAKqB,QAAQgB,KAAM,WACrC,IAAK,YACD,MAAO,2BACX,IAAK,UACD,MAAO,mCACX,IAAK,UACD,MAAO,mCACX,IAAK,QACD,MAAO,iCACX,IAAK,SACD,MAAO,kCACX,IAAK,WACD,MAAO,sCACX,IAAK,iBACD,MAAO,4CAIf,OAAO9C,GAAOsF,mBAAmB,sBAAuB,UAAW7E,KAAKqB,QAAQgB,KACnF,GA/BL,oBAiCI,SAAO2wB,EAAgB7N,GACnB,IAAM8N,EAAQhhB,OAAOjG,KAAKmZ,GAAQ0H,QAAO,SAACC,EAAOpc,GAC7C,IAAMhR,EAAQylB,EAAOzU,GAIrB,OAHa,MAAThR,IACAotB,GAAS,IAAJ,OAASpc,EAAT,YAAkBhR,IAEpBotB,CACV,GAAE,IACGqF,EAAWnyB,KAAKmyB,OAAN,kBAA4BnyB,KAAKmyB,QAAW,GAC5D,MAAO,GAAP,OAAWnyB,KAAKkzB,QAAhB,uBAAwCF,GAAxC,OAAmDC,GAAnD,OAA6Dd,EAChE,GA3CL,wBA6CI,WACI,MAAO,GAAP,OAAWnyB,KAAKkzB,QAAhB,OACH,GA/CL,yBAiDI,SAAYF,EAAgB7N,GAGxB,OAFAA,EAAO6N,OAASA,EAChB7N,EAAOgO,OAASnzB,KAAKmyB,OACdhN,CACV,GArDL,mBAuDU,SAAM6N,EAAgB7N,EAA6BiO,G,uJA8BtC,OA7BTrwB,EAAOqwB,EAAOpzB,KAAKqzB,aAAcrzB,KAAKyP,OAAOujB,EAAQ7N,GACrD2I,EAAWsF,EAAOpzB,KAAKszB,YAAYN,EAAQ7N,GAAS,KACpDoO,EAAuB,UAAXP,EAAsBH,GAAehF,GAEvD7tB,KAAK+gB,KAAK,QAAS,CACf8N,OAAQ,UACRlf,QAAS5M,EACTZ,SAAUnC,OAGR4R,EAA6B,CAC/B7O,IAAKA,EACLuP,qBAAsB,IACtBD,iBAAkB,SAAC+B,EAAiBrR,GAIhC,OAHI,EAAKyX,uBACLE,KAEGvJ,QAAQC,SAAQ,EAC1B,GAGDoiB,EAAqB,KACrB1F,IACAlc,EAAW/B,QAAU,CAAE,eAAgB,oDACvC2jB,EAAavhB,OAAOjG,KAAK8hB,GAAStkB,KAAI,SAACkH,GACnC,MAAO,GAAP,OAAWA,EAAX,YAAoBod,EAAQpd,GAC/B,IAAEuK,KAAK,M,SAGStJ,GAAUC,EAAY4hB,EAAYD,GAAYV,I,cAA7D1rB,EAAS,EAATA,KAENnH,KAAK+gB,KAAK,QAAS,CACf8N,OAAQ,WACRlf,QAAS5M,EACTyN,UAAU6a,EAAAA,EAAAA,IAASlkB,GACnBhF,SAAUnC,O,kBAGPmH,G,gDACV,GA/FL,2BAiGU,W,yJACKnH,KAAKqB,S,+CACf,GAnGL,qBAqGU,SAAQuO,EAAgBuV,GAAW,W,+PAE7BvV,E,OACC,mB,KAAA,EAGA,gBAHA,KAGA,EAGA,eAHA,KAGA,EAQA,wBARA,KAQA,EAOA,YAPA,KAOA,EAOA,iBAPA,KAOA,EAQA,oBARA,KAQA,EAQA,aARA,KAQA,GAUA,mBAVA,KAUA,GAMA,0BANA,KAMA,GAMA,SANA,KAMA,GAgBA,gBAhBA,KAgBA,GAYA,YAZA,KAYA,GAmDA,kBAnDA,KAmDA,M,sCAhJM5P,KAAKuQ,MAAM,QAAS,CAAEse,OAAQ,qB,gCAG9B7uB,KAAKuQ,MAAM,QAAS,CAAEse,OAAQ,kB,gCAI9B7uB,KAAKuQ,MAAM,UAAW,CACzBse,OAAQ,UACR/Y,QAASqP,EAAOrP,QAChB2F,IAAK0J,EAAOlP,Y,gCAITjW,KAAKuQ,MAAM,QAAS,CACvBse,OAAQ,0BACR/Y,QAASqP,EAAOrP,QAChB2F,IAAK0J,EAAOlP,Y,gCAITjW,KAAKuQ,MAAM,QAAS,CACvBse,OAAQ,cACR/Y,QAASqP,EAAOrP,QAChB2F,IAAK0J,EAAOlP,Y,gCAITjW,KAAKuQ,MAAM,QAAS,CACvBse,OAAQ,mBACR/Y,QAASqP,EAAOrP,QAChBsP,SAAUD,EAAOC,SACjB3J,IAAK0J,EAAOlP,Y,gCAITjW,KAAKuQ,MAAM,QAAS,CACvBse,OAAQ,yBACR3Y,IAAKiP,EAAOO,oBACb,GAAMplB,OAAM,SAACC,GACZ,OAAOotB,GAAW,kBAAmBptB,EAAO4kB,EAAOO,kBACtD,K,YAGGP,EAAOlP,SAAU,C,yCACVjW,KAAKuQ,MAAM,QAAS,CACvBse,OAAQ,uBACRpT,IAAK0J,EAAOlP,SACZ2C,QAAUuM,EAAO2B,oBAAsB,OAAQ,W,cAGjD,IAAIlgB,MAAM,yC,iCAGT5G,KAAKuQ,MAAM,QAAS,CACvBse,OAAQ,2BACR4E,OAAQtO,EAAO/N,mB,iCAIZpX,KAAKuQ,MAAM,QAAS,CACvBse,OAAQ,4BACR4E,OAAQtO,EAAO/N,mB,WAIK,WAApB+N,EAAOlP,SAAa,C,sBACd,IAAIrP,MAAM,wD,QAQT,OALL8sB,EAAWhB,GAAuBvN,EAAO/O,cACtC4c,OAAS,QAClBU,EAAS7E,OAAS,W,oBAGD7uB,KAAKuQ,MAAM,QAASmjB,GAAU,G,qGAEpC/F,GAAW,OAAD,KAAgBxI,EAAO/O,c,QAUjC,OALLsd,EAAWhB,GAAuBvN,EAAO/O,cACtC4c,OAAS,QAClBU,EAAS7E,OAAS,kB,oBAGD7uB,KAAKuQ,MAAM,QAASmjB,GAAU,G,qGAEpC/F,GAAW,cAAD,KAAuBxI,EAAO/O,c,QAkC1B,OA7BnB2R,EAA4B,CAAE8G,OAAQ,WAExC1J,EAAOrY,OAAO0L,YACduP,EAAKvP,UAAYsa,GAAY3N,EAAOrY,OAAO0L,YAG3C2M,EAAOrY,OAAO2L,UACdsP,EAAKtP,QAAUqa,GAAY3N,EAAOrY,OAAO2L,UAGzC0M,EAAOrY,OAAOgJ,UACdiS,EAAKjS,QAAUqP,EAAOrY,OAAOgJ,SAI7BqP,EAAOrY,OAAOuK,QAAU8N,EAAOrY,OAAOuK,OAAO3U,OAAS,IAClDyiB,EAAOrY,OAAOuK,OAAO3U,OAAS,GAC9BnD,GAAOwT,WAAW,0BAA2BvT,EAAAA,GAAAA,OAAAA,sBAAqC,CAAE6X,OAAQ8N,EAAOrY,OAAOuK,SAG1E,IAAhC8N,EAAOrY,OAAOuK,OAAO3U,SAEE,kBADjBixB,EAASxO,EAAOrY,OAAOuK,OAAO,KACiB,KAAlBsc,EAAOjxB,QACtCnD,GAAOwT,WAAW,2BAA4BvT,EAAAA,GAAAA,OAAAA,sBAAqC,CAAEm0B,OAAQA,IAEjG5L,EAAK4L,OAASA,I,UAIS3zB,KAAKuQ,MAAM,OAAQwX,G,QAA5ClQ,EAAAA,EAAAA,KAGF+b,EAAoC,CAAC,EAGhCzuB,EAAI,E,aAAGA,EAAI0S,EAAKnV,QAAAA,C,mBAEA,OADfkY,EAAM/C,EAAK1S,IACToR,UAAa,C,0DACU,MAA3Bqd,EAAOhZ,EAAIpE,aAAgB,C,gBACb,O,UAAMxW,KAAKG,SAASya,EAAIpE,a,SAAhCtW,EAAQ,EAARA,QAEF0zB,EAAOhZ,EAAIpE,aAAetW,EAAMoP,M,QAGxCsL,EAAIrE,UAAYqd,EAAOhZ,EAAIpE,a,QATErR,I,iDAY1B0S,G,WAImB,cAAtB7X,KAAKqB,QAAQgB,KAAS,C,yCAAsB,G,QAC7B,O,KAAZwxB,W,UAAkB7zB,KAAKuQ,MAAM,QAAS,CAAEse,OAAQ,a,2BAAeiF,O,uGAMvE7B,EAAMhQ,QAAO1a,KAAA,KAACqI,EAAQuV,I,kEAChC,GAlQL,wBAwQU,SAAWF,EAAyCf,EAAuB6P,G,+IAG/D,O,SAAM/zB,KAAK4mB,YAAY3B,G,OAMtB,O,iBALiB,MAAdf,EAAsB,EAAGA,E,KACf,MAAZ6P,EAAoB,SAAUA,EAJxC5O,EAAS,CACX0J,OAAQ,SACR/Y,QAAS,EAATA,GACAke,WAAY,EAAZA,GACAC,SAAU,EAAVA,GACApoB,KAAM,O,SAGW7L,KAAKuQ,MAAM,UAAW4U,G,cAArChe,EAAS,EAATA,K,kBAECA,EAAOqC,KAAI,SAACmU,GACf,CAAC,kBAAmB,MAAMvW,SAAQ,SAASsJ,GACxB,IAAXiN,EAAGjN,WAAqBiN,EAAGjN,EAClC,IACiB,MAAdiN,EAAG3G,SAAyC,MAAtB2G,EAAGlG,kBACzBkG,EAAG3G,QAAU2G,EAAGlG,iBAEpB,IAAMyc,EAAO,EAAK7W,UAAU9E,oBAAoBoF,GAEhD,OADIA,EAAGwW,YAAaD,EAAKjc,UAAYxD,SAASkJ,EAAGwW,YAC1CD,CACV,K,gDACJ,GA9RL,iCAgSI,WACI,OAAuB,MAAfl0B,KAAKmyB,MAChB,KAlSL,GAAuC/R,IC5JjC,SAAUgU,GAASntB,GAGrB,IAAK,IAAI9B,GAFT8B,EAAQA,EAAM6D,SAEKpI,OAAS,EAAGyC,EAAI,EAAGA,IAAK,CACvC,IAAMc,EAAIwC,KAAKQ,MAAMR,KAAKiM,UAAYvP,EAAI,IACpCkvB,EAAMptB,EAAM9B,GAClB8B,EAAM9B,GAAK8B,EAAMhB,GACjBgB,EAAMhB,GAAKouB,CACd,CAED,OAAOptB,CACV,C,2SCEK1H,GAAS,IAAIC,EAAAA,GAAOuH,IAE1B,SAAS0c,KAAQ,OAAQ,IAAInI,MAAQD,SAAY,CAIjD,SAASiZ,GAAc/wB,GAGnB,IAFA,IAAI4D,EAAS,KAEJhC,EAAI,EAAGA,EAAI5B,EAASb,OAAQyC,IAAK,CACtC,IAAM9D,EAAUkC,EAAS4B,GAGzB,GAAe,MAAX9D,EAAmB,OAAO,KAE1B8F,EAEMA,EAAO9E,OAAShB,EAAQgB,MAAQ8E,EAAOjE,UAAY7B,EAAQ6B,UAC3DiE,EAAOhE,aAAe9B,EAAQ8B,YAAqC,MAArBgE,EAAOhE,YAA4C,MAAtB9B,EAAQ8B,aAErF5D,GAAOsF,mBAAmB,oBAAqB,WAAYtB,GAG/D4D,EAAS9F,CAEhB,CAED,OAAO8F,CACV,CAED,SAASotB,GAAO1O,EAAuB2O,GACnC3O,EAASA,EAAO/a,QAAQe,OACxB,IAAM4oB,EAAShsB,KAAKQ,MAAM4c,EAAOnjB,OAAS,GAG1C,GAAImjB,EAAOnjB,OAAS,EAChB,OAAOmjB,EAAO4O,GAIlB,IAAMprB,EAAIwc,EAAO4O,EAAS,GAAInrB,EAAIuc,EAAO4O,GAEzC,OAAgB,MAAZD,GAAoB/rB,KAAK+Z,IAAInZ,EAAIC,GAAKkrB,EAC/B,MAGHnrB,EAAIC,GAAK,CACpB,CAED,SAASorB,GAAUh1B,GACf,GAAc,OAAVA,EACA,MAAO,OACJ,GAAsB,kBAAXA,GAAyC,mBAAXA,EAC5C,OAAOsV,KAAKyK,UAAU/f,GACnB,GAAsB,kBAAXA,EACd,OAAOA,EACJ,GAAIkB,EAAAA,GAAAA,YAAsBlB,GAC7B,OAAOA,EAAMqO,WACV,GAAItG,MAAMC,QAAQhI,GACrB,OAAOsV,KAAKyK,UAAU/f,EAAM8J,KAAI,SAACrE,GAAD,OAAOuvB,GAAUvvB,EAAjB,KAC7B,GAAsB,kBAAXzF,EAAqB,CACnC,IAAMsM,EAAOiG,OAAOjG,KAAKtM,GAEzB,OADAsM,EAAKH,OACE,IAAMG,EAAKxC,KAAI,SAACkH,GACnB,IAAI9I,EAAIlI,EAAMgR,GAMd,OAJI9I,EADc,oBAAPA,EACH,aAEA8sB,GAAU9sB,GAEXoN,KAAKyK,UAAU/O,GAAO,IAAM9I,CACtC,IAAEqT,KAAK,KAAO,GAClB,CAED,MAAM,IAAIrU,MAAM,8BAAgClH,EACnD,CAGD,IAAIi1B,GAAU,EA+Bd,SAASpgB,GAAMrD,GACX,IAAI+C,EAAqB,KAErBJ,EAAsB,KACtBC,EAA0B,IAAI3C,SAAQ,SAACC,GACvC6C,EAAS,WACDJ,IACAK,aAAaL,GACbA,EAAQ,MAEZzC,GACH,EACDyC,EAAQxC,WAAW4C,EAAQ/C,EAC9B,IAWD,MAAO,CAAE+C,OAAAA,EAAQ2gB,WAJjB,WACI,OAAO9gB,CACV,EAE4B0R,KAThB,SAAClkB,GAEV,OADAwS,EAAUA,EAAQyB,KAAKjU,EAE1B,EAOJ,CAED,IAAMuzB,GAAgB,CAClBr1B,EAAAA,GAAAA,OAAAA,eACAA,EAAAA,GAAAA,OAAAA,mBACAA,EAAAA,GAAAA,OAAAA,cACAA,EAAAA,GAAAA,OAAAA,wBACAA,EAAAA,GAAAA,OAAAA,yBAGEs1B,GAAoB,CACtB,UACA,OACA,YACA,iBACA,SACA,eAeJ,SAASC,GAAkBC,EAAuBvR,GAC9C,IAAMtc,EAAc,CAChB8tB,OAAQD,EAAOC,QAYnB,OAVAhjB,OAAOijB,eAAe/tB,EAAQ,WAAY,CAAEyJ,IAAK,kBAAMokB,EAAO7yB,QAAb,IAC7C6yB,EAAO9rB,QAAS/B,EAAO+B,MAAQ8rB,EAAO9rB,OACtCua,IAAOtc,EAAO+J,SAAYuS,EAAMuR,EAAO9rB,OACvC8rB,EAAO3f,OACH2f,EAAOz0B,MACP4G,EAAO5G,MAAQy0B,EAAOz0B,MAEtB4G,EAAOA,OAAS6tB,EAAO7tB,QAAU,MAGlCA,CACV,CA0BD,SAASguB,GAAehzB,EAA4ByN,EAAgBuV,GAEhE,IAAIhX,EAAYumB,GAEhB,OAAQ9kB,GACJ,IAAK,iBAKD,OAAO,SAASwlB,GACZ,IAAMvP,EAASuP,EAAQ5rB,KAAI,SAAC6rB,GAAD,OAAOA,EAAEluB,MAAT,IAGvBqP,EAAc+d,GAAOa,EAAQ5rB,KAAI,SAAC6rB,GAAD,OAAOA,EAAEluB,MAAT,IAAkB,GACvD,GAAmB,MAAfqP,EAYJ,OAVAA,EAAc/N,KAAKqU,KAAKtG,GAGpBqP,EAAOzjB,QAAQoU,EAAc,IAAM,GAAKA,IAGxCA,GAAerU,EAASmzB,sBACxBnzB,EAASmzB,oBAAsB9e,GAG5BrU,EAASmzB,mBACnB,EAEL,IAAK,cAID,OAAO,SAASF,GACZ,IAAMvP,EAASuP,EAAQ5rB,KAAI,SAAC6rB,GAAD,OAAOA,EAAEluB,MAAT,IAE3B,OADA0e,EAAOha,OACAga,EAAOpd,KAAKQ,MAAM4c,EAAOnjB,OAAS,GAC5C,EAEL,IAAK,gBAGD,OAAO,SAAS0yB,GACZ,OAAOb,GAAOa,EAAQ5rB,KAAI,SAAC6rB,GAAD,OAAOA,EAAEluB,MAAT,IAC7B,EAGL,IAAK,aACL,IAAK,sBACL,IAAK,UACL,IAAK,eACL,IAAK,OACL,IAAK,cACL,IAAK,UACD,MAGJ,IAAK,iBACL,IAAK,wBACDgH,EAAY,SAASwP,GACjB,OAAU,MAANA,EAAqB,OAEzBA,GAAK3L,EAAAA,EAAAA,IAAY2L,IACdjH,eAAiB,EACbge,GAAU/W,GACpB,EACD,MAGJ,IAAK,WAGGxP,EADAgX,EAAO2B,oBACK,SAAS5mB,GACjB,OAAa,MAATA,EAAwB,OAE5BA,GAAQ8R,EAAAA,EAAAA,IAAY9R,IACdmY,aAAenY,EAAMmY,aAAa7O,KAAI,SAACmU,GAGzC,OAFAA,GAAK3L,EAAAA,EAAAA,IAAY2L,IACdjH,eAAiB,EACbiH,CACV,IACM+W,GAAUx0B,GACpB,EAEW,SAASA,GACjB,OAAa,MAATA,EAAwB,KACrBw0B,GAAUx0B,EACpB,EAEL,MAEJ,QACI,MAAM,IAAI0G,MAAM,mBAAqBgJ,GAK7C,OA1HJ,SAAyBzB,EAAmCvL,GACxD,OAAO,SAASwyB,GAGZ,IAAMG,EAA4D,CAAC,EACnEH,EAAQhuB,SAAQ,SAACiuB,GACb,IAAM31B,EAAQyO,EAAUknB,EAAEluB,QACrBouB,EAAM71B,KAAU61B,EAAM71B,GAAS,CAAE81B,MAAO,EAAGruB,OAAQkuB,EAAEluB,SAC1DouB,EAAM71B,GAAO81B,OAChB,IAID,IADA,IAAMxpB,EAAOiG,OAAOjG,KAAKupB,GAChBpwB,EAAI,EAAGA,EAAI6G,EAAKtJ,OAAQyC,IAAK,CAClC,IAAMqH,EAAQ+oB,EAAMvpB,EAAK7G,IACzB,GAAIqH,EAAMgpB,OAAS5yB,EACf,OAAO4J,EAAMrF,MAEpB,CAIJ,CACJ,CAmGUsuB,CAAgBtnB,EAAWhM,EAASS,OAE9C,CAID,SAAe8yB,GAAYV,EAAuBxe,G,2IAGjB,OAFvBrU,EAA0B6yB,EAAO7yB,UAEzBqU,aAAuBrU,EAASqU,aAAeA,IAAiC,IAAjBA,GAAiB,C,wCACnFrU,G,gCAGJ+S,IAAK,WACR,OAAO,IAAI/D,SAAQ,SAACC,EAAS2C,GACzB1C,YAAW,WAGP,OAAIlP,EAASqU,aAAeA,EAAsBpF,EAAQjP,GAGtD6yB,EAAOnQ,UAAoBzT,EAAQ,MAGhCA,OAAQzK,EAClB,GAAE,EACN,GACJ,GAAE,CAAE6O,SAAUrT,K,0CAClB,CAED,SAAewzB,GAAUX,EAAuBY,EAA4BhmB,EAAgBuV,G,wIACpFhjB,EAAW6yB,EAAO7yB,S,KAEdyN,E,OACC,mB,MACA,gBADA,OAGA,kBAFA,KAEA,EAKA,eALA,MAMA,wBADA,MAEA,YADA,KADA,EAOA,iBALA,KAKA,GAKA,aALA,KAKA,GAKA,SALA,MAMA,gBADA,QASA,mBARA,MASA,0BADA,QAGA,YAFA,KAEA,M,sCAnCMzN,EAASyN,M,WAENzN,EAAU0zB,cAAe,C,wCAClB1zB,EAAU0zB,iB,8CAMvB1Q,EAAOlP,YAAYgD,EAAAA,EAAAA,IAAYkM,EAAOlP,UAAR,C,gBACnB,O,UAAMyf,GAAYV,EAAQY,G,QAArCzzB,EAAW,EAAXA,K,iCAEGA,EAASyN,GAAQuV,EAAOrP,QAASqP,EAAOlP,UAAY,W,YAEvDkP,EAAOlP,YAAYgD,EAAAA,EAAAA,IAAYkM,EAAOlP,UAAR,C,gBACnB,O,UAAMyf,GAAYV,EAAQY,G,QAArCzzB,EAAW,EAAXA,K,iCAEGA,EAAS2zB,aAAa3Q,EAAOrP,QAASqP,EAAOC,SAAUD,EAAOlP,UAAY,W,YAE7EkP,EAAOlP,YAAYgD,EAAAA,EAAAA,IAAYkM,EAAOlP,UAAR,C,gBACnB,O,UAAMyf,GAAYV,EAAQY,G,QAArCzzB,EAAW,EAAXA,K,iCAEGA,EAAUgjB,EAAO2B,oBAAsB,2BAA4B,YAAa3B,EAAOlP,UAAYkP,EAAO5O,Y,YAG7G4O,EAAOlP,YAAYgD,EAAAA,EAAAA,IAAYkM,EAAOlP,UAAR,C,gBACnB,O,UAAMyf,GAAYV,EAAQY,G,QAArCzzB,EAAW,EAAXA,K,WAEW,SAAXyN,IAAqBuV,EAAOlP,SAAAA,C,yCACrB9T,EAASyN,GAAQuV,EAAO/O,YAAa+O,EAAOlP,W,iCAEhD9T,EAASyN,GAAQuV,EAAO/O,c,iCAGxBjU,EAASyN,GAAQuV,EAAO/N,kB,cAE3BtK,EAASqY,EAAOrY,QACR0L,YAAaS,EAAAA,EAAAA,IAAYnM,EAAO0L,YAAgB1L,EAAO2L,UAAWQ,EAAAA,EAAAA,IAAYnM,EAAO2L,UAAR,C,gBAC1E,O,UAAMid,GAAYV,EAAQY,G,QAArCzzB,EAAW,EAAXA,K,iCAEGA,EAAS2gB,QAAQhW,I,iCAIzBvN,GAAOwT,WAAW,uBAAwBvT,EAAAA,GAAAA,OAAAA,cAA6B,CAC1EoQ,OAAQA,EACRuV,OAAQA,K,2CAEf,CAEM,IAAMxiB,GAAb,0CASI,WAAYpB,EAAqDqB,GAAe,sBACnD,IAArBrB,EAAUmB,QACVnD,GAAOsF,mBAAmB,oBAAqB,YAAatD,GAGhE,IAAMw0B,EAAiDx0B,EAAUiI,KAAI,SAACwsB,EAAkBC,GACpF,GAAIp2B,EAASq2B,WAAWF,GAAmB,CACvC,IAAMG,EAAe3b,GAAoBwb,GAAoB,IAAM,IAEnE,OAAO/jB,OAAOmZ,OAAO,CAAEjpB,SAAU6zB,EAAkBf,OAAQ,EAAGkB,aAAAA,EAAcC,SAD3D,GAEpB,CAED,IAAMpB,GAAiChjB,EAAAA,EAAAA,IAAYgkB,GAE5B,MAAnBhB,EAAOoB,WAAoBpB,EAAOoB,SAAW,GACtB,MAAvBpB,EAAOmB,eACPnB,EAAOmB,aAAe3b,GAAoBwb,GAAoB,IAAM,KAEnD,MAAjBhB,EAAOC,SAAkBD,EAAOC,OAAS,GAE7C,IAAMA,EAASD,EAAOC,OAKtB,OAJIA,EAAS,GAAKA,EAAS,KAAOA,EAAS,IACvC11B,GAAOsF,mBAAmB,8CAA1B,oBAAuFoxB,EAAvF,YAAyGhB,GAGtGhjB,OAAOmZ,OAAO4J,EACxB,IAEK/sB,EAAQ8tB,EAAgBlJ,QAAO,SAACC,EAAOuI,GAAR,OAAevI,EAAQuI,EAAEJ,MAAzB,GAAkC,GAEzD,MAAVryB,EACAA,EAASqF,EAAQ,EACVrF,EAASqF,GAChB1I,GAAOsF,mBAAmB,oDAAqD,SAAUjC,GAI7F,IAAIqsB,EAA6CqF,GAAcyB,EAAgBvsB,KAAI,SAAC6rB,GAAD,OAAcA,EAAElzB,SAAWd,OAA3B,KArCP,OAwCtD,MAAlB4tB,IACAA,EAAiB,IAAI9d,SAAQ,SAACC,EAAS2C,GACnC1C,YAAW,WACP,EAAKqP,gBAAgBnL,KAAKnE,EAAS2C,EACtC,GAAE,EACN,KAGL,cAAMkb,IAGNlvB,EAAAA,EAAAA,KAAe,UAAM,kBAAmBkS,OAAOmZ,OAAO2K,KACtDh2B,EAAAA,EAAAA,KAAe,UAAM,SAAU6C,GAE/B,EAAK0yB,qBAAuB,EAtDgD,CAuD/E,CAhEL,4CAkEU,W,sIACe,O,SAAMnkB,QAAQ4R,IAAI/iB,KAAK+1B,gBAAgBvsB,KAAI,SAAC6rB,GAAD,OAAOA,EAAElzB,SAASwC,YAAlB,K,cAAtDpB,EAAW,EAAXA,K,kBACC+wB,GAAc/wB,I,+CACxB,GArEL,qBAuEU,SAAQqM,EAAgBuV,G,kKAEX,oBAAXvV,EAAW,C,gBAC4B,O,SAAMuB,QAAQ4R,IAAI/iB,KAAK+1B,gBAAgBvsB,KAAI,SAAC6rB,GAC/E,OAAOA,EAAElzB,SAAS6mB,gBAAgB7D,EAAOO,mBAAmBnQ,MAAK,SAACpO,GAC9D,OAAOA,EAAOmI,IACjB,IAAE,SAAC/O,GACA,OAAOA,CACV,GACJ,K,OANK8oB,EAAAA,EAAAA,KASGlkB,EAAI,E,YAAGA,EAAIkkB,EAAQ3mB,QAAAA,C,mBAED,kBADjByE,EAASkiB,EAAQlkB,IACA,C,wCAAmBgC,G,OAFVhC,I,6BAM9BkkB,EAAQ,G,YAKgB,IAA9BrpB,KAAKs1B,qBAAyC,mBAAX1lB,EAAW,C,gBAC9C,O,UAAM5P,KAAK0jB,iB,QAGT5R,EAAcqjB,GAAen1B,KAAM4P,EAAQuV,IAI3CiQ,EAAgChB,GAASp0B,KAAK+1B,gBAAgBvsB,IAAIwI,EAAAA,MAChEnG,MAAK,SAACxC,EAAGC,GAAJ,OAAWD,EAAE+sB,SAAW9sB,EAAE8sB,QAA1B,IAEPR,EAAqB51B,KAAKs1B,oBAE5BnwB,EAAI,EACJkxB,GAAQ,E,uHASR,IAPMC,EAAK7S,KAGP8S,EAAiBnB,EAAQtoB,QAAO,SAACuoB,GAAD,OAAQA,EAAE1S,QAAY2T,EAAKjB,EAAEnsB,MAASmsB,EAAEc,YAAxC,IACPtJ,QAAO,SAACC,EAAOuI,GAAR,OAAevI,EAAQuI,EAAEJ,MAAzB,GAAkC,G,aAIlE,IAAMD,EAASI,EAAQjwB,KAEjBksB,EAAMsD,KAEZK,EAAO9rB,MAAQua,KACfuR,EAAO/jB,QAAUsD,GAAMygB,EAAOmB,cAC9BnB,EAAO/jB,QAAQuU,MAAK,WAAQwP,EAAO/jB,QAAU,IAAO,IAEpD+jB,EAAOrS,OAASgT,GAAUX,EAAQY,EAAoBhmB,EAAQuV,GAAQ5P,MAAK,SAACpO,GACxE6tB,EAAO3f,MAAO,EACd2f,EAAO7tB,OAASA,EAEZ,EAAK8oB,cAAc,UACnB,EAAKlP,KAAK,QAAS,CACf8N,OAAQ,UACRwC,IAAKA,EACLmF,QAASzB,GAAkBC,EAAQvR,MACnC9T,QAAS,CAAEC,OAAQA,EAAQuV,QAAQkG,EAAAA,EAAAA,IAASlG,IAC5ChjB,SAAU,GAIrB,IAAE,SAAC5B,GACAy0B,EAAO3f,MAAO,EACd2f,EAAOz0B,MAAQA,EAEX,EAAK0vB,cAAc,UACnB,EAAKlP,KAAK,QAAS,CACf8N,OAAQ,UACRwC,IAAKA,EACLmF,QAASzB,GAAkBC,EAAQvR,MACnC9T,QAAS,CAAEC,OAAQA,EAAQuV,QAAQkG,EAAAA,EAAAA,IAASlG,IAC5ChjB,SAAU,GAGrB,IAEG,EAAK8tB,cAAc,UACnB,EAAKlP,KAAK,QAAS,CACf8N,OAAQ,UACRwC,IAAKA,EACLmF,QAASzB,GAAkBC,EAAQ,MACnCrlB,QAAS,CAAEC,OAAQA,EAAQuV,QAAQkG,EAAAA,EAAAA,IAASlG,IAC5ChjB,SAAU,IAIlBo0B,GAAkBvB,EAAOC,M,EAhDtBsB,EAAiB,EAAK3zB,QAAUuC,EAAIiwB,EAAQ1yB,QAAQ,I,GAoDrD+zB,EAA+B,GACrCrB,EAAQhuB,SAAQ,SAACiuB,IACTA,EAAEhgB,MAASggB,EAAE1S,SACjB8T,EAAQ70B,KAAKyzB,EAAE1S,QACX0S,EAAEpkB,SAAWwlB,EAAQ70B,KAAKyzB,EAAEpkB,QAAQ2jB,cAC3C,KAEG6B,EAAQ/zB,OAAQ,C,eAAE,O,SAAMyO,QAAQ2D,KAAK2hB,G,aAInCpN,EAAU+L,EAAQtoB,QAAO,SAACuoB,GAAD,OAAQA,EAAEhgB,MAAmB,MAAXggB,EAAE90B,KAApB,KACnBmC,QAAU,EAAKE,QAAAA,C,wBAER+D,KADTQ,EAAS2K,EAAYuX,IACZ1iB,C,uBAEXyuB,EAAQhuB,SAAQ,SAAAiuB,GACRA,EAAEpkB,SAAWokB,EAAEpkB,QAAQgD,SAC3BohB,EAAExQ,WAAY,CACjB,I,qBACM1d,I,WAENkvB,EAAO,C,gBAAE,O,UAAM9hB,GAAM,KAAKqgB,a,QAC/ByB,GAAQ,E,WAINK,EAAStB,EAAQvI,QAAO,SAACC,EAAOuI,GAClC,IAAKA,EAAEhgB,MAAmB,MAAXggB,EAAE90B,MAAiB,OAAOusB,EAEzC,IAAMtP,EAAc6X,EAAE90B,MAAQid,KAM9B,OALIqX,GAAczyB,QAAQob,IAAS,IAC1BsP,EAAMtP,KAASsP,EAAMtP,GAAQ,CAAEjd,MAAO80B,EAAE90B,MAAO00B,OAAQ,IAC5DnI,EAAMtP,GAAMyX,QAAUI,EAAEJ,QAGrBnI,CACV,GAA2D,CAAC,GAE7D7a,OAAOjG,KAAK0qB,GAAQtvB,SAAQ,SAACuvB,GACzB,IAAMpB,EAAQmB,EAAOC,GACrB,KAAIpB,EAAMN,OAAS,EAAKryB,QAAxB,CAGAwyB,EAAQhuB,SAAQ,SAAAiuB,GACRA,EAAEpkB,SAAWokB,EAAEpkB,QAAQgD,SAC3BohB,EAAExQ,WAAY,CACjB,IAED,IAAM8C,EAAU4N,EAAMh1B,MAEhBq2B,EAAmC,CAAC,EAC1C9B,GAAkB1tB,SAAQ,SAAC/E,GACR,MAAXslB,EAAEtlB,KACNu0B,EAAMv0B,GAAQslB,EAAEtlB,GACnB,IAED9C,GAAOwT,WAAW4U,EAAE/C,QAAU+C,EAAEra,QAAcqpB,EAAWC,EAhBd,CAiB9C,IAG6C,IAA1CxB,EAAQtoB,QAAO,SAACuoB,GAAD,OAAQA,EAAEhgB,IAAV,IAAgB3S,OAAW,C,yUAIlD0yB,EAAQhuB,SAAQ,SAAAiuB,GACRA,EAAEpkB,SAAWokB,EAAEpkB,QAAQgD,SAC3BohB,EAAExQ,WAAY,CACjB,I,kBAEMtlB,GAAOwT,WAAW,wBAAyBvT,EAAAA,GAAAA,OAAAA,aAA4B,CAC1EoQ,OAAQA,EACRuV,OAAQA,EAGRkE,QAAS+L,EAAQ5rB,KAAI,SAAC6rB,GAAD,OAAON,GAAkBM,EAAzB,IACrBlzB,SAAUnC,Q,gDAEjB,KAvPL,GAAsCogB,ICnZhCyW,GAAmB,KCSnBt3B,GAAS,IAAIC,EAAAA,GAAOuH,IAKpB+vB,GAAmB,mCAEZC,GAAb,0CAKI,WAAY11B,EAAsB8wB,GAAY,sBAC1C,IAAMhwB,EAAW,IAAIT,GAAeL,EAAS8wB,GACvCvgB,EAAazP,EAASyP,WACxBA,EAAWgB,UACXrT,GAAOwT,WAAW,+CAAgDvT,EAAAA,GAAAA,OAAAA,sBAAqC,CACnG4e,UAAW,0CAInB,IAAMrb,EAAM6O,EAAW7O,IAAIgX,QAAQ,SAAU,MAAMA,QAAQ,OAAQ,WATzB,OAU1C,cAAMhX,EAAK1B,IAEXtB,EAAAA,EAAAA,KAAe,UAAM,SAAUoC,EAAS60B,YACxCj3B,EAAAA,EAAAA,KAAe,UAAM,YAAaoC,EAAS60B,YAC3Cj3B,EAAAA,EAAAA,KAAe,UAAM,gBAAiBoC,EAASswB,eAdL,CAe7C,CApBL,kDAsBI,WACI,OAAQzyB,KAAKg3B,YAAcF,EAC9B,KAxBL,GAA6CtG,IA2BhC9uB,GAAb,uJAoGI,WACI,OAAQ1B,KAAKg3B,YAAcF,EAC9B,IAtGL,mCAII,SAA4Bz1B,EAAsB8wB,GAC9C,OAAO,IAAI4E,GAAwB11B,EAAS8wB,EAC/C,GANL,uBAQI,SAAiBA,GACb,IAAM8E,EAA0E,CAC5E9E,OAAQ2E,GACRE,UAAWF,GACXrE,cAAe,MAGnB,OAAc,MAAVN,IAEmB,kBAAZA,EACP8E,EAAUD,UAAY7E,EAES,MAAxBA,EAAOM,eACdlzB,GAAO6S,eAA6C,kBAAtB+f,EAAO6E,UACjC,qCAAsC,YAAa7E,EAAO6E,WAC9Dz3B,GAAO6S,eAAiD,kBAA1B+f,EAAOM,cACjC,wBAAyB,gBAAiB,cAE9CwE,EAAUD,UAAY7E,EAAO6E,UAC7BC,EAAUxE,cAAgBN,EAAOM,eAE1BN,EAAO6E,YACdC,EAAUD,UAAY7E,EAAO6E,WAGjCC,EAAU9E,OAAS8E,EAAUD,WAlBAC,CAqBhC,GApCL,oBAsCI,SAAc51B,EAAkB8wB,GAC5B,IAAIG,EAAe,KACnB,OAAOjxB,EAAUA,EAAQgB,KAAM,WAC3B,IAAK,YACDiwB,EAAO,oBACP,MACJ,IAAK,UACDA,EAAO,oBACP,MACJ,IAAK,UACDA,EAAO,oBACP,MACJ,IAAK,QACDA,EAAO,kBACP,MACJ,IAAK,SACDA,EAAO,mBACP,MACJ,IAAK,QACDA,EAAO,4BACP,MACJ,IAAK,WACDA,EAAO,2BACP,MACJ,IAAK,WACDA,EAAO,6BACP,MACJ,IAAK,iBACDA,EAAO,2BACP,MACJ,IAAK,WACDA,EAAO,6BACP,MACJ,IAAK,mBACDA,EAAO,6BACP,MACJ,QACI/yB,GAAOwT,WAAW,sBAAuBvT,EAAAA,GAAAA,OAAAA,iBAAgC,CACrEwT,SAAU,UACVtT,MAAO2B,IAInB,IAAMuQ,EAA6B,CAC/Bc,WAAW,EACX3P,IAAM,WAAkBuvB,EAAO,OAASH,EAAO6E,UAC/C3kB,iBAAkB,SAAC+B,EAAiBrR,GAIhC,OAHIovB,EAAO6E,YAAcF,IACrBpc,KAEGvJ,QAAQC,SAAQ,EAC1B,GAQL,OAL4B,MAAxB+gB,EAAOM,gBACP7gB,EAAWe,KAAO,GAClBf,EAAWgB,SAAWuf,EAAOM,eAG1B7gB,CACV,KAlGL,GAAoCsgB,ICrCvBgF,GAAb,wIAQI,SAAKtnB,EAAgBuV,GAAkB,WAC7BxV,EAAU,CACZC,OAAQA,EACRuV,OAAQA,EACRoE,GAAKvpB,KAAKkvB,UACVM,QAAS,OAGa,MAAtBxvB,KAAKm3B,gBACLn3B,KAAKm3B,cAAgB,IAGzB,IAAMC,EAAuB,CAAEznB,QAAAA,EAASyB,QAAS,KAAM2C,OAAQ,MAEzDD,EAAU,IAAI3C,SAAQ,SAACC,EAAS2C,GAClCqjB,EAAgBhmB,QAAUA,EAC1BgmB,EAAgBrjB,OAASA,CAC5B,IA6DD,OA3DA/T,KAAKm3B,cAAcv1B,KAAKw1B,GAEnBp3B,KAAKq3B,0BAENr3B,KAAKq3B,wBAA0BhmB,YAAW,WAItC,IAAMimB,EAAQ,EAAKH,cACnB,EAAKA,cAAgB,KACrB,EAAKE,wBAA0B,KAG/B,IAAM1nB,EAAU2nB,EAAM9tB,KAAI,SAAC+tB,GAAD,OAAcA,EAAS5nB,OAAvB,IAQ1B,OANA,EAAKoR,KAAK,QAAS,CACf8N,OAAQ,eACRlf,SAAS0b,EAAAA,EAAAA,IAAS1b,GAClBxN,SAAU,IAGPwP,GAAU,EAAKC,WAAYoD,KAAKyK,UAAU9P,IAAU4F,MAAK,SAACpO,GAC7D,EAAK4Z,KAAK,QAAS,CACf8N,OAAQ,WACRlf,QAASA,EACTa,SAAUrJ,EACVhF,SAAU,IAKdm1B,EAAMlwB,SAAQ,SAACgwB,EAAiBnB,GAC5B,IAAMnI,EAAU3mB,EAAO8uB,GACvB,GAAInI,EAAQvtB,MAAO,CACf,IAAMA,EAAQ,IAAIqG,MAAMknB,EAAQvtB,MAAM+M,SAChC/M,EAAOid,KAAOsQ,EAAQvtB,MAAMid,KAC5Bjd,EAAO2E,KAAO4oB,EAAQvtB,MAAM2E,KAClCkyB,EAAgBrjB,OAAOxT,EAC1B,MACG62B,EAAgBhmB,QAAQ0c,EAAQ3mB,OAEvC,GAEJ,IAAE,SAAC5G,GACA,EAAKwgB,KAAK,QAAS,CACf8N,OAAQ,WACRtuB,MAAOA,EACPoP,QAASA,EACTxN,SAAU,IAGdm1B,EAAMlwB,SAAQ,SAACgwB,GACXA,EAAgBrjB,OAAOxT,EAC1B,GACJ,GAEJ,GAAE,KAGAuT,CACV,KAvFL,GAA0C9Q,ICCpCzD,GAAS,IAAIC,EAAAA,GAAOuH,IAKbywB,GAAb,kJAEI,SAAiBrF,GAIb,OAHIA,GAA6B,kBAAZA,GACjB5yB,GAAOsF,mBAAmB,iBAAkB,SAAUstB,GAEnDA,GARO,kBASjB,GAPL,oBASI,SAAc9wB,EAAkB8wB,GAC5B5yB,GAAO6b,KAAK,qFAEZ,IAAIkX,EAAO,KACX,OAAQjxB,EAAQgB,MACZ,IAAK,YACDiwB,EAAO,uDACP,MACJ,IAAK,UACDA,EAAO,uDACP,MACJ,IAAK,UACDA,EAAO,uDACP,MACJ,IAAK,SACDA,EAAO,sDACP,MACJ,IAAK,QACDA,EAAO,qDACP,MACJ,QACG/yB,GAAOsF,mBAAmB,sBAAuB,UAAW0tB,UAAU,IAG7E,OAAQD,EAAO,WAAaH,CAC/B,KAlCL,GAAuCD,ICPjC3yB,GAAS,IAAIC,EAAAA,GAAOuH,IAIpB0wB,GAAuB,2BAGhBx1B,GAAb,uJA2EI,WACI,OAAQjC,KAAK03B,gBAAkBD,EAClC,IA7EL,wBAKI,SAAiBtF,GACb,IAAM8E,EAA4F,CAC9FS,cAAe,KACfC,cAAc,EACdC,qBAAsB,MAqB1B,OAjBc,MAAVzF,EACA8E,EAAUS,cAAgBD,GAEC,kBAAZtF,EACf8E,EAAUS,cAAgBvF,EAEY,MAA/BA,EAAOyF,sBACdX,EAAUS,cAAgBvF,EAAOuF,cACjCT,EAAUW,qBAAuBzF,EAAOyF,sBAEjCzF,EAAOuF,cACdT,EAAUS,cAAgBvF,EAAOuF,cAGjCn4B,GAAOsF,mBAAmB,oCAAqC,SAAUstB,GAGtE8E,CACV,GA/BL,oBAiCI,SAAc51B,EAAkB8wB,GAC5B,IAAIG,EAAe,KACnB,OAAQjxB,EAAUA,EAAQgB,KAAO,WAC7B,IAAK,SACDiwB,EAAO,kCACP,MACJ,IAAK,YACDA,EAAO,mCACP,MACJ,IAAK,QACDA,EAAO,iCACP,MACJ,IAAK,QACDA,EAAO,oCACP,MACJ,IAAK,WACDA,EAAO,0CACP,MACJ,IAAK,UACDA,EAAO,mCACP,MACJ,IAAK,UACDA,EAAO,mCACP,MACJ,QACI/yB,GAAOwT,WAAW,sBAAuBvT,EAAAA,GAAAA,OAAAA,iBAAgC,CACrEwT,SAAU,UACVtT,MAAO2B,IAInB,IAEMuQ,EAA6B,CAAE/B,QAAS,CAAC,EAAI9M,IAFvC,WAAH,OAAgBuvB,EAAhB,kBAAgCH,EAAOuF,gBAQhD,OALmC,MAA/BvF,EAAOyF,uBACPhmB,EAAWe,KAAO,GAClBf,EAAWgB,SAAWuf,EAAOyF,sBAG1BhmB,CACV,KAzEL,GAAoCsgB,ICP9B3yB,GAAS,IAAIC,EAAAA,GAAOuH,IAetBmoB,GAAU,EAMd,SAAS2I,GAAuB11B,EAA4B21B,GACxD,IAAMC,EAAU,oBAEhB,OAAO,SAASnoB,EAAgBuV,GAAkB,WACxCxV,EAAU,CACZC,OAAQA,EACRuV,OAAQA,EACRoE,GAAK2F,KACLM,QAAS,OAGb,OAAO,IAAIre,SAAQ,SAACC,EAAS2C,GACzB,EAAKgN,KAAK,QAAS,CACf8N,OAAQ,UACRkJ,QAAAA,EACApoB,SAAS0b,EAAAA,EAAAA,IAAS1b,GAClBxN,SAAU,IAGd21B,EAASnoB,GAAS,SAACpP,EAAOiQ,GAEtB,GAAIjQ,EASA,OARA,EAAKwgB,KAAK,QAAS,CACf8N,OAAQ,WACRkJ,QAAAA,EACAx3B,MAAAA,EACAoP,QAAAA,EACAxN,SAAU,IAGP4R,EAAOxT,GAWlB,GARA,EAAKwgB,KAAK,QAAS,CACf8N,OAAQ,WACRkJ,QAAAA,EACApoB,QAAAA,EACAa,SAAAA,EACArO,SAAU,IAGVqO,EAASjQ,MAAO,CAChB,IAAMA,EAAQ,IAAIqG,MAAM4J,EAASjQ,MAAM+M,SAGvC,OAFM/M,EAAOid,KAAOhN,EAASjQ,MAAMid,KAC7Bjd,EAAO2E,KAAOsL,EAASjQ,MAAM2E,KAC5B6O,EAAOxT,EACjB,CAED6Q,EAAQZ,EAASrJ,OACpB,GACJ,GACJ,CACJ,CAwCM,IAAM6wB,GAAb,0CAII,WAAY71B,EAA+Cd,GAAoB,sBAC3D,MAAZc,GACA5C,GAAOsF,mBAAmB,mBAAoB,WAAY1C,GAG9D,IAAI81B,EAAe,KACfC,EAAqC,KACrCC,EAAgC,KAPuC,MASlD,oBAAdh2B,GACP81B,EAAO,WACPC,EAAmB/1B,MAGnB81B,EAAO91B,EAASmwB,MAAQnwB,EAAS81B,MAAQ,KAC5B91B,EAASi2B,aAClBH,EAAO,YAGXE,EAAch2B,EAEVA,EAASwN,SACI,KAATsoB,IAAeA,EAAO,aAC1BC,EAjEhB,SAA6B/1B,GACzB,OAAO,SAASyN,EAAgBuV,GAAkB,WAChC,MAAVA,IAAkBA,EAAS,IAE/B,IAAMxV,EAAU,CAAEC,OAAAA,EAAQuV,OAAAA,GAS1B,OAPAnlB,KAAK+gB,KAAK,QAAS,CACf8N,OAAQ,UACRkJ,QAAS,iBACTpoB,SAAS0b,EAAAA,EAAAA,IAAS1b,GAClBxN,SAAUnC,OAGPmC,EAASwN,QAAQA,GAAS4F,MAAK,SAAC/E,GASnC,OARA,EAAKuQ,KAAK,QAAS,CACf8N,OAAQ,WACRkJ,QAAS,iBACTpoB,QAAAA,EACAa,SAAAA,EACArO,SAAU,IAGPqO,CAEV,IAAE,SAACjQ,GASA,MARA,EAAKwgB,KAAK,QAAS,CACf8N,OAAQ,WACRkJ,QAAS,iBACTpoB,QAAAA,EACApP,MAAAA,EACA4B,SAAU,IAGR5B,CACT,GACJ,CACJ,CA6BkC83B,CAAoBl2B,IAChCA,EAASm2B,UAChBJ,EAAmBL,GAAuB11B,EAAUA,EAASm2B,UAAUviB,KAAK5T,IACrEA,EAASosB,KAChB2J,EAAmBL,GAAuB11B,EAAUA,EAASosB,KAAKxY,KAAK5T,IAEvE5C,GAAOsF,mBAAmB,uBAAwB,WAAY1C,GAG7D81B,IAAQA,EAAO,aAGxB,cAAMA,EAAM52B,IAEZtB,EAAAA,EAAAA,KAAe,UAAM,mBAAoBm4B,IACzCn4B,EAAAA,EAAAA,KAAe,UAAM,WAAYo4B,GAtC0C,CAuC9E,CA3CL,mCA6CI,SAAKvoB,EAAgBuV,GACjB,OAAOnlB,KAAKk4B,iBAAiBtoB,EAAQuV,EACxC,KA/CL,GAAkCniB,IC/E5BzD,GAAS,IAAIC,EAAAA,GAAOuH,IAK1B,SAASwxB,GAAmBl3B,EAAsBG,GAI9C,GAHe,MAAXH,IAAmBA,EAAU,aAGT,kBAAbA,EAAuB,CAI9B,IAAMiS,EAAQjS,EAAQiS,MAAM,kBAC5B,GAAIA,EACA,OAAQA,EAAM,GAAG3C,eACb,IAAK,OAAQ,IAAK,QACd,OAAO,IAAI3N,GAAgB3B,GAC/B,IAAK,KAAM,IAAK,MACZ,OAAO,IAAImvB,GAAkBnvB,GACjC,QACI9B,GAAOsF,mBAAmB,yBAA0B,UAAWxD,GAG9E,CAED,IAAMwI,EAAIlF,EAAWtD,GAQrB,OAPKwI,GAAMA,EAAEzG,kBACT7D,GAAOwT,WAAW,yCAA0CvT,EAAAA,GAAAA,OAAAA,cAA6B,CACrF4e,UAAW,qBACX/c,QAASA,IAIVwI,EAAEzG,iBAAiB,CACtBT,iBAAAA,GAEAZ,gBAAAA,GACAS,aAAAA,GACAF,mBAAAA,GACAT,kBAAAA,GACAH,eAAAA,GACAsB,gBAAAA,GACAw0B,kBAAAA,GACAv1B,eAAAA,GACA+1B,aAAAA,GAEAnB,YAAAA,IACDr1B,EACN,C","sources":["../node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/decoder.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/lib.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/include.ts","../node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/@ethersproject/providers/src.ts/ankr-provider.ts","../node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/web3-provider.ts","../node_modules/@ethersproject/providers/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    lastBaseFeePerGas: null | BigNumber;\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            lastBaseFeePerGas = block.baseFeePerGas;\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","export const version = \"abstract-provider/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\" ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [ \"ropsten\" ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"networks/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","export const version = \"hash/5.7.0\";\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nexport type Numbers = Uint8Array | Array<number>;\nexport type NextFunc = (...args: Array<any>) => number;\n\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array: Array<any>, depth?: number): Array<any> {\n    if (depth == null) { depth = 1; }\n    const result: Array<any> = [];\n\n    const forEach = result.forEach;\n\n    const flatDeep = function (arr: Array<any>, depth: number) {\n        forEach.call(arr, function (val: any) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            } else {\n               result.push(val);\n            }\n        });\n    };\n\n    flatDeep(array, depth);\n    return result;\n}\n\nfunction fromEntries<T extends string | number | symbol = string | number | symbol, U = any>(array: Array<[T, U]>): Record<T, U> {\n    const result: Record<T, U> = <Record<T, U>>{ };\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\n\nexport function decode_arithmetic(bytes: Numbers): Array<number> {\n\tlet pos = 0;\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n\t\n\t// decode the frequency table\n\tlet symbol_count = u16();\n\tlet total = 1;\n\tlet acc = [0, 1]; // first symbol has frequency 1\n\tfor (let i = 1; i < symbol_count; i++) {\n\t\tacc.push(total += u16());\n\t}\n\n\t// skip the sized-payload that the last 3 symbols index into\n\tlet skip = u16();\n\tlet pos_payload = pos;\n\tpos += skip;\n\n\tlet read_width = 0;\n\tlet read_buffer = 0; \n\tfunction read_bit() {\n\t\tif (read_width == 0) {\n\t\t\t// this will read beyond end of buffer\n\t\t\t// but (undefined|0) => zero pad\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\n\t\t\tread_width = 8;\n\t\t}\n\t\treturn (read_buffer >> --read_width) & 1;\n\t}\n\n\tconst N = 31;\n\tconst FULL = 2**N;\n\tconst HALF = FULL >>> 1;\n\tconst QRTR = HALF >> 1;\n\tconst MASK = FULL - 1;\n\n\t// fill register\n\tlet register = 0;\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\n\n\tlet symbols = [];\n\tlet low = 0;\n\tlet range = FULL; // treat like a float\n\twhile (true) {\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\n\t\tlet start = 0;\n\t\tlet end = symbol_count;\n\t\twhile (end - start > 1) { // binary search\n\t\t\tlet mid = (start + end) >>> 1;\n\t\t\tif (value < acc[mid]) {\n\t\t\t\tend = mid;\n\t\t\t} else {\n\t\t\t\tstart = mid;\n\t\t\t}\n\t\t}\n\t\tif (start == 0) break; // first symbol is end mark\n\t\tsymbols.push(start);\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1\n\t\twhile (((a ^ b) & HALF) == 0) {\n\t\t\tregister = (register << 1) & MASK | read_bit();\n\t\t\ta = (a << 1) & MASK;\n\t\t\tb = (b << 1) & MASK | 1;\n\t\t}\n\t\twhile (a & ~b & QRTR) {\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n\t\t\ta = (a << 1) ^ HALF;\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\n\t\t}\n\t\tlow = a;\n\t\trange = 1 + b - a;\n\t}\n\tlet offset = symbol_count - 4;\n\treturn symbols.map(x => { // index into payload\n\t\tswitch (x - offset) {\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 1: return offset + bytes[pos_payload++];\n\t\t\tdefault: return x - 1;\n\t\t}\n\t});\n}\t\n\n\n// returns an iterator which returns the next symbol\nexport function read_payload(v: Numbers): NextFunc {\n\tlet pos = 0;\n\treturn () => v[pos++];\n}\nexport function read_compressed_payload(bytes: Numbers): NextFunc {\n\treturn read_payload(decode_arithmetic(bytes));\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nexport function signed(i: number): number { \n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\n}\n\nfunction read_counts(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0; i < n; i++) v[i] = 1 + next();\n\treturn v;\n}\n\nfunction read_ascending(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = -1; i < n; i++) v[i] = x += 1 + next();\n\treturn v;\n}\n\nfunction read_deltas(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n\treturn v;\n}\n\nexport function read_member_array(next: NextFunc, lookup?: Record<number, number>) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nexport function read_mapped_map(next: NextFunc): Record<number, Array<number>> {\n\tlet ret = [];\n\twhile (true) {\n\t\tlet w = next();\n\t\tif (w == 0) break;\n\t\tret.push(read_linear_table(w, next));\n\t}\n\twhile (true) {\n\t\tlet w = next() - 1;\n\t\tif (w < 0) break;\n\t\tret.push(read_replacement_table(w, next));\n\t}\n\treturn fromEntries<number, Array<number>>(flat(ret));\n}\n\nexport function read_zero_terminated_array(next: NextFunc): Array<number> {\n\tlet v = [];\n\twhile (true) {\n\t\tlet i = next();\n\t\tif (i == 0) break;\n\t\tv.push(i);\n\t}\n\treturn v;\n}\n\nfunction read_transposed(n: number, w: number, next: NextFunc): Array<Array<number>> {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\n\n\nfunction read_linear_table(w: number, next: NextFunc): Array<Array<number | Array<number>>> {\n\tlet dx = 1 + next();\n\tlet dy = next();\n\tlet vN = read_zero_terminated_array(next);\n\tlet m = read_transposed(vN.length, 1+w, next);\n\treturn flat(m.map((v, i) => {\n\t  const x = v[0], ys = v.slice(1);\n\t\t//let [x, ...ys] = v;\n\t\t//return Array(vN[i]).fill().map((_, j) => {\n\t\treturn Array(vN[i]).fill(undefined).map((_, j) => {\n\t\t\tlet j_dy = j * dy;\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\n\t\t});\n\t}));\n}\n\nfunction read_replacement_table(w: number, next: NextFunc): Array<[ number, Array<number> ]> {\n\tlet n = 1 + next();\n\tlet m = read_transposed(n, 1+w, next);\n\treturn m.map(v => [v[0], v.slice(1)]);\n}\n\nexport type Branch = {\n    set: Set<number>;\n    node: Node;\n};\n\nexport type Node = {\n    branches: Array<Branch>;\n    valid: number;\n    fe0f: boolean;\n    save: boolean;\n    check: boolean;\n};\n\nexport function read_emoji_trie(next: NextFunc): Node {\n\tlet sorted = read_member_array(next).sort((a, b) => a - b);\n\treturn read();\n\tfunction read(): Node {\n\t\tlet branches = [];\n\t\twhile (true) {\n\t\t\tlet keys = read_member_array(next, sorted);\n\t\t\tif (keys.length == 0) break;\n\t\t\tbranches.push({set: new Set(keys), node: read()});\n\t\t}\n    branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n \t\tlet temp = next();\n \t\tlet valid = temp % 3;\n \t\ttemp = (temp / 3)|0;\n \t\tlet fe0f = !!(temp & 1);\n \t\ttemp >>= 1;\n \t\tlet save = temp == 1;\n \t\tlet check = temp == 2;\n \t\treturn {branches, valid, fe0f, save, check};\n\t}\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { toUtf8CodePoints } from \"@ethersproject/strings\";\n\nimport { getData } from './include.js';\nconst r = getData();\n\nimport {read_member_array, read_mapped_map, read_emoji_trie} from './decoder.js';\n\n// @TODO: This should be lazily loaded\n\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\n\nfunction explode_cp(name: string): Array<number> {\n    return toUtf8CodePoints(name);\n}\n\nfunction filter_fe0f(cps: Array<number>): Array<number> {\n    return cps.filter(cp => cp != 0xFE0F);\n}\n\nexport function ens_normalize_post_check(name: string): string {\n\tfor (let label of name.split('.')) {\n\t\tlet cps = explode_cp(label);\n\t\ttry {\n\t\t\tfor (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n\t\t\t\tif (cps[i] !== UNDERSCORE) {\n\t\t\t\t\tthrow new Error(`underscore only allowed at start`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n\t\t\t\tthrow new Error(`invalid label extension`);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow new Error(`Invalid label \"${label}\": ${err.message}`);\n\t\t}\n\t}\n\treturn name;\n}\n\nexport function ens_normalize(name: string): string {\n\treturn ens_normalize_post_check(normalize(name, filter_fe0f));\n}\n\nfunction normalize(name: string, emoji_filter: (a: Array<number>) => Array<number>): string {\n\tlet input = explode_cp(name).reverse(); // flip for pop\n\tlet output = [];\n\twhile (input.length) {\t\t\n\t\tlet emoji = consume_emoji_reversed(input);\n\t\tif (emoji) {\n\t\t\toutput.push(...emoji_filter(emoji));\n\t\t\tcontinue;\n\t\t}\n\t\tlet cp = input.pop();\n\t\tif (VALID.has(cp)) {\n\t\t\toutput.push(cp);\n\t\t\tcontinue;\n\t\t} \n\t\tif (IGNORED.has(cp)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet cps = MAPPED[cp];\n\t\tif (cps) {\n\t\t\toutput.push(...cps);\n\t\t\tcontinue;\n\t\t}\n\t\tthrow new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n\t}\n\treturn ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\n\nfunction nfc(s: string): string {\n    return s.normalize('NFC');\n}\n\nfunction consume_emoji_reversed(cps: Array<number>, eaten?: Array<number>) {\n\tlet node = EMOJI_ROOT;\n\tlet emoji;\n\tlet saved;\n\tlet stack = [];\n\tlet pos = cps.length;\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\n\twhile (pos) {\n\t\tlet cp = cps[--pos];\n\t\tnode = node.branches.find(x => x.set.has(cp))?.node;\n\t\tif (!node) break;\n\t\tif (node.save) { // remember\n\t\t\tsaved = cp;\n\t\t} else if (node.check) { // check exclusion\n\t\t\tif (cp === saved) break;\n\t\t}\n\t\tstack.push(cp);\n\t\tif (node.fe0f) {\n\t\t\tstack.push(0xFE0F);\n\t\t\tif (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F\n\t\t}\n\t\tif (node.valid) { // this is a valid emoji (so far)\n\t\t\temoji = stack.slice(); // copy stack\n\t\t\tif (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n\t\t\tcps.length = pos; // truncate\n\t\t}\n\t}\n\treturn emoji;\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { decode } from \"@ethersproject/base64\";\n\nimport {read_compressed_payload} from './decoder.js';\n\nexport function getData(): () => number {\n    return read_compressed_payload(decode('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'));\n}\n\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { ens_normalize } from \"./ens-normalize/lib\";\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nfunction checkComponent(comp: Uint8Array): Uint8Array {\n    if (comp.length === 0) { throw new Error(\"invalid ENS name; empty component\"); }\n    return comp;\n}\n\nfunction ensNameSplit(name: string): Array<Uint8Array> {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps: Array<Uint8Array> = [ ];\n\n    if (name.length === 0) { return comps; }\n\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) { throw new Error(\"invalid ENS name; empty component\"); }\n\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n\nexport function ensNormalize(name: string): string {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\n\nexport function isValidName(name: string): boolean {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n\n    }))) + \"00\";\n}\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.7.0\";\n","export const version = \"web/5.7.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    if (options.fetchOptions != null) {\n        const opts = options.fetchOptions;\n        if (opts.mode) { request.mode = <RequestMode>(opts.mode); }\n        if (opts.cache) { request.cache = <RequestCache>(opts.cache); }\n        if (opts.credentials) { request.credentials = <RequestCredentials>(opts.credentials); }\n        if (opts.redirect) { request.redirect = <RequestRedirect>(opts.redirect); }\n        if (opts.referrer) { request.referrer = opts.referrer; }\n    }\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    fetchOptions?: Record<string, string>;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"providers/5.7.0\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: Formatter.allowNull(address),\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\": case \"pending\": case \"safe\": case \"finalized\":\n                return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\nconst MAX_CCIP_REDIRECTS = 10;\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    _lastBlockNumber: number\n    _inflight: boolean;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = arrayify(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>) {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return hexConcat(result);\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    _supportsEip2544: null | Promise<boolean>;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    supportsWildcard(): Promise<boolean> {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return false; }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n\n        return this._supportsEip2544;\n    }\n\n    async _fetch(selector: string, parameters?: string): Promise<null | string> {\n\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            ccipReadEnabled: true,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        // Wildcard support; use EIP-2544 to resolve the request\n        let parseBytes = false;\n        if (await this.supportsWildcard()) {\n            parseBytes = true;\n\n            // selector(\"resolve(bytes,bytes)\")\n            tx.data = hexConcat([ \"0x9061b923\", encodeBytes([ dnsEncode(this.name), tx.data ]) ]);\n        }\n\n        try {\n            let result = await this.provider.call(tx);\n            if ((arrayify(result).length % 32) === 4) {\n                logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                    transaction: tx, data: result\n                });\n            }\n            if (parseBytes) { result = _parseBytes(result, 0); }\n            return result;\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        const result = await this._fetch(selector, parameters);\n        if (result != null) { return _parseBytes(result, 0); }\n        return null;\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const result = await this._fetch(\"0x3b3b57de\");\n\n                // No address\n                if (result === \"0x\" || result === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(result);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx), 0);\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // IPNS (CID: 1, Type: libp2p-key)\n        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipns) {\n            const length = parseInt(ipns[3], 16);\n            if (ipns[4].length === length * 2) {\n                return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n        if (skynet) {\n            if (skynet[1].length === (34 * 2)) {\n                // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                const urlSafe: Record<string, string> = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                return \"sia:/\\/\" + hash;\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n    _maxFilterBlockRange: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n    disableCcipRead: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.disableCcipRead = false;\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    async ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                value.status = response.statusCode;\n                return value;\n            });\n\n            if (result.data) { return result.data; }\n\n            const errorMessage = (result.message || \"unknown error\");\n\n            // 4xx indicates the result is not present; stop\n            if (result.status >= 400 && result.status < 500) {\n                return logger.throwError(`response not found during CCIP fetch: ${ errorMessage }`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n            }\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        return logger.throwError(`error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, Logger.errors.SERVER_ERROR, {\n            urls, errorMessages\n        });\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    // We only allow a single getLogs to be in-flight at a time\n                    if (!event._inflight) {\n                        event._inflight = true;\n\n                        // This is the first filter for this event, so we want to\n                        // restrict events to events that happened no earlier than now\n                        if (event._lastBlockNumber === -2) {\n                            event._lastBlockNumber = blockNumber - 1;\n                        }\n\n                        // Filter from the last *known* event; due to load-balancing\n                        // and some nodes returning updated block numbers before\n                        // indexing events, a logs result with 0 entries cannot be\n                        // trusted and we must retry a range which includes it again\n                        const filter = event.filter;\n                        filter.fromBlock = event._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n\n                        // Prevent fitler ranges from growing too wild, since it is quite\n                        // likely there just haven't been any events to move the lastBlockNumber.\n                        const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                        if (minFromBlock > filter.fromBlock) { filter.fromBlock = minFromBlock; }\n\n                        if (filter.fromBlock < 0) { filter.fromBlock = 0; }\n\n                        const runner = this.getLogs(filter).then((logs) => {\n                            // Allow the next getLogs\n                            event._inflight = false;\n\n                            if (logs.length === 0) { return; }\n\n                            logs.forEach((log: Log) => {\n                                // Only when we get an event for a given block number\n                                // can we trust the events are indexed\n                                if (log.blockNumber > event._lastBlockNumber) {\n                                    event._lastBlockNumber = log.blockNumber;\n                                }\n\n                                // Make sure we stall requests to fetch blocks and txs\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\n                                this.emit(filter, log);\n                            });\n                        }).catch((error: Error) => {\n                            this.emit(\"error\", error);\n\n                            // Allow another getLogs (the range was not updated)\n                            event._inflight = false;\n                        });\n                        runners.push(runner);\n                    }\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string> {\n        if (attempt >= MAX_CCIP_REDIRECTS) {\n            logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                redirects: attempt, transaction\n            });\n        }\n\n        const txSender = transaction.to;\n\n        const result = await this.perform(\"call\", { transaction, blockTag });\n\n        // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n        if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n            try {\n                const data = hexDataSlice(result, 4);\n\n                // Check the sender of the OffchainLookup matches the transaction\n                const sender = hexDataSlice(data, 0, 32);\n                if (!BigNumber.from(sender).eq(txSender)) {\n                    logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                // Read the URLs from the response\n                const urls: Array<string> = [];\n                const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                const urlsData = hexDataSlice(data, urlsOffset + 32);\n                for (let u = 0; u < urlsLength; u++) {\n                    const url = _parseString(urlsData, u * 32);\n                    if (url == null) {\n                        logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    urls.push(url);\n                }\n\n                // Get the CCIP calldata to forward\n                const calldata = _parseBytes(data, 64);\n\n                // Get the callbackSelector (bytes4)\n                if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                    logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n                const callbackSelector = hexDataSlice(data, 96, 100);\n\n                // Get the extra data to send back to the contract as context\n                const extraData = _parseBytes(data, 128);\n\n                const ccipResult = await this.ccipReadFetch(<Transaction>transaction, calldata, urls);\n                if (ccipResult == null) {\n                    logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                const tx = {\n                    to: txSender,\n                    data: hexConcat([ callbackSelector, encodeBytes([ ccipResult, extraData ]) ])\n                };\n\n                return this._call(tx, blockTag, attempt + 1);\n\n            } catch (error) {\n                if (error.code === Logger.errors.SERVER_ERROR) { throw error; }\n            }\n        }\n\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params: { transaction, blockTag }, result, error\n            });\n        }\n\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const resolved = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag),\n            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n        });\n        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0: -1);\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await this._getResolver(currentName, \"getResolver\");\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new Resolver(this, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n\n    }\n\n    async _getResolver(name: string, operation?: string): Promise<string> {\n        if (operation == null) { operation = \"ENS\"; }\n\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation, network: network.name }\n            );\n        }\n\n        try {\n            // keccak256(\"resolver(bytes32)\")\n            const addrData = await this.call({\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            });\n            return this.formatter.callAddress(addrData);\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n        }\n\n        return null;\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resolver\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddr = await this._getResolver(node, \"lookupAddress\");\n        if (resolverAddr == null) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        const name = _parseString(await this.call({\n            to: resolverAddr,\n            data: (\"0x691f3431\" + namehash(node).substring(2))\n        }), 0);\n\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(node, \"getAvatar\");\n            if (!resolverAddress) { return null; }\n\n            // Try resolving the avatar against the addr.reverse resolver\n            resolver = new Resolver(this, resolverAddress, node);\n            try {\n                const avatar = await resolver.getAvatar();\n                if (avatar) { return avatar.url; }\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n            }\n\n            // Try getting the name and performing forward lookup; allowing wildcards\n            try {\n                // keccak(\"name(bytes32)\")\n                const name = _parseString(await this.call({\n                    to: resolverAddress,\n                    data: (\"0x691f3431\" + namehash(node).substring(2))\n                }), 0);\n                resolver = await this.getResolver(name);\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n                return null;\n            }\n\n        } else {\n            // ENS name; forward lookup with wildcard\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.7.0\";\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction spelunk(value: any, requireData: boolean): null | { message: string, data: null | string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data: null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction checkError(method: string, error: any, params: any): any {\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) { return result.data; }\n\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) { result = spelunk(error, false); }\n\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n\n    // @TODO: Should we spelunk for message too?\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n\n        try {\n            return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"signMessage\",\n                    from: address,\n                    message: data\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        try {\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_legacySignMessage\",\n                    from: address,\n                    message: data\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        try {\n            return await this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_signTypedData\",\n                    from: address,\n                    message: { domain: populated.domain, types, value: populated.value }\n                });\n            }\n            throw error;\n        }\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue(BigNumber.from((<any>transaction)[key]));\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\nexport interface WebSocketLike {\n    onopen: ((...args: Array<any>) => any) | null;\n    onmessage: ((...args: Array<any>) => any) | null;\n    onerror: ((...args: Array<any>) => any) | null;\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string | WebSocketLike, network?: Networkish) {\n\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        if (typeof(url) === \"string\") {\n            super(url, network);\n        } else {\n            super(\"_websocket\", network);\n        }\n\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        } else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this.websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket(): WebSocketLike { return this._websocket; }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this.websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this.websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this.websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this.websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this.websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arb-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-goerli\":\n                host = \"opt-goerli.g.alchemy.com/v2/\"\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\nimport { Network } from \"@ethersproject/networks\";\n\nimport { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport type { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\n\nfunction getHost(name: string): string {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\n\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    readonly apiKey: string;\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        if (apiKey == null) { apiKey = defaultApiKey; }\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || typeof(result.message) !== \"string\" || !result.message.match(/^OK/)) {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string | null;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || null);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-kovan\":\n                return \"https:/\\/api-kovan-optimistic.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey == null);\n    }\n}\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            if (method === \"call\" && params.blockTag) {\n                return provider[method](params.transaction, params.blockTag);\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\n\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: true,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (apiKey == null) {\n            apiKeyObj.applicationId = defaultApplicationId;\n\n        } else if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n\n        } else if (apiKey.applicationId) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"kovan\":\n                host = \"poa-kovan.gateway.pokt.network\";\n                break;\n            case \"matic\":\n                host = \"poly-mainnet.gateway.pokt.network\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai-rpc.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n\n        const connection: ConnectionInfo = { headers: { }, url };\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationId);\n    }\n}\n","\"use strict\";\n\nimport { Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Exported Types\nexport type ExternalProvider = {\n    isMetaMask?: boolean;\n    isStatus?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet _nextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend) : JsonRpcFetchFunc {\n    const fetcher = \"Web3LegacyFetcher\";\n\n    return function(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n\n            sendFunc(request, (error, response) => {\n\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n\n                    return reject(error);\n                }\n\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    (<any>error).code = response.error.code;\n                    (<any>error).data = response.error.data;\n                    return reject(error);\n                }\n\n                resolve(response.result);\n            });\n        });\n    }\n}\n\nfunction buildEip1193Fetcher(provider: ExternalProvider): JsonRpcFetchFunc {\n    return function(method: string, params: Array<any>): Promise<any> {\n        if (params == null) { params = [ ]; }\n\n        const request = { method, params };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n\n            return response;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n\n            throw error;\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string = null;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc = null;\n        let subprovider: ExternalProvider = null;\n\n        if (typeof(provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.request) {\n                if (path === \"\") { path = \"eip-1193:\"; }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\": case \"https\":\n                    return new JsonRpcProvider(network);\n                case \"ws\": case \"wss\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    AnkrProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n"],"names":["logger","Logger","ForkEvent","value","_isForkEvent","Description","Provider","checkAbstract","defineReadOnly","this","resolveProperties","block","getBlock","gasPrice","getGasPrice","catch","error","lastBaseFeePerGas","maxFeePerGas","maxPriorityFeePerGas","baseFeePerGas","BigNumber","mul","add","eventName","listener","on","off","_isProvider","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","push","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","provider","indexOf","name","CloudflareProvider","cloudflare","AnkrProvider","ankr","length","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","chainId","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","throwArgumentError","defaultProvider","decode","textData","atob","data","i","charCodeAt","arrayify","encode","String","fromCharCode","btoa","BaseX","alphabet","charAt","_alphabetMap","source","digits","carry","j","base","string","k","_leader","q","TypeError","bytes","Uint8Array","byte","undefined","Error","reverse","Base58","version","flat","array","depth","result","forEach","flatDeep","arr","call","val","Array","isArray","read_compressed_payload","v","pos","read_payload","u16","symbol_count","total","acc","skip","pos_payload","read_width","read_buffer","read_bit","FULL","Math","HALF","QRTR","MASK","register","symbols","low","range","floor","start","end","mid","a","b","offset","map","x","decode_arithmetic","signed","read_ascending","n","next","read_deltas","read_member_array","lookup","vX","vN","read_counts","read_transposed","w","m","fill","read_linear_table","dx","dy","read_zero_terminated_array","ys","slice","_","j_dy","y","read_replacement_table","r","VALID","Set","IGNORED","MAPPED","ret","fromEntries","read_mapped_map","EMOJI_ROOT","sorted","sort","read","branches","keys","set","node","size","temp","valid","fe0f","save","check","read_emoji_trie","explode_cp","toUtf8CodePoints","filter_fe0f","cps","filter","cp","ens_normalize_post_check","split","label","lastIndexOf","every","err","message","ens_normalize","emoji_filter","input","output","emoji","consume_emoji_reversed","pop","has","toString","toUpperCase","s","fromCodePoint","normalize","eaten","saved","stack","find","_a","splice","Zeros","checkComponent","comp","ensNameSplit","toUtf8Bytes","comps","last","namehash","keccak256","concat","hexlify","sha256","hash","update","digest","getUrl","href","request","method","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetchOptions","opts","fetch","response","arrayBuffer","key","toLowerCase","get","statusCode","status","statusMessage","statusText","staller","duration","Promise","resolve","setTimeout","bodyify","type","isBytesLike","trim","toUtf8String","fetchJson","connection","json","processFunc","updated","shallowCopy","Object","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","errorPassThrough","allow304","timeout","allowGzip","user","password","substring","allowInsecureAuthentication","throwError","argument","authorization","base64Encode","reData","RegExp","dataMatch","match","base64Decode","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","reject","makeError","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","parseInt","random","pow","serverError","throttleRetry","race","_fetchData","JSON","parse","poll","ceiling","interval","done","retryLimit","then","oncePoll","once","onceBlock","Formatter","formats","getDefaultFormats","address","bind","bigNumber","blockTag","hex","number","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasLimit","to","nonce","uint256","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","parentHash","timestamp","difficulty","miner","extraData","transactions","blockWithTransactions","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","toNumber","strict","isHexString","getAddress","hexDataSlice","getContractAddress","hexValue","hexDataLength","hexZeroPad","format","author","_difficulty","_block","gas","isZero","networkId","replace","parseTransaction","byzantium","object","checkKey","checkValue","nullValue","replaceValue","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","log","checkTopic","topic","serializeTopics","unique","join","getEventTag","isForkEvent","warn","getTime","Date","PollableEvents","Event","tag","_lastBlockNumber","_inflight","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","matcherIpfs","matchers","_parseString","_parseBytes","getIpfsLink","link","numPad","padded","bytesPad","ceil","encodeBytes","datas","byteCount","hexConcat","Resolver","resolvedAddress","formatter","_supportsEip2544","eq","code","selector","parameters","tx","ccipReadEnabled","parseBytes","supportsWildcard","CALL_EXCEPTION","_fetch","coinType","hexBytes","coinInfo","operation","words","bech32","unshift","HashZero","callAddress","_fetchBytes","_getAddress","linkage","content","getText","avatar","scheme","_resolvedAddress","owner","addr","tokenId","tokenOwner","balance","metadataUrl","metadata","stringify","imageUrl","image","ipfs","ipns","swarm","skynet","urlSafe","keyBytes","defaultFormatter","nextPollId","BaseProvider","_events","_emitted","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","event","calldata","urls","sender","errorMessages","errorMessage","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","_setFastBlockNumber","pollId","runners","_getInternalBlockNumber","pollingInterval","abs","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","minFromBlock","getLogs","all","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","now","getBlockNumber","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","__awaiter","getTransactionCount","getTransaction","mined","getBlockWithTransactions","ti","waitForTransaction","reason","cancelled","replacement","_wrapTransaction","unref","addressOrName","_getBlockTag","params","position","p","expectedHash","returnedHash","wait","confirms","signedTransaction","t","hexTx","values","redirects","txSender","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipReadFetch","ccipResult","_call","SERVER_ERROR","_getTransactionRequest","resolved","resolveName","blockHashOrBlockTag","includeTransactions","blockWithTxs","_getBlock","_getFilter","currentName","_getResolver","resolver","addrData","getResolver","resolverAddr","nameOrAddress","resolverAddress","getAvatar","e","pollable","_startEvent","_addEventListener","args","stopped","eventTag","apply","_stopEvent","removeAllListeners","found","allowedTransactionKeys","forwardErrors","Signer","_checkProvider","getBalance","checkTransaction","estimateGas","populateTransaction","signTransaction","signedTx","sendTransaction","getFeeData","hasEip1559","feeData","getChainId","results","_isSigner","id","text","padding","NegativeOne","Zero","One","MaxUint256","hexTrue","hexFalse","domainFieldTypes","verifyingContract","salt","domainFieldNames","checkString","domainChecks","getBaseEncoder","width","boundsUpper","mask","boundsLower","lt","gt","toTwos","padOffset","hexPadRight","encodeType","fields","TypedDataEncoder","types","freeze","deepCopy","links","parents","subtypes","uniqueNames","field","baseType","primaryTypes","checkCircular","child","subtype","primaryType","st","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","encodeData","hashStruct","callback","_visit","reduce","accum","domain","domainFields","EIP712Domain","hashDomain","ensCache","visit","domainValues","domainTypes","typesWithDomain","errorGas","spelunk","requireData","checkError","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","constructor","hexlifyTransaction","action","sendUncheckedTransaction","_TypedDataEncoder","populated","networkOrReady","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","getSigner","connectUnchecked","jsonrpc","prepareRequest","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","allowed","checkProperties","WS","WebSocket","NextId","WebSocketProvider","_wsReady","websocket","onopen","_requests","onmessage","messageEvent","sub","_subs","subscription","fauxPoll","_websocket","_detectNetwork","rid","param","subIdPromise","_subIds","subId","_subscribe","emitReceipt","readyState","CONNECTING","onerror","close","StaticJsonRpcProvider","_super","UrlJsonRpcProvider","apiKey","defaultApiKey","AlchemyWebSocketProvider","host","arguments","getHost","projectSecret","getTransactionPostData","maxFeePerGs","storageKeys","getJsonResult","checkLogTag","getBaseUrl","module","query","baseUrl","apikey","post","getPostUrl","getPostData","procFunc","payloadStr","txhash","postData","topic0","blocks","parseFloat","ethusd","endBlock","startblock","endblock","item","timeStamp","shuffled","tmp","checkNetworks","median","maxDelta","middle","serialize","nextRid","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","getProcessFunc","configs","c","_highestBlockNumber","tally","count","normalizedTally","waitForSync","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","first","t0","inflightWeight","backend","waiting","errors","errorCode","props","IpcProvider","defaultProjectId","InfuraWebSocketProvider","projectId","apiKeyObj","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationId","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider"],"sourceRoot":""}